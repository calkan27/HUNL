{"file":"action.py","doc":"Action object representing a player decision.\n\nMethods\n-------\n\nClasses\n-------\n- Action: Lightweight wrapper around an ActionType with a readable repr and a kind property."}
{"file":"action_type.py","doc":"Enumeration of all supported betting actions in the sparse action set.\n\nMethods\n-------\n\nClasses\n-------\n- ActionType: Enum of FOLD, CALL, HALF_POT_BET, POT_SIZED_BET, TWO_POT_BET, ALL_IN."}
{"file":"agent.py","doc":"High-level agent façade that wires the CFR solver, clustering, and device management for play/serve.\n\nMethods\n-------\n- set_device(device): Move all models to the requested device string.\n- set_latency_profile(round_iters=None): Configure per-round iteration budgets.\n- act(public_state, our_private_cards): Compute an action for the current public state.\n- observe_opponent_action(prev_public_state, new_public_state, observed_action_type): Update ranges on opponent action.\n- observe_chance(new_public_state): Update ranges on chance reveals.\n- load_bundle(path): Load and apply a CFV bundle to the solver.\n\nClasses\n-------\n- Agent: Orchestrates CFRSolver, HandClusterer, and device/model plumbing."}
{"file":"aivat.py","doc":"AIVAT evaluator for low-variance performance estimation using control variates.\n\nMethods\n-------\n\nClasses\n-------\n- AIVATEvaluator: Computes AIVAT corrections over an episode; exposes evaluate(episode)." }
{"file":"bucketed_range.py","doc":"Utilities for mapping between hand-level probabilities and bucketized ranges.\n\nMethods\n-------\n\nClasses\n-------\n- BucketedRange: Bidirectional mapping hand↔bucket with normalization helpers."}
{"file":"card.py","doc":"Typed representation of a playing card using Rank and Suit enums.\n\nMethods\n-------\n\nClasses\n-------\n- Card: Immutable rank/suit pair; supports string parsing via from_string and pretty **str**."}
{"file":"cfr_core.py","doc":"Public-chance CFR re-solver used at VALUE boundaries with gadgets and sparse actions.\n\nMethods\n-------\n\nClasses\n-------\n- PublicChanceCFR: Implements regret updates, sampling traversal, and solve_subgame with constraints."}
{"file":"cfr_solver.py","doc":"End-to-end continual re-solving engine with depth limits, CFV nets, and range gadgets.\n\nMethods\n-------\n- reset(): Clear iteration state and caches.\n- run_cfr(node): Re-solve at node and return an Action.\n- set_cfr_hybrid_config(preflop_omit=None, flop_omit=None, turn_omit=None, river_omit=None, round_iters=None, round_flags=None): Configure budgets and action flags.\n- flop_label_targets_using_turn_net(node): Produce flop labels using the turn net.\n- turn_label_targets_solve_to_terminal(node): Produce turn labels by solving to terminal.\n\nClasses\n-------\n- CFRSolver: Composes mixins for models, strategies, caching, diagnostics, and utils."}
{"file":"cfr_solver_caching.py","doc":"Preflop cache and related helpers for signatures, clustering signatures, and strength eval.\n\nMethods\n-------\n\nClasses\n-------\n- CFRSolverCachingMixin: Adds preflop LRU cache, hand-strength eval, and recursive range sampling to CFRSolver."}
{"file":"cfr_solver_diagnostics.py","doc":"Diagnostics for continual re-solving: regret norms, entropy, and zero-sum residuals.\n\nMethods\n-------\n\nClasses\n-------\n- CFRSolverDiagnosticsMixin: Computes metrics and exposes get_last_diagnostics()."}
{"file":"cfr_solver_models.py","doc":"Model management for CFV networks: load, share, shape checks, inputs/outputs, predictions.\n\nMethods\n-------\n- load_models(): Load stage models from disk with fallbacks.\n- calculate_input_size(): Compute input size for flop/turn nets.\n- calculate_input_size_preflop(): Compute preflop input size.\n- prepare_input_vector(node): Build network input for street with board + ranges.\n- prepare_input_vector_preflop(node): Build preflop input.\n- predict_counterfactual_values(node, player): Query stage model and enforce zero-sum.\n- apply_cfv_bundle(bundle, device=None): Apply pre-loaded networks and metadata.\n\nClasses\n-------\n- CFRSolverModelsMixin: Utilities to manage CFV networks and I/O conventions."}
{"file":"cfr_solver_strategies.py","doc":"Strategy computation, masking by legal actions, and posterior updates to player ranges.\n\nMethods\n-------\n- get_cumulative_strategy(player): Aggregate strategy over all nodes.\n- update_player_range(node, player, cluster_id, action_index): Bayes-consistent update.\n- _allowed_actions_agent(ps): Compute legal actions respecting round flags.\n- _allowed_actions_opponent(ps): Mirror of agent action legality.\n- _mask_strategy(base_strategy, allowed_actions): Normalize masked policy.\n- _mixed_action_distribution(node, player, allowed_actions): Average strategy weighted by priors.\n\nClasses\n-------\n- CFRSolverStrategiesMixin: Strategy math and action menus for CFR."}
{"file":"cfr_solver_utils.py","doc":"General utilities for cards, stages, range manipulation, and range gadget plumbing.\n\nMethods\n-------\n- generate_all_possible_hands(): Enumerate all unique hole-card pairs.\n- _stable_seed(entity, board): Deterministic seed from context.\n- _player_wins(player_hand, opponent_hand, board): Compare hands.\n- get_stage(node): Map current_round to stage string.\n- lift_ranges_after_chance(node): Reweight ranges after board updates.\n- apply_opponent_action_update(prev_node, new_node, observed_action_type): Update trackers.\n- update_tracking_on_own_action(node, agent_player=0, counterfactual_values=None): Track own posteriors and opp upper bounds.\n- apply_round_iteration_schedule(round_index): Set total_iterations by round.\n\nClasses\n-------\n- CFRSolverUtilsMixin: Shared helpers mixed into CFRSolver."}
{"file":"cfr_values.py","doc":"Per-cluster regret tables, average strategy, and pruning/rehabilitation logic.\n\nMethods\n-------\n\nClasses\n-------\n- CFRValues: Stores cumulative regrets/strategies; computes current/average strategy; prunes/reactivates actions."}
{"file":"cfv_network.py","doc":"Neural network architecture for counterfactual values with a differentiable zero-sum outer layer.\n\nMethods\n-------\n- make_cfv_network(input_size, num_clusters): Factory.\n- build_three_stage_cfv(input_size_preflop, input_size_flop, input_size_turn, num_clusters, device=None): Build staged models.\n\nClasses\n-------\n- CounterfactualValueNetwork: 7×500 PReLU MLP with enforce_zero_sum and predict helpers."}
{"file":"cfv_shard_dataset.py","doc":"Iterable dataset that streams JSONL shards of CFV training examples with optional schema checks.\n\nMethods\n-------\n\nClasses\n-------\n- CFVShardDataset: Iterates shard files line-by-line and yields parsed examples."}
{"file":"cfv_stream_dataset.py","doc":"On-the-fly CFV training sample generator wrapping a DataGenerator-like source.\n\nMethods\n-------\n\nClasses\n-------\n- CFVStreamDataset: Iterates a configured number of samples and yields records with spec metadata."}
{"file":"cfv_trainer.py","doc":"Generic trainer for CFV networks using Huber loss and zero-sum outer adjustment.\n\nMethods\n-------\n- train_cfv_network(model, train_samples, val_samples, epochs=350, batch_size=1000, lr=1e-3, lr_drop_epoch=200, lr_after=1e-4, weight_decay=1e-6, device=None, seed=None, early_stop_patience=30, min_delta=0.0): Train loop with early stopping.\n\nClasses\n-------\n"}
{"file":"cfv_trainer_flop.py","doc":"Flop CFV trainer with optional turn-net target provider and checkpointing.\n\nMethods\n-------\n- train_flop_cfv(model, train_samples, val_samples, epochs=200, batch_size=1000, lr=1e-3, lr_after=1e-4, lr_drop_epoch=150, weight_decay=1e-6, device=None, seed=None, ckpt_dir=None, save_best=True, target_provider=None, turn_model=None, turn_device=None, early_stop_patience=30, min_delta=0.0): Train flop net.\n- default_turn_leaf_target_provider(xb, y1b, y2b, turn_model): Build flop targets via turn net.\n\nClasses\n-------\n"}
{"file":"cfv_trainer_turn.py","doc":"Turn CFV training utilities supporting list and streaming datasets with eval helpers.\n\nMethods\n-------\n- batcher_from_iter(samples_iter, bs, device): Batch an iterator of records.\n- eval_stream(model, samples_iter, batch_size, device, K, criterion): Evaluate streaming source.\n- train_turn_cfv(model, train_samples, val_samples, ...): Train turn net on lists.\n- train_turn_cfv_streaming(model, train_iter, val_iter=None, ...): Train turn net on streams.\n\nClasses\n-------\n"}
{"file":"compat_linear_cfv.py","doc":"Linear projection CFV model compatible with stored state_dicts; includes zero-sum wrapper.\n\nMethods\n-------\n\nClasses\n-------\n- CompatLinearCFV: Single Linear head producing two K-vectors with enforce_zero_sum."}
{"file":"config_io.py","doc":"Read/write configs (JSON/YAML), compose ResolveConfig from YAML triplet, and seed control.\n\nMethods\n-------\n- save_config(config, path): Persist config dict/dataclass.\n- load_config(path): Load JSON/YAML.\n- compose_resolve_config_from_yaml(abstraction_yaml_path, value_nets_yaml_path, solver_yaml_path, overrides=None): Merge files into ResolveConfig + runtime overrides.\n\nClasses\n-------\n"}
{"file":"data_generator.py","doc":"Synthetic data generation for CFV training using the live solver + clustering on sampled boards.\n\nMethods\n-------\n- generate_training_data(stage='flop', progress=None): Produce records for a board set.\n- compute_counterfactual_values(node): Query solver CFVs for both players.\n- prepare_input_vector(player_ranges_bucketed, public_cards, pot_size, actions=None): Build input vector.\n- prepare_target_values(counterfactual_values, pot_size=None): Normalize targets.\n\nClasses\n-------\n- DataGenerator: Configurable generator mixing sampling, datasets, and utilities via mixins."}
{"file":"data_generator_datasets.py","doc":"Dataset writers and production guards for generating NPZ shards plus metadata/manifests.\n\nMethods\n-------\n- generate_turn_dataset(num_situations, out_dir, chunk_size=50000, seed=2027): Persist turn data.\n- generate_flop_dataset(num_situations, out_dir, chunk_size=50000, seed=2027, persist_format='npz'): Persist flop data.\n- generate_flop_dataset_using_turn(turn_model, num_situations, out_dir=None, ...): Create flop data using a turn net.\n\nClasses\n-------\n- DataGeneratorDatasetsMixin: Adds meta/specs, chunking, and guard helpers."}
{"file":"data_generator_sampling.py","doc":"Sampling policies for boards, ranges, and game-node construction for flop/turn situations.\n\nMethods\n-------\n- _sample_random_range(cluster_ids): Recursively sample a normalized range over clusters.\n- _sample_flop_situation(rng): Build a flop GameNode with ranges.\n- _sample_turn_situation(rng): Build a turn GameNode with ranges.\n- sample_pot_size(): Draw a pot size from fixed bins.\n- pot_sampler_spec(): Describe the sampler.\n- range_generator_spec(): Describe the range generator.\n\nClasses\n-------\n- DataGeneratorSamplingMixin: Sampling utilities for DataGenerator."}
{"file":"data_generator_utils.py","doc":"Utilities for normalization, bucketing, mapping hands↔clusters, seeds, and invariants.\n\nMethods\n-------\n- normalize_cluster_probabilities(ranges_list): Normalize per-cluster masses.\n- bucket_player_ranges(ranges_pair): Convert dicts→dense lists and normalize.\n- _push_leaf_override(stage): Temporarily adjust solver depth/iters for label generation.\n- _pop_leaf_override(snap): Restore solver settings.\n- get_round_from_stage(stage): Map stage name→round index.\n- set_seed(seed): Seed Python/NumPy/Torch consistently.\n- expected_total_steps(): Estimate generation steps.\n- _recursive_R(hands_set, total_prob, public_cards): Fallback range sampler.\n- _assert_sampler_invariants(public_cards, ranges_pair, pot_size): Validate inputs.\n- map_hands_to_clusters(hand_probs, clusters): Aggregate to cluster space.\n- _push_production_mode(): Switch to production guard settings.\n- _pop_production_mode(snap): Restore production guard.\n\nClasses\n-------\n- DataGeneratorUtilsMixin: Utility mixin for DataGenerator."}
{"file":"data_manifest.py","doc":"Create and persist JSON manifests describing generation specs and action sets.\n\nMethods\n-------\n- make_manifest(data_generator, stage, seed, extras=None): Build manifest dict.\n- save_manifest(manifest, path): Write manifest file.\n\nClasses\n-------\n"}
{"file":"eval_cli.py","doc":"CLI to run agent-vs-agent or agent-vs-policy matches and compute AIVAT/CI summaries.\n\nMethods\n-------\n- main(argv=None): Parse args and run evaluation.\n\nClasses\n-------\n"}
{"file":"eval_cli_lbr.py","doc":"Local Best Response (LBR) evaluation harness targeting flop strategy and sanity checks.\n\nMethods\n-------\n- run_lbr_eval(episodes=10000, seed=1729, cfg=None, policy_iters_agent=2, policy_iters_after_lbr=2): Run one trial.\n- run_lbr_acceptance(seeds, episodes=10000, cfg=None, policy_iters_agent=2, policy_iters_after_lbr=2): Union-CI acceptance.\n\nClasses\n-------\n"}
{"file":"eval_cli_utils.py","doc":"Shared utilities for evaluation: policies from solver, sparse menus, sanity checks, and diagnostics.\n\nMethods\n-------\n- flop_turn_leaf_sanity(samples=5, seed=2027): Instrument calls to nets along hands.\n\nClasses\n-------\n"}
{"file":"game_node.py","doc":"Immutable-ish wrapper around PublicState that carries ranges, players-in-hand, and hashing.\n\nMethods\n-------\n\nClasses\n-------\n- GameNode: Holds public_state and per-player ranges; provides equality/hash via serialized public signature."}
{"file":"hand_clusterer.py","doc":"Hand clustering orchestrator: features, k-means style assignment, fast-test path, and mapping.\n\nMethods\n-------\n- cluster_hands(hands, board, opponent_range, pot_size): Produce cluster→hand sets.\n- fit(hands, board, opponent_range, pot_size, K=None, stage=None): Fit clusters for a board.\n- assign(hand, board): Determine a cluster id for a hand.\n- set_num_clusters(K): Update K used by the clusterer.\n- hand_to_bucket_on_board(hand, board): Map hand on board to cluster.\n\nClasses\n-------\n- HandClusterer: Combines feature extraction and utils; supports caches and drift-based reuse."}
{"file":"hand_clusterer_features.py","doc":"Feature space and MC-based equity/potential/payoff proxies for clustering.\n\nMethods\n-------\n- calculate_hand_features(hand, board, opponent_range, pot_size): Return normalized feature vector.\n\nClasses\n-------\n- HandClustererFeaturesMixin: Provides feature computation and distances."}
{"file":"hand_clusterer_utils.py","doc":"Utility helpers for clustering: mappings, preflop typing, drift detection, and deterministic seeds.\n\nMethods\n-------\n- get_cluster_ranges(): Uniform over K clusters.\n- hand_to_bucket(hand): Hash/lookup mapping.\n- hands_to_bucket_range(hand_probs): Aggregate hands→cluster masses.\n- bucket_range_to_hand_weights(bucket_probs): Spread cluster mass back to hands.\n- persist_mapping(): Export cluster mapping.\n- load_mapping(mapping): Load mapping into clusterer.\n\nClasses\n-------\n- HandClustererUtilsMixin: Support routines for cluster bookkeeping and stability."}
{"file":"lookahead_tree.py","doc":"Public-tree builder and reach propagation for sparse action lookahead with chance branching.\n\nMethods\n-------\n\nClasses\n-------\n- LookaheadTreeBuilder: Builds tree (our/opp/chance/leaf), sets leaf callback, and propagates ranges/values."}
{"file":"model_io.py","doc":"Serialization for CFV bundles (models + cluster mapping + input meta) with robust loading.\n\nMethods\n-------\n- save_cfv_bundle(models, cluster_mapping, input_meta, path, seed=None): Write a portable bundle.\n- load_cfv_bundle(path, device=None): Load bundle and create compatible models.\n\nClasses\n-------\n"}
{"file":"play_cli.py","doc":"CLI to run continual play with online re-solving, optional ACPC-like client mode, and logging.\n\nMethods\n-------\n- run_continual_cli(argv=None): Parse args and run the interactive loop.\n\nClasses\n-------\n"}
{"file":"poker_utils.py","doc":"Card encodings, deck utilities, 7-card evaluator bridge, and board one-hot features.\n\nMethods\n-------\n- get_rank(card): Return rank char.\n- get_suit(card): Return suit char.\n- card_to_index(card): Map card to [0,51].\n- board_one_hot(board): 52-dim one-hot of public cards.\n- evaluate_7card(hole, board): Rank a 7-card hand.\n\nClasses\n-------\n- Card: Low-level integer bit-encoding helpers.\n- LookupTable: Precomputed tables for flush/unsuited ranks.\n- Evaluator: 5,6,7-card evaluation convenience."}
{"file":"public_state.py","doc":"Single source of truth for HUNL public state with actions, streets, and utility rules.\n\nMethods\n-------\n- clone(): Deep-ish copy of the state.\n- copy(): Alias for clone.\n- legal_actions(): Compute legal action menu.\n- terminal_utility(): Compute terminal utilities for each player.\n- street_index(): Current round index.\n- board_one_hot(): Board 1-hot encoding.\n- public_summary(): Small dict summary.\n- pot_normalized(): Pot size normalized by total initial stacks.\n- to_canonical(): Canonical state features for learning.\n\nClasses\n-------\n- PublicState: Composes Actions/Streets/Utils mixins; immutable-ish transitions via update methods in mixins."}
{"file":"public_state_actions.py","doc":"Deterministic state transitions for fold/call/bet/raise/all-in and exogenous opponent actions.\n\nMethods\n-------\n- PublicStateActionsMixin.update_state(node, action): Apply action and return a new state.\n- PublicStateActionsMixin.apply_exogenous_opponent_check(actor): Force a legal check.\n- PublicStateActionsMixin.apply_exogenous_opponent_bet(bettor, kind): Force a legal bet/raise.\n- PublicStateActionsMixin.apply_exogenous_opponent_all_in(bettor): Force a legal all-in.\n\nClasses\n-------\n- PublicStateActionsMixin: Transition logic with accounting and invariants."}
{"file":"public_state_streets.py","doc":"Street bookkeeping, min-raise computation, fast-forward to showdown, and street advance.\n\nMethods\n-------\n\nClasses\n-------\n- PublicStateStreetsMixin: Encapsulates street-level rules and card dealing policies."}
{"file":"public_state_utils.py","doc":"Common helpers mirrored on PublicState for terminal utilities and canonical features.\n\nMethods\n-------\n- PublicStateUtilsMixin.terminal_utility(): Compute terminal utilities.\n- PublicStateUtilsMixin.street_index(): Round index.\n- PublicStateUtilsMixin.board_one_hot(): 52-dim board encoding.\n- PublicStateUtilsMixin.public_summary(): Small feature dict.\n- PublicStateUtilsMixin.pot_normalized(): Pot normalization.\n- PublicStateUtilsMixin.to_canonical(): Canonical features.\n- PublicStateUtilsMixin.legal_actions(): Legal action menu.\n\nClasses\n-------\n- PublicStateUtilsMixin: Utility mixin used by PublicState."}
{"file":"range_gadget.py","doc":"Per-state range gadget maintaining a non-increasing upper bound vector over opponent CFVs.\n\nMethods\n-------\n\nClasses\n-------\n- RangeGadget: Begin/update/get upper-bound dictionary across re-solves."}
{"file":"rank.py","doc":"Enum of card ranks with helper to render the canonical single-character symbol.\n\nMethods\n-------\n\nClasses\n-------\n- Rank: IntEnum 2..Ace with symbol() printer."}
{"file":"resolve_config.py","doc":"Dataclass of run-time configuration and environment-driven defaults for reproduction.\n\nMethods\n-------\n- ResolveConfig.from_env(overrides=None): Construct config with FAST_TESTS-aware defaults.\n\nClasses\n-------\n- ResolveConfig: Parameters for abstraction, nets, solver budgets, and profiles."}
{"file":"resolver_integration.py","doc":"Thin integration layer that builds lookahead trees, calls CFR-D with gadgets, and enforces acceptance checks.\n\nMethods\n-------\n- resolve_at(public_state, r_us, w_opp, config=None, value_server=None): Re-solve once and return (policy, next_opp_upper, our_cfv).\n- resolve_at_with_diag(public_state, r_us, w_opp, config=None, value_server=None): Re-solve and also return diagnostics.\n\nClasses\n-------\n"}
{"file":"result_handle.py","doc":"Threaded result handle used by ValueServer for async batched predictions.\n\nMethods\n-------\n\nClasses\n-------\n- ResultHandle: Waits on an event and returns tensors (numpy or torch)." }
{"file":"review_finder_libcst.py","doc":"Static analysis tool using LibCST to flag constructs that require HUMAN REVIEW before strict refactors.\n\nMethods\n-------\n- main(): CLI entry to scan a project and write a JSON report.\n\nClasses\n-------\n- ReviewCollector: CSTVisitor collecting try/except, raise, nested functions, and ternary if-exprs."}
{"file":"river_bucket_aux.py","doc":"Auxiliary network mapping bucket-mix features to cluster values with zero-sum enforcement.\n\nMethods\n-------\n\nClasses\n-------\n- RiverBucketAux: MLP head with enforce_zero_sum/predict helpers for river abstractions."}
{"file":"river_endgame.py","doc":"River endgame evaluator: bucketization flows or exact pairwise payoffs to compute per-cluster EVs.\n\nMethods\n-------\n\nClasses\n-------\n- RiverEndgame: Computes cluster CFVs on river (bucketed or unbucketed) with sampling limits."}
{"file":"seeded_rng.py","doc":"Global seeding utilities to coordinate Python/NumPy/Torch RNG state.\n\nMethods\n-------\n- set_global_seed(seed): Initialize RNGs and return the set seed.\n\nClasses\n-------\n- SeededRNG: Small wrapper exposing rand, randint, choice with synchronized seeds."}
{"file":"smoke_eval.py","doc":"Quick smoke tests for solver integrity, speed, and zero-sum properties; prints summary metrics.\n\nMethods\n-------\n- main_basic(): Minimal pass/fail checks for residual, mass, and pot monotonicity.\n- main(): Extended instrumentation with counters, timings, and summary.\n\nClasses\n-------\n"}
{"file":"smoke_eval_checks.py","doc":"Helper assertions for smoke tests: zero-sum residual, mass conservation, pot monotonicity.\n\nMethods\n-------\n- zero_sum_residual_ok(solver, node, tol=1e-6): Check enforced zero-sum at leaf.\n- mass_conservation_ok(node, tol=1e-12): Validate range sums.\n- nonnegative_pot_deltas_ok(ps): Ensure no negative pot deltas in a bet+call.\n- pot_monotonicity_ok_sequence(ps, steps=6, allowed_actions=None): Multi-step non-decreasing pot.\n- verify_outer_zero_sum_residual(models, K, samples=1000, tol=1e-6, seed=1729): Stress the outer zero-sum.\n\nClasses\n-------\n"}
{"file":"smoke_eval_utils.py","doc":"Instrumentation for value-net call counting, timing, and preflop cache statistics.\n\nMethods\n-------\n- instrument_value_nets(solver): Wrap predict_counterfactual_values and count calls.\n- measure_resolve_time(solver, node, trials=5): Measure mean wall time per resolve.\n- preflop_cache_hit_rate(solver, node, trials=6): Estimate Δ hit-rate and cache stats.\n\nClasses\n-------\n"}
{"file":"smoke_poker_utils.py","doc":"Ad-hoc smoke for card normalization and small test assertions.\n\nMethods\n-------\n- test_card_normalization_smoke(): Minimal sanity test for _to_str_card/_normalize_cards.\n\nClasses\n-------\n"}
{"file":"value_server.py","doc":"Threaded micro-batching prediction server for CFV models with zero-sum residual tracking.\n\nMethods\n-------\n- ValueServer.start(): Launch worker thread.\n- ValueServer.stop(join=True): Stop worker.\n- ValueServer.query(stage, inputs, scale_to_pot=False, as_numpy=True, total_initial=None): Enqueue a single request.\n- ValueServer.query_many(stage, batch_inputs, scale_to_pot=False, as_numpy=True, total_initial=None): Enqueue a batch.\n- ValueServer.get_counters(): Return per-stage query counts.\n\nClasses\n-------\n- ValueServer: Accepts CFV model dict and serves predictions via an internal queue."}

