--- a/resolver_integration.py
+++ b/resolver_integration.py
@@ -8,169 +8,90 @@
 from cfr_core import PublicChanceCFR
 
 def resolve_at(public_state, r_us: Dict[int, float], w_opp: Dict[int, float], config: Optional[Dict[str, Any]] = None, value_server: Optional[ValueServer] = None) -> Tuple[Dict[Any, float], Dict[int, float], Dict[int, float]]:
-	if config is None:
-		config = {}
-	stage_map = {0: "preflop", 1: "flop", 2: "turn", 3: "river"}
-	cr = int(getattr(public_state, "current_round", 0))
-	stage = stage_map.get(cr, "none")
-	if stage not in ("flop", "turn"):
-		stage = "flop"
-	K = int(len(r_us))
-	def _to_vec(d: Dict[int, float], k: int) -> List[float]:
-		v = [0.0] * k
-		s = 0.0
-		for i, p in d.items():
-			ii = int(i)
-			if 0 <= ii < k:
-				v[ii] = float(p)
-				s += float(p)
-		if s > 0.0:
-			for i in range(k):
-				v[i] = v[i] / s
-		return v
-	r_our_vec = _to_vec(r_us, K)
-	r_opp_init = config.get("r_opp_init", None)
-	if isinstance(r_opp_init, dict):
-		r_opp_vec = _to_vec(r_opp_init, K)
-	else:
-		if K > 0:
-			u = 1.0 / float(K)
-			r_opp_vec = [u] * K
-		else:
-			r_opp_vec = []
-	w_vec = _to_vec(w_opp, K)
-	if value_server is None:
-		value_server = ValueServer(models={})
-	depth_limit = int(config.get("depth_limit", 1))
-	bet_fractions = list(config.get("bet_fractions", ([0.5, 1.0] if stage == "flop" else [0.5, 1.0, 2.0])))
-	builder = LookaheadTreeBuilder(
-		depth_limit=depth_limit,
-		bet_fractions=bet_fractions,
-		include_all_in=True
-	)
-	root = builder.build(public_state)
-	def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
-		total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
-		if total_initial <= 0.0:
-			total_initial = 1.0
-		pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
-		bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
-		x = [pot_norm] + list(bvec) + list(r1) + list(r2)
-		xt = torch.tensor([x], dtype=torch.float32)
-		st = "turn" if int(getattr(ps, "current_round", 2)) == 2 else "flop"
-		v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
-		out = v1 if int(pov_player) == 0 else v2
-		return out[0]
-	T = int(config.get("iterations", 1000))
-	cfr = PublicChanceCFR(
-		depth_limit=depth_limit,
-		bet_fractions=bet_fractions,
-		include_all_in=True,
-		regret_matching_plus=bool(config.get("rm_plus", True)),
-		importance_weighting=True
-	)
-	root_policy, node_values, opp_cfv = cfr.solve_subgame(
-		root_node=root,
-		r_us=r_our_vec,
-		r_opp=r_opp_vec,
-		opp_cfv_constraints=w_vec,
-		T=T,
-		leaf_value_fn=_leaf_value_fn
-	)
-	our_cfv_vec = {}
-	if isinstance(node_values, dict):
-		for i, v in node_values.items():
-			our_cfv_vec[int(i)] = float(v)
-	return root_policy, {int(k): float(v) for k, v in opp_cfv.items()}, our_cfv_vec
+        if config is None:
+                config = {}
+        stage_map = {0: "preflop", 1: "flop", 2: "turn", 3: "river"}
+        cr = int(getattr(public_state, "current_round", 0))
+        stage = stage_map.get(cr, "none")
+        if stage not in ("flop", "turn"):
+                stage = "flop"
+        K = int(len(r_us))
+        def _to_vec(d: Dict[int, float], k: int) -> List[float]:
+                v = [0.0] * k
+                s = 0.0
+                for i, p in d.items():
+                        ii = int(i)
+                        if 0 <= ii < k:
+                                pi = float(p)
+                                v[ii] = pi
+                                s += pi
+                if s > 0.0:
+                        for i in range(k):
+                                v[i] = v[i] / s
+                return v
+        r_our_vec = _to_vec(r_us, K)
+        r_opp_init = config.get("r_opp_init", None)
+        if isinstance(r_opp_init, dict):
+                r_opp_vec = _to_vec(r_opp_init, K)
+        else:
+                if K > 0:
+                        u = 1.0 / float(K)
+                        r_opp_vec = [u] * K
+                else:
+                        r_opp_vec = []
+        w_vec = _to_vec(w_opp, K)
+        if value_server is None:
+                if "value_server" in config and isinstance(config["value_server"], ValueServer):
+                        value_server = config["value_server"]
+                elif "models" in config and isinstance(config["models"], dict):
+                        value_server = ValueServer(models=config["models"], device=config.get("device", None))
+                elif "bundle_path" in config and isinstance(config["bundle_path"], str):
+                        loaded = load_cfv_bundle(config["bundle_path"], device=config.get("device", None))
+                        value_server = ValueServer(models=loaded.get("models", {}), device=config.get("device", None))
+                else:
+                        value_server = ValueServer(models={})
+        depth_limit = int(config.get("depth_limit", 1))
+        if "bet_fractions" in config:
+                bet_fractions = list(config["bet_fractions"])
+        else:
+                bet_fractions = [0.5, 1.0, 2.0] if stage == "turn" else [0.5, 1.0]
+        include_all_in = True
+        builder = LookaheadTreeBuilder(depth_limit=depth_limit, bet_fractions=bet_fractions, include_all_in=include_all_in)
+        root = builder.build(public_state)
+        def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
+                total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
+                if total_initial <= 0.0:
+                        total_initial = 1.0
+                pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
+                bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
+                x = [pot_norm] + list(bvec) + list(r1) + list(r2)
+                xt = torch.tensor([x], dtype=torch.float32)
+                st = "turn" if int(getattr(ps, "current_round", 2)) == 2 else "flop"
+                v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
+                out = v1 if int(pov_player) == 0 else v2
+                return out[0]
+        T = int(config.get("iterations", 1000))
+        cfr = PublicChanceCFR(
+                depth_limit=depth_limit,
+                bet_fractions=bet_fractions,
+                include_all_in=include_all_in,
+                regret_matching_plus=bool(config.get("rm_plus", True)),
+                importance_weighting=True
+        )
+        root_policy, node_values, opp_cfv = cfr.solve_subgame(
+                root_node=root,
+                r_us=r_our_vec,
+                r_opp=r_opp_vec,
+                opp_cfv_constraints=w_vec,
+                T=T,
+                leaf_value_fn=_leaf_value_fn
+        )
+        our_cfv_vec = {}
+        if isinstance(node_values, dict):
+                for i, v in node_values.items():
+                        try:
+                                our_cfv_vec[int(i)] = float(v)
+                        except Exception:
+                                continue
+        return root_policy, {int(k): float(v) for k, v in opp_cfv.items()}, our_cfv_vec
 
-
-	def continual_re_solve_step(public_state, r_us: Dict[int, float], w_opp: Dict[int, float], config: Optional[Dict[str, Any]] = None, value_server: Optional[ValueServer] = None, warm_start: Optional[Dict[Any, List[float]]] = None) -> Tuple[Dict[Any, float], Dict[int, float], Dict[int, float], Dict[int, float], Dict[Any, List[float]]]:
-		if config is None:
-			config = {}
-		K = max(0, max(r_us.keys(), default=-1) + 1)
-		def _norm_range(d: Dict[int, float]) -> List[float]:
-			v = [0.0] * K
-			s = 0.0
-			for i, p in d.items():
-				ii = int(i)
-				if 0 <= ii < K:
-					v[ii] = float(p)
-					s += float(p)
-			if s > 0.0:
-				for i in range(K):
-					v[i] = v[i] / s
-			return v
-		def _to_dict(v: List[float]) -> Dict[int, float]:
-			out = {}
-			for i, x in enumerate(v):
-				if x > 0.0:
-					out[int(i)] = float(x)
-			return out
-		stage_map = {0: "preflop", 1: "flop", 2: "turn", 3: "river"}
-		cr = int(getattr(public_state, "current_round", 0))
-		stage = stage_map.get(cr, "none")
-		if stage not in ("flop", "turn"):
-			stage = "flop"
-		r_our_vec = _norm_range(r_us)
-		w_vec = _norm_range(w_opp)
-		if value_server is None:
-			value_server = ValueServer(models={})
-		depth_limit = int(config.get("depth_limit", 1))
-		bet_fractions = list(config.get("bet_fractions", ([0.5, 1.0] if stage == "flop" else [0.5, 1.0, 2.0])))
-		builder = LookaheadTreeBuilder(depth_limit=depth_limit, bet_fractions=bet_fractions, include_all_in=True)
-		root = builder.build(public_state)
-		def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
-			total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
-			if total_initial <= 0.0:
-				total_initial = 1.0
-			pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
-			bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
-			x = [pot_norm] + list(bvec) + list(r1) + list(r2)
-			xt = torch.tensor([x], dtype=torch.float32)
-			st = "turn" if int(getattr(ps, "current_round", 2)) == 2 else "flop"
-			v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
-			return (v1 if int(pov_player) == 0 else v2)[0]
-		T = int(config.get("iterations", 1000))
-		cfr = PublicChanceCFR(depth_limit=depth_limit, bet_fractions=bet_fractions, include_all_in=True, regret_matching_plus=bool(config.get("rm_plus", True)), importance_weighting=True)
-		if warm_start:
-			cfr.set_warm_start(warm_start)
-		root_policy, node_values, opp_cfv = cfr.solve_subgame(root_node=root, r_us=r_our_vec, r_opp=_norm_range({i: 1.0 / float(K) for i in range(K)} if K > 0 else {}), opp_cfv_constraints=w_vec, T=T, leaf_value_fn=_leaf_value_fn)
-		policy_vec = [0.0] * K
-		for a, p in root_policy.items():
-			policy_vec[0] += float(p)
-		r_next = r_our_vec[:]
-		act_prob = root_policy.get(next(iter(root_policy.keys())), 1.0) if root_policy else 1.0
-		for i in range(K):
-			r_next[i] = r_next[i] * float(act_prob)
-		s = sum(r_next) or 0.0
-		if s > 0.0:
-			r_next = [x / s for x in r_next]
-		our_cfv_vec = [0.0] * K
-		r_next_dict = _to_dict(r_next)
-		our_cfv_dict = _to_dict(our_cfv_vec)
-		w_next = {int(k): float(v) for k, v in opp_cfv.items()}
-		warm_hint = {}
-		key0 = (tuple(getattr(public_state, "board_cards", [])), int(getattr(public_state, "current_round", 0)), (int(getattr(public_state, "current_bets", [0, 0])[0]), int(getattr(public_state, "current_bets", [0, 0])[1])), int(getattr(public_state, "current_player", 0)), int(getattr(public_state, "current_player", 0)))
-		if key0:
-			Amax = 1
-			warm_hint[key0] = [policy_vec[i] if i < Amax else 0.0 for i in range(Amax)]
-		return root_policy, r_next_dict, w_next, our_cfv_dict, warm_hint
-	def resolve_at_with_diagnostics(public_state, r_us: Dict[int, float], w_opp: Dict[int, float], config: Optional[Dict[str, Any]] = None, value_server: Optional[ValueServer] = None) -> Tuple[Dict[Any, float], Dict[int, float], Dict[int, float], Dict[str, Any]]:
-		if config is None:
-			config = {}
-		policy, w_next, our_cfv = resolve_at(public_state, r_us, w_opp, config=config, value_server=value_server)
-		stage_map = {0: "preflop", 1: "flop", 2: "turn", 3: "river"}
-		cr = int(getattr(public_state, "current_round", 0))
-		stage = stage_map.get(cr, "none")
-		diag = {
-			"stage": stage,
-			"depth_limit": int(config.get("depth_limit", 1)),
-			"iterations": int(config.get("iterations", 1000)),
-			"bet_fractions": list(config.get("bet_fractions", [])),
-			"k1": float(config.get("k1", 0.0)),
-			"k2": float(config.get("k2", 0.0)),
-			"pot": float(getattr(public_state, "pot_size", 0.0)),
-			"player": int(getattr(public_state, "current_player", 0)),
-		}
-		return policy, w_next, our_cfv, diag
-
