--- a/hand_clusterer.py
+++ b/hand_clusterer.py
@@ -258,265 +258,165 @@
 		return distance
 
     def cluster_hands(self, hands, board, opponent_range, pot_size):
-        if self.profile == "test":
-            if self._fast_test_frozen_clusters is not None:
-                if os.getenv("DEBUG_FAST_TESTS") == "1":
-                    print("[FASTTEST] Returning frozen clusters (reuse)")
-                return self._fast_test_frozen_clusters
-
-            if os.getenv("DEBUG_FAST_TESTS") == "1":
-                print("[FASTTEST] Building frozen clusters (O(n); no features/MC/K-means)")
-
-            if isinstance(hands, (set, dict)):
-                hands_list = sorted(list(hands))
+            if self.profile == "test":
+                    if self._fast_test_frozen_clusters is not None:
+                            if os.getenv("DEBUG_FAST_TESTS") == "1":
+                                    print("[FASTTEST] Returning frozen clusters (reuse)")
+                            return self._fast_test_frozen_clusters
+
+                    if os.getenv("DEBUG_FAST_TESTS") == "1":
+                            print("[FASTTEST] Building frozen clusters (O(n); no features/MC/K-means)")
+
+                    if isinstance(hands, (set, dict)):
+                            hands_list = sorted(list(hands))
+                    else:
+                            hands_list = list(hands)
+                            hands_list.sort()
+
+                    K = int(self.num_clusters)
+                    N = len(hands_list)
+
+                    clusters = {i: set() for i in range(K)}
+
+                    if N == 0:
+                            self._fast_test_frozen_clusters = clusters
+                            self.clusters = clusters
+                            self.centroids = None
+                            self._fast_test_initialized = True
+                            return clusters
+
+                    if N < K:
+                            rng = random.Random(self._fast_test_seed)
+                            perm = list(range(K))
+                            rng.shuffle(perm)
+                            for idx, hand in enumerate(hands_list):
+                                    clusters[perm[idx]] = {hand}
+                    else:
+                            for hand in hands_list:
+                                    if isinstance(hand, str):
+                                            key = hand
+                                    else:
+                                            key = " ".join(list(hand))
+                                    h = hashlib.sha256(key.encode("utf-8")).hexdigest()
+                                    cls = int(h, 16) % K
+                                    clusters[cls].add(hand)
+
+                    K = int(self.num_clusters)
+                    for k in range(K):
+                            if k not in clusters:
+                                    clusters[k] = set()
+                    empties = [k for k, v in clusters.items() if len(v) == 0]
+                    if empties:
+                            donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+                            for e in empties:
+                                    if not donors:
+                                            break
+                                    dk, _ = donors[0]
+                                    move = sorted(clusters[dk])[0]
+                                    clusters[dk].remove(move)
+                                    clusters[e].add(move)
+                                    donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+
+                    self._fast_test_frozen_clusters = clusters
+                    self.clusters = clusters
+                    self.centroids = None
+                    self._last_features = None
+                    self._fast_test_initialized = True
+                    return clusters
+
+            start_time = time.time()
+            hits_before = self._cache_hits
+            misses_before = self._cache_misses
+
+            hand_features = {}
+            for hand in hands:
+                    features = self.calculate_hand_features(hand, board, opponent_range, pot_size)
+                    hand_features[hand] = features
+
+            D_t = self._compute_drift(hand_features)
+            should_recluster = False
+            if self.clusters is None or self.centroids is None:
+                    should_recluster = True
             else:
-                hands_list = list(hands)
-                hands_list.sort()
-
-            K = int(self.num_clusters)
-            N = len(hands_list)
-
-            clusters = {i: set() for i in range(K)}
-
-            if N == 0:
-                self._fast_test_frozen_clusters = clusters
-                self.clusters = clusters
-                self.centroids = None
-                self._fast_test_initialized = True
-                return clusters
-
-            if N < K:
-                rng = random.Random(self._fast_test_seed)
-                perm = list(range(K))
-                rng.shuffle(perm)
-                for idx, hand in enumerate(hands_list):
-                    clusters[perm[idx]] = {hand}
-            else:
-                for hand in hands_list:
-                    if isinstance(hand, str):
-                        key = hand
+                    if D_t is None:
+                            should_recluster = True
                     else:
-                        key = " ".join(list(hand))
-                    h = hashlib.sha256(key.encode("utf-8")).hexdigest()
-                    cls = int(h, 16) % K
-                    clusters[cls].add(hand)
+                            if D_t >= self.tau_re:
+                                    should_recluster = True
+                            else:
+                                    should_recluster = False
+
+            if not should_recluster:
+                    total_time = time.time() - start_time
+                    print(f"[INFO] Reusing previous clustering (D_t={D_t:.4f} < τ_re={self.tau_re:.4f}); time {total_time:.4f}s")
+                    print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
+                    return self.clusters
+
+            import numpy as _np
+            rs = _np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
+
+            feature_vectors = _np.array(list(hand_features.values()))
+            norms = _np.linalg.norm(feature_vectors, axis=1, keepdims=True)
+            normalized_features = feature_vectors / norms
+
+            if len(hands) < self.num_clusters:
+                    self.num_clusters = len(hands)
+
+            idx_all = _np.arange(len(hands))
+            rs.shuffle(idx_all)
+            initial_indices = idx_all[:self.num_clusters]
+            centroids = normalized_features[initial_indices].copy()
+
+            previous_cluster_ids = None
+            iteration = 0
+            while iteration < self.max_iterations:
+                    distances = _np.linalg.norm(normalized_features[:, _np.newaxis] - centroids, axis=2)
+                    cluster_ids = _np.argmin(distances, axis=1)
+                    if previous_cluster_ids is not None:
+                            if _np.array_equal(cluster_ids, previous_cluster_ids):
+                                    break
+                    previous_cluster_ids = cluster_ids.copy()
+                    i = 0
+                    while i < self.num_clusters:
+                            members = normalized_features[cluster_ids == i]
+                            if len(members) > 0:
+                                    centroids[i] = _np.mean(members, axis=0)
+                            else:
+                                    centroids[i] = normalized_features[rs.randint(0, len(hands))]
+                            i = i + 1
+                    iteration = iteration + 1
+
+            from collections import defaultdict as _dd
+            clusters = _dd(set)
+            idx = 0
+            hands_list = list(hands)
+            while idx < len(hands_list):
+                    clusters[int(cluster_ids[idx])].add(hands_list[idx])
+                    idx = idx + 1
 
             K = int(self.num_clusters)
             for k in range(K):
-                if k not in clusters:
-                    clusters[k] = set()
+                    if k not in clusters:
+                            clusters[k] = set()
+
             empties = [k for k, v in clusters.items() if len(v) == 0]
             if empties:
-                donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-                for e in empties:
-                    if not donors:
-                        break
-                    dk, _ = donors[0]
-                    move = sorted(clusters[dk])[0]
-                    clusters[dk].remove(move)
-                    clusters[e].add(move)
                     donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-
-            self._fast_test_frozen_clusters = clusters
+                    for e in empties:
+                            if not donors:
+                                    break
+                            dk, _ = donors[0]
+                            move = sorted(clusters[dk])[0]
+                            clusters[dk].remove(move)
+                            clusters[e].add(move)
+                            donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+
             self.clusters = clusters
-            self.centroids = None
-            self._last_features = None
-            self._fast_test_initialized = True
+            self.centroids = centroids
+            self._last_features = hand_features
+
+            total_time2 = time.time() - start_time
+            print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
+            print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
             return clusters
 
-        start_time = time.time()
-        hits_before = self._cache_hits
-        misses_before = self._cache_misses
-
-        hand_features = {}
-        for hand in hands:
-            features = self.calculate_hand_features(hand, board, opponent_range, pot_size)
-            hand_features[hand] = features
-
-        D_t = self._compute_drift(hand_features)
-        should_recluster = False
-        if self.clusters is None or self.centroids is None:
-            should_recluster = True
-        else:
-            if D_t is None:
-                should_recluster = True
-            else:
-                if D_t >= self.tau_re:
-                    should_recluster = True
-                else:
-                    should_recluster = False
-
-        if not should_recluster:
-            total_time = time.time() - start_time
-            print(f"[INFO] Reusing previous clustering (D_t={D_t:.4f} < τ_re={self.tau_re:.4f}); time {total_time:.4f}s")
-            print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-            return self.clusters
-
-        import numpy as _np
-        rs = _np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
-
-        feature_vectors = _np.array(list(hand_features.values()))
-        norms = _np.linalg.norm(feature_vectors, axis=1, keepdims=True)
-        normalized_features = feature_vectors / norms
-
-        if len(hands) < self.num_clusters:
-            self.num_clusters = len(hands)
-
-        idx_all = _np.arange(len(hands))
-        rs.shuffle(idx_all)
-        initial_indices = idx_all[:self.num_clusters]
-        centroids = normalized_features[initial_indices].copy()
-
-        previous_cluster_ids = None
-        iteration = 0
-        while iteration < self.max_iterations:
-            distances = _np.linalg.norm(normalized_features[:, _np.newaxis] - centroids, axis=2)
-            cluster_ids = _np.argmin(distances, axis=1)
-            if previous_cluster_ids is not None:
-                if _np.array_equal(cluster_ids, previous_cluster_ids):
-                    break
-            previous_cluster_ids = cluster_ids.copy()
-            i = 0
-            while i < self.num_clusters:
-                members = normalized_features[cluster_ids == i]
-                if len(members) > 0:
-                    centroids[i] = _np.mean(members, axis=0)
-                else:
-                    centroids[i] = normalized_features[rs.randint(0, len(hands))]
-                i = i + 1
-            iteration = iteration + 1
-
-        from collections import defaultdict as _dd
-        clusters = _dd(set)
-        idx = 0
-        hands_list = list(hands)
-        while idx < len(hands_list):
-            clusters[int(cluster_ids[idx])].add(hands_list[idx])
-            idx = idx + 1
-
-        K = int(self.num_clusters)
-        for k in range(K):
-            if k not in clusters:
-                clusters[k] = set()
-
-        empties = [k for k, v in clusters.items() if len(v) == 0]
-        if empties:
-            donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-            for e in empties:
-                if not donors:
-                    break
-                dk, _ = donors[0]
-                move = sorted(clusters[dk])[0]
-                clusters[dk].remove(move)
-                clusters[e].add(move)
-                donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-
-        self.clusters = clusters
-        self.centroids = centroids
-        self._last_features = hand_features
-
-        total_time2 = time.time() - start_time
-        print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
-        print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-        return clusters
-
-	def get_cluster_ranges(self):
-		ranges = {}
-		total_clusters = len(self.clusters)
-		for cluster_id in self.clusters.keys():
-			if total_clusters > 0:
-				ranges[cluster_id] = 1.0 / total_clusters
-			else:
-				ranges[cluster_id] = 0.0
-		return ranges
-
-	def _opponent_range_signature(self, opponent_range):
-		n = len(opponent_range)
-		if n >= 600:
-			sample = list(opponent_range.items())[:256]
-			if sample:
-				w0 = float(sample[0][1])
-				if all(abs(float(w) - w0) < 1e-12 for _, w in sample):
-					return f"UNIFORM:{n}"
-		items = []
-		for k, v in opponent_range.items():
-			if isinstance(k, (int, np.integer)):
-				kk = f"#{int(k)}"
-			else:
-				kk = str(k)
-			items.append((kk, "{:.6f}".format(float(v))))
-		items.sort(key=lambda x: x[0])
-		prefix = "|".join(f"{k}:{val}" for k, val in items[:256])
-		return f"CHK:{hashlib.md5(prefix.encode()).hexdigest()}:{n}"
-
-	def _compute_drift(self, new_features):
-		if self._last_features is None:
-			return None
-		common_keys = list(set(new_features.keys()).intersection(set(self._last_features.keys())))
-		n = len(common_keys)
-		if n == 0:
-			return None
-		if n > self.drift_sample_size:
-			rng = np.random.RandomState(12345)
-			indices = rng.choice(n, size=self.drift_sample_size, replace=False)
-			sample_keys = [common_keys[i] for i in indices]
-		else:
-			sample_keys = common_keys
-		total = 0.0
-		count = 0
-		i = 0
-		while i < len(sample_keys):
-			k = sample_keys[i]
-			v_new = np.asarray(new_features[k], dtype=float)
-			v_old = np.asarray(self._last_features[k], dtype=float)
-			diff = v_new - v_old
-			d = float(np.linalg.norm(diff))
-			total = total + d
-			count = count + 1
-			i = i + 1
-		if count > 0:
-			return total / float(count)
-		else:
-			return None
-
-
-	def _fast_test_assign_clusters(self, hands_iterable):
-		if isinstance(hands_iterable, (set, dict)):
-			hands_list = sorted(list(hands_iterable))
-		else:
-			hands_list = list(hands_iterable)
-			hands_list.sort()
-
-		K = int(self.num_clusters)
-		N = len(hands_list)
-		clusters = {i: set() for i in range(K)}
-
-		if N == 0:
-			return clusters
-
-		if N < K:
-			rng = random.Random(self._fast_test_seed)
-			perm = list(range(K))
-			rng.shuffle(perm)
-			for idx, hand in enumerate(hands_list):
-				clusters[perm[idx]] = {hand}
-			return clusters
-
-		for hand in hands_list:
-			key = hand if isinstance(hand, str) else " ".join(list(hand))
-			h = hashlib.sha256(key.encode("utf-8")).hexdigest()
-			cls = int(h, 16) % K
-			clusters[cls].add(hand)
-		return clusters
-
-	def _deterministic_seed_for_clustering(self, board, opponent_range, pot_size):
-		rsig = self._opponent_range_signature(opponent_range)
-		key = f"{','.join(board)}|{rsig}|{float(pot_size):.6f}|{int(self.num_clusters)}"
-		val = 2166136261
-		i = 0
-		while i < len(key):
-			val ^= ord(key[i])
-			val = (val * 16777619) & 0xFFFFFFFF
-			i += 1
-		base = int(self._fast_test_seed) if hasattr(self, "_fast_test_seed") else 1729
-		return int((val ^ (base * 1315423911)) & 0x7FFFFFFF)
