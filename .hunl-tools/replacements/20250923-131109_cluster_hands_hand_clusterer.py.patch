--- a/hand_clusterer.py
+++ b/hand_clusterer.py
@@ -97,183 +97,181 @@
 				self.opp_sample_size = int(opp_sample_size) if opp_sample_size is not None else None
 				self.use_cfv_in_features = bool(use_cfv_in_features)
 
-	def cluster_hands(
-		self,
-		hands: Any,
-		board: List[str],
-		opponent_range: Dict[Any, float],
-		pot_size: float,
-	) -> Dict[int, Set[str]]:
-
-		if self.profile == "test":
-			ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
-			assert ok
-			if self._fast_test_frozen_clusters is not None:
-				return self._fast_test_frozen_clusters
-
-			if isinstance(hands, (set, dict)):
-				hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
-			else:
-				hands_list = list(hands)
-				hands_list.sort()
-
-			K = int(self.num_clusters)
-			N = len(hands_list)
-			clusters: Dict[int, Set[str]] = {i: set() for i in range(K)}
-
-			if N == 0:
-				self._fast_test_frozen_clusters = clusters
-				self.clusters = clusters
-				self.centroids = None
-				self._fast_test_initialized = True
-				return clusters
-
-			if N < K:
-				rng = random.Random(self._fast_test_seed)
-				perm = list(range(K))
-				rng.shuffle(perm)
-				for idx, hand in enumerate(hands_list):
-					clusters[perm[idx]] = {hand}
-			else:
-				for hand in hands_list:
-					key = hand if isinstance(hand, str) else " ".join(list(hand))
-					h = hashlib.sha256(key.encode("utf-8")).hexdigest()
-					cls = int(h, 16) % K
-					clusters[cls].add(hand)
-
-			for k in range(K):
-				if k not in clusters:
-					clusters[k] = set()
-			empties = [k for k, v in clusters.items() if len(v) == 0]
-			if empties:
-				donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-				for e in empties:
-					if not donors:
-						break
-					dk, _ = donors[0]
-					move = sorted(clusters[dk])[0]
-					clusters[dk].remove(move)
-					clusters[e].add(move)
-					donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-
-			self._fast_test_frozen_clusters = clusters
-			self.clusters = clusters
-			self.centroids = None
-			self._last_features = None
-			self._fast_test_initialized = True
-			return clusters
-
-		start_time = time.time()
-		hits_before = self._cache_hits
-		misses_before = self._cache_misses
-
-		hand_features: Dict[str, np.ndarray] = {}
-		if isinstance(hands, dict):
-			iterable = hands.keys()
-		else:
-			iterable = hands
-		for h in iterable:
-			features = self.calculate_hand_features(h, board, opponent_range, pot_size)
-			hand_features[h] = features
-
-		enable_reuse = bool(getattr(self, "_config", None) and getattr(self._config, "enable_drift_reuse", False))
-		if enable_reuse and self.clusters is not None and self.centroids is not None:
-			D_t = self._compute_drift(hand_features)
-			if D_t is not None and D_t < self.tau_re:
-				return self.clusters
-
-		rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
-		feature_vectors = np.array(list(hand_features.values()))
-		norms = np.linalg.norm(feature_vectors, axis=1, keepdims=True)
-		normalized_features = feature_vectors / norms
-
-		N = len(hand_features)
-		if N < self.num_clusters:
-			self.num_clusters = N
-
-		idx_all = np.arange(N)
-		rs.shuffle(idx_all)
-		initial_indices = idx_all[: self.num_clusters]
-		centroids = normalized_features[initial_indices].copy()
-
-		previous_cluster_ids = None
-		iteration = 0
-		while iteration < int(self.max_iterations):
-			distances = np.linalg.norm(normalized_features[:, np.newaxis] - centroids, axis=2)
-			cluster_ids = np.argmin(distances, axis=1)
-			if previous_cluster_ids is not None and np.array_equal(cluster_ids, previous_cluster_ids):
-				break
-			previous_cluster_ids = cluster_ids.copy()
-			for i in range(int(self.num_clusters)):
-				members = normalized_features[cluster_ids == i]
-				if len(members) > 0:
-					centroids[i] = np.mean(members, axis=0)
-				else:
-					centroids[i] = normalized_features[rs.randint(0, N)]
-			iteration += 1
-
-		clusters_raw: Dict[int, Set[str]] = defaultdict(set)
-		hlist = list(hand_features.keys())
-		for idx, h in enumerate(hlist):
-			clusters_raw[int(cluster_ids[idx])].add(h)
-
-		K = int(self.num_clusters)
-		for k in range(K):
-			if k not in clusters_raw:
-				clusters_raw[k] = set()
-		empties = [k for k, v in clusters_raw.items() if len(v) == 0]
-		if empties:
-			donors = sorted([(k, len(v)) for k, v in clusters_raw.items() if len(v) > 1], key=lambda x: -x[1])
-			for e in empties:
-				if not donors:
-					break
-				dk, _ = donors[0]
-				move = sorted(clusters_raw[dk])[0]
-				clusters_raw[dk].remove(move)
-				clusters_raw[e].add(move)
-				donors = sorted([(k, len(v)) for k, v in clusters_raw.items() if len(v) > 1], key=lambda x: -x[1])
-
-		if enable_reuse and isinstance(self.clusters, dict) and self.clusters:
-			prev = {int(k): set(v) for k, v in self.clusters.items()}
-			used_prev = set()
-			mapping = {}
-			for nc in sorted(clusters_raw.keys()):
-				best_p = None
-				best_overlap = -1
-				for pc in sorted(prev.keys()):
-					if pc in used_prev:
-						continue
-					ov = len(clusters_raw[nc] & prev[pc])
-					if ov > best_overlap:
-						best_overlap = ov
-						best_p = pc
-				if best_p is not None:
-					mapping[int(nc)] = int(best_p)
-					used_prev.add(int(best_p))
-			free_prev = [p for p in sorted(prev.keys()) if p not in used_prev]
-			free_new = [n for n in sorted(clusters_raw.keys()) if n not in mapping]
-			for n, p in zip(free_new, free_prev):
-				mapping[int(n)] = int(p)
-			clusters_aligned: Dict[int, Set[str]] = {int(k): set() for k in range(K)}
-			for n, hands_set in clusters_raw.items():
-				tgt = int(mapping.get(int(n), int(n)))
-				if 0 <= tgt < K:
-					clusters_aligned[tgt].update(hands_set)
-			for k in range(K):
-				if k not in clusters_aligned:
-					clusters_aligned[k] = set()
-			clusters = clusters_aligned
-		else:
-			clusters = {int(k): set(v) for k, v in clusters_raw.items()}
-
-		self.clusters = clusters
-		self.centroids = centroids
-		self._last_features = hand_features
-
-		total_time2 = time.time() - start_time
-		print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
-		print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-		return clusters
+    def cluster_hands(
+        self,
+        hands: Any,
+        board: List[str],
+        opponent_range: Dict[Any, float],
+        pot_size: float,
+    ) -> Dict[int, Set[str]]:
+
+        if self.profile == "test":
+            ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
+            assert ok
+            if self._fast_test_frozen_clusters is not None:
+                return self._fast_test_frozen_clusters
+            if isinstance(hands, (set, dict)):
+                hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
+            else:
+                hands_list = list(hands)
+                hands_list.sort()
+            K = int(self.num_clusters)
+            N = len(hands_list)
+            clusters = {i: set() for i in range(K)}
+            if N == 0:
+                self._fast_test_frozen_clusters = clusters
+                self.clusters = clusters
+                self.centroids = None
+                self._fast_test_initialized = True
+                return clusters
+            rng = random.Random(self._fast_test_seed)
+            if N < K:
+                perm = list(range(K))
+                rng.shuffle(perm)
+                for idx, hand in enumerate(hands_list):
+                    clusters[perm[idx]] = {hand}
+            else:
+                for hand in hands_list:
+                    key = hand if isinstance(hand, str) else " ".join(list(hand))
+                    h = hashlib.sha256(key.encode("utf-8")).hexdigest()
+                    cls = int(h, 16) % K
+                    clusters[cls].add(hand)
+            for k in range(K):
+                if k not in clusters:
+                    clusters[k] = set()
+            empties = [k for k, v in clusters.items() if len(v) == 0]
+            if empties:
+                donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+                for e in empties:
+                    if not donors:
+                        break
+                    dk, _ = donors[0]
+                    move = sorted(clusters[dk])[0]
+                    clusters[dk].remove(move)
+                    clusters[e].add(move)
+                    donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+            self._fast_test_frozen_clusters = clusters
+            self.clusters = clusters
+            self.centroids = None
+            self._last_features = None
+            self._fast_test_initialized = True
+            return clusters
+
+        start_time = time.time()
+        hits_before = self._cache_hits
+        misses_before = self._cache_misses
+
+        hand_features: Dict[str, np.ndarray] = {}
+        if isinstance(hands, dict):
+            iterable = hands.keys()
+        else:
+            iterable = hands
+        for h in iterable:
+            features = self.calculate_hand_features(h, board, opponent_range, pot_size)
+            hand_features[h] = np.asarray(features, dtype=float)
+
+        N = len(hand_features)
+        if N == 0:
+            self.clusters = {}
+            self.centroids = None
+            self._last_features = {}
+            return {}
+
+        if N < self.num_clusters:
+            self.num_clusters = N
+
+        rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, {}, 0.0))
+        all_keys = list(hand_features.keys())
+        idx_all = np.arange(N)
+        rs.shuffle(idx_all)
+        K = int(self.num_clusters)
+        medoid_idx = list(idx_all[:K])
+        key_list = all_keys
+        assign = [-1] * N
+
+        def _dist(i, j):
+            return float(self._emd_distance(hand_features[key_list[i]], hand_features[key_list[j]]))
+
+        def _assign_all(medoids):
+            changed = False
+            i = 0
+            while i < N:
+                best = None
+                best_d = None
+                for m in medoids:
+                    d = _dist(i, m)
+                    if best_d is None or d < best_d:
+                        best_d = d
+                        best = m
+                if assign[i] != best:
+                    assign[i] = best
+                    changed = True
+                i += 1
+            return changed
+
+        def _update_medoids(medoids):
+            updated = False
+            for k in range(len(medoids)):
+                cluster_members = [i for i in range(N) if assign[i] == medoids[k]]
+                if not cluster_members:
+                    continue
+                best_i = medoids[k]
+                best_sum = None
+                for cand in cluster_members:
+                    s = 0.0
+                    for j in cluster_members:
+                        if j == cand:
+                            continue
+                        s += _dist(cand, j)
+                    if best_sum is None or s < best_sum:
+                        best_sum = s
+                        best_i = cand
+                if best_i != medoids[k]:
+                    medoids[k] = best_i
+                    updated = True
+            return updated
+
+        _assign_all(medoid_idx)
+        it = 0
+        while it < int(self.max_iterations):
+            it += 1
+            if not _update_medoids(medoid_idx):
+                break
+            if not _assign_all(medoid_idx):
+                break
+
+        clusters_raw: Dict[int, Set[str]] = defaultdict(set)
+        for i in range(N):
+            m = assign[i]
+            if m < 0:
+                continue
+            key = key_list[i]
+            clusters_raw[int(m)].add(key)
+
+        if len(clusters_raw) < K:
+            left = [i for i in range(N) if assign[i] < 0]
+            i2 = 0
+            for mid in medoid_idx:
+                if mid not in clusters_raw:
+                    clusters_raw[int(mid)] = set()
+                while i2 < len(left) and len(clusters_raw[int(mid)]) == 0:
+                    clusters_raw[int(mid)].add(key_list[left[i2]])
+                    i2 += 1
+
+        id_map = {old: new for new, old in enumerate(sorted(clusters_raw.keys()))}
+        clusters = {int(id_map[k]): set(v) for k, v in clusters_raw.items()}
+        for i in range(K):
+            if i not in clusters:
+                clusters[i] = set()
+
+        self.clusters = clusters
+        self.centroids = None
+        self._last_features = hand_features
+
+        total_time2 = time.time() - start_time
+        print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
+        print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
+        return clusters
 
 	def fit(
 		self,
