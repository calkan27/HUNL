--- a/cfv_network.py
+++ b/cfv_network.py
@@ -48,23 +48,22 @@
 		p2 = self.output_player2_values(h)
 		return p1, p2
 
-	def enforce_zero_sum(self, player1_range, player2_range, player1_values, player2_values):
-		eps = 1e-7
-		r1 = player1_range
-		r2 = player2_range
-		s1 = torch.sum(r1, dim=1, keepdim=True)
-		s2 = torch.sum(r2, dim=1, keepdim=True)
-		has1 = (s1 > eps).to(player1_values.dtype)
-		has2 = (s2 > eps).to(player2_values.dtype)
-		r1n = r1 / torch.clamp(s1, min=eps)
-		r2n = r2 / torch.clamp(s2, min=eps)
-		sv1 = has1 * torch.sum(r1n * player1_values, dim=1, keepdim=True)
-		sv2 = has2 * torch.sum(r2n * player2_values, dim=1, keepdim=True)
-		den = has1 + has2
-		delta = torch.where(den > 0.0, (sv1 + sv2) / den, torch.zeros_like(sv1))
-		f1 = player1_values - delta
-		f2 = player2_values - delta
-		return f1, f2
+    def enforce_zero_sum(self, player1_range, player2_range, player1_values, player2_values):
+        eps = 1e-7
+        r1 = player1_range
+        r2 = player2_range
+        s1 = torch.sum(r1, dim=1, keepdim=True)
+        s2 = torch.sum(r2, dim=1, keepdim=True)
+        K = player1_values.shape[1]
+        u = player1_values.new_full((player1_values.shape[0], K), 1.0 / max(1, K))
+        w1 = torch.where(s1 > eps, r1 / torch.clamp(s1, min=eps), u)
+        w2 = torch.where(s2 > eps, r2 / torch.clamp(s2, min=eps), u)
+        sv1 = torch.sum(w1 * player1_values, dim=1, keepdim=True)
+        sv2 = torch.sum(w2 * player2_values, dim=1, keepdim=True)
+        delta = 0.5 * (sv1 + sv2)
+        f1 = player1_values - delta
+        f2 = player2_values - delta
+        return f1, f2
 
 	def predict_with_zero_sum(self, input_tensor, player1_range, player2_range):
 		p1, p2 = self(input_tensor)
