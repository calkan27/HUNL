--- a/cfv_trainer.py
+++ b/cfv_trainer.py
@@ -46,22 +46,26 @@
 
 
 def _eval_loss_cfv(model, train_samples, val_samples, split, batch_size, device, criterion, K: int):
-	model.eval()
-	total = 0.0
-	count = 0
-	with torch.no_grad():
-		source = val_samples if split == "val" else train_samples
-		for xb, y1b, y2b in _cfv_batcher(source, batch_size, shuffle=False, device=device):
-			r1b, r2b = _ranges_from_inputs(xb, K)
-			p1, p2 = model(xb)
-			f1, f2 = model.enforce_zero_sum(r1b, r2b, p1, p2)
-			l1 = criterion(f1, y1b)
-			l2 = criterion(f2, y2b)
-			l = 0.5 * (l1 + l2)
-			total += float(l.item()) * xb.shape[0]
-			count += xb.shape[0]
-	return total / max(1, count)
-
+        model.eval()
+        total_huber = 0.0
+        total_mae = 0.0
+        count = 0
+        with torch.no_grad():
+                source = val_samples if split == "val" else train_samples
+                for xb, y1b, y2b in _cfv_batcher(source, batch_size, shuffle=False, device=device):
+                        r1b, r2b = _ranges_from_inputs(xb, K)
+                        p1, p2 = model(xb)
+                        f1, f2 = model.enforce_zero_sum(r1b, r2b, p1, p2)
+                        l1 = criterion(f1, y1b)
+                        l2 = criterion(f2, y2b)
+                        l = 0.5 * (l1 + l2)
+                        mae = 0.5 * (torch.mean(torch.abs(f1 - y1b)) + torch.mean(torch.abs(f2 - y2b)))
+                        bs = xb.shape[0]
+                        total_huber += float(l.item()) * bs
+                        total_mae += float(mae.item()) * bs
+                        count += bs
+        den = max(1, count)
+        return total_huber / den, total_mae / den
 
 def train_cfv_network(
 	model,
