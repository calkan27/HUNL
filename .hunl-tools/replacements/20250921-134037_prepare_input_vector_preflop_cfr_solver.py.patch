--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -121,26 +121,38 @@
 						m.bias.zero_()
 
 
-	def prepare_input_vector_preflop(self, node):
-		total_initial = sum(node.public_state.initial_stacks) if getattr(node.public_state, "initial_stacks", None) else 1.0
-		if total_initial <= 0:
-			total_initial = 1.0
-		pot_norm = node.public_state.pot_size / float(total_initial)
-		pot_vec = [pot_norm]
-		K = self.num_clusters
-		r1 = [0.0] * K
-		r2 = [0.0] * K
-		range_p1 = node.player_ranges[0]
-		range_p2 = node.player_ranges[1]
-		total1 = sum(range_p1.values())
-		total2 = sum(range_p2.values())
-		for cluster_id, prob in range_p1.items():
-			if 0 <= int(cluster_id) < K and total1 > 0:
-				r1[int(cluster_id)] = prob / total1
-		for cluster_id, prob in range_p2.items():
-			if 0 <= int(cluster_id) < K and total2 > 0:
-				r2[int(cluster_id)] = prob / total2
-		return pot_vec + r1 + r2
+    def prepare_input_vector_preflop(self, node):
+        total_initial = sum(node.public_state.initial_stacks) if getattr(node.public_state, "initial_stacks", None) else 1.0
+        if total_initial <= 0:
+            total_initial = 1.0
+        pot_norm = node.public_state.pot_size / float(total_initial)
+        pot_vec = [pot_norm]
+        K = self.num_clusters
+        r1 = [0.0] * K
+        r2 = [0.0] * K
+        range_p1 = dict(node.player_ranges[0])
+        range_p2 = dict(node.player_ranges[1])
+        total1 = sum(range_p1.values())
+        total2 = sum(range_p2.values())
+        if total1 > 0:
+            for k in list(range_p1.keys()):
+                range_p1[k] = range_p1[k] / total1
+        else:
+            for k in list(range_p1.keys()):
+                range_p1[k] = 0.0
+        if total2 > 0:
+            for k in list(range_p2.keys()):
+                range_p2[k] = range_p2[k] / total2
+        else:
+            for k in list(range_p2.keys()):
+                range_p2[k] = 0.0
+        for cluster_id, prob in range_p1.items():
+            if 0 <= int(cluster_id) < K:
+                r1[int(cluster_id)] = float(prob)
+        for cluster_id, prob in range_p2.items():
+            if 0 <= int(cluster_id) < K:
+                r2[int(cluster_id)] = float(prob)
+        return pot_vec + r1 + r2
 
 	def calculate_input_size_preflop(self):
 		pot_size_input = 1
