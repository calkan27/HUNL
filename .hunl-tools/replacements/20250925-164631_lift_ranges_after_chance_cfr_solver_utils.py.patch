--- a/cfr_solver_utils.py
+++ b/cfr_solver_utils.py
@@ -51,69 +51,28 @@
 			return "river"
 		return "none"
 
-	def lift_ranges_after_chance(self, node: GameNode) -> dict:
-		ps = node.public_state
-		board = list(getattr(ps, "board_cards", []))
-		board_set = set(board)
-		cl = getattr(self, "clusters", {}) or {}
-
-		def _compat_count(hset):
-			if not hset:
-				return 0
-			c = 0
-			for h in hset:
-				if isinstance(h, str):
-					a, b = h.split()
-				else:
-					a, b = list(h)
-				if a == b:
-					continue
-				if (a in board_set) or (b in board_set):
-					continue
-				c += 1
-			return c
-
-		def _reweight(r):
-			num = {}
-			for cid, p in dict(r).items():
-				cid_i = int(cid)
-				hset = cl.get(cid_i, set())
-				cnum = _compat_count(hset)
-				if cnum > 0:
-					num[cid_i] = float(p) * float(cnum)
-
-			if not num:
-				avail = {int(k): _compat_count(v) for k, v in cl.items()}
-				avail = {k: v for k, v in avail.items() if v > 0}
-
-				if not avail:
-					return r
-
-				u = 1.0 / float(len(avail))
-				return {int(k): u for k in avail.keys()}
-
-			s = sum(num.values())
-			for k in list(num.keys()):
-				num[k] = num[k] / s
-			return num
-
-		for pl in (0, 1):
-			if isinstance(node.player_ranges[pl], dict):
-				node.player_ranges[pl] = _reweight(node.player_ranges[pl])
-
-		if not hasattr(self, "own_range_tracking"):
-			self.own_range_tracking = {}
-
-		get_key = getattr(self, "_state_key", None)
-		if callable(get_key):
-			key = get_key(node)
-			cp = int(getattr(node.public_state, "current_player", 0))
-			self.own_range_tracking[key] = {
-				int(k): float(v)
-				for k, v in dict(node.player_ranges[cp]).items()
-			}
-
-		return {0: dict(node.player_ranges[0]), 1: dict(node.player_ranges[1])}
+    def lift_ranges_after_chance(self, node: GameNode) -> dict:
+        ps = node.public_state
+        board = list(getattr(ps, "board_cards", []))
+        board_set = set(board)
+        cl = getattr(self, "clusters", {}) or {}
+        for pl in (0, 1):
+            if isinstance(node.player_ranges[pl], dict):
+                node.player_ranges[pl] = self._reweight_range_by_available(
+                    node.player_ranges[pl],
+                    cl,
+                    board_set
+                )
+        if not hasattr(self, "own_range_tracking"):
+            self.own_range_tracking = {}
+        get_key = getattr(self, "_state_key", None)
+        if callable(get_key):
+            key = get_key(node)
+            cp = int(getattr(node.public_state, "current_player", 0))
+            self.own_range_tracking[key] = {}
+            for k, v in dict(node.player_ranges[cp]).items():
+                self.own_range_tracking[key][int(k)] = float(v)
+        return {0: dict(node.player_ranges[0]), 1: dict(node.player_ranges[1])}
 
 	def apply_opponent_action_update(self, prev_node: GameNode, new_node: GameNode, observed_action_type: ActionType):
 		if not hasattr(self, "opponent_cfv_upper_tracking"):
