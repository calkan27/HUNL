--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -504,23 +504,28 @@
 			except Exception:
 				pass
 		return True
-	def flop_label_targets_using_turn_net(self, node):
-		self.depth_limit = max(1, int(getattr(self, "depth_limit", 1)))
-		if "turn" not in self.models or self.models["turn"] is None:
-			return [0.0] * int(self.num_clusters), [0.0] * int(self.num_clusters)
-		self.total_iterations = int(getattr(self, "total_iterations", 1000))
-		self.run_cfr(node)
-		v0 = self._expected_cfv_vector(node, player=0)
-		v1 = self._expected_cfv_vector(node, player=1)
-		K = int(self.num_clusters)
-		out0 = [0.0] * K
-		out1 = [0.0] * K
-		for cid in range(K):
-			a = v0.get(int(cid), [0.0])
-			b = v1.get(int(cid), [0.0])
-			out0[cid] = float(a[0] if isinstance(a, (list, tuple)) and len(a) > 0 else a)
-			out1[cid] = float(b[0] if isinstance(b, (list, tuple)) and len(b) > 0 else b)
-		return out0, out1
+    def flop_label_targets_using_turn_net(self, node):
+        old_flag = bool(getattr(self, "_label_pot_fraction", False))
+        self._label_pot_fraction = True
+        old_depth = int(getattr(self, "depth_limit", 1))
+        try:
+            self.depth_limit = max(1, old_depth)
+            self.run_cfr(node)
+            v0 = self._expected_cfv_vector(node, player=0)
+            v1 = self._expected_cfv_vector(node, player=1)
+            K = int(self.num_clusters)
+            out0 = [0.0] * K
+            out1 = [0.0] * K
+            for cid in range(K):
+                a = v0.get(int(cid), [0.0])
+                b = v1.get(int(cid), [0.0])
+                out0[cid] = float(a[0] if isinstance(a, (list, tuple)) and len(a) > 0 else a)
+                out1[cid] = float(b[0] if isinstance(b, (list, tuple)) and len(b) > 0 else b)
+            return out0, out1
+        finally:
+            self._label_pot_fraction = old_flag
+            self.depth_limit = old_depth
+
 	def _expected_cfv_vector(self, node, player):
 		A = len(ActionType)
 		ps = node.public_state
