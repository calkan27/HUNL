--- a/river_endgame.py
+++ b/river_endgame.py
@@ -70,39 +70,57 @@
 		else:
 			return 0.5 * p
 
-	def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
-		if my_bet is not None or opp_bet is not None:
-			mb = float(my_bet or 0.0)
-			ob = float(opp_bet or 0.0)
-			def _payoff(i, j):
-				if i > j:
-					return ob
-				elif i < j:
-					return -mb
-				else:
-					return 0.5 * (ob - mb)
-		else:
-			p = float(resolved_pot if resolved_pot is not None else 1.0)
-			def _payoff(i, j):
-				if i > j:
-					return p
-				elif i < j:
-					return -p
-				else:
-					return 0.5 * p
-		ev_p = 0.0
-		ev_o = 0.0
-		i = 0
-		while i < B:
-			j = 0
-			while j < B:
-				w = float(my_bucket_probs[i]) * float(opp_bucket_probs[j])
-				v = _payoff(i, j)
-				ev_p += w * v
-				ev_o -= w * v
-				j += 1
-			i += 1
-		return ev_p, ev_o
+    def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
+        p = list(my_bucket_probs)
+        q = list(opp_bucket_probs)
+
+        def _norm(v):
+            s = sum(v) or 0.0
+            if s > 0.0:
+                return [float(x) / s for x in v]
+            return [0.0] * len(v)
+
+        p = _norm(p)
+        q = _norm(q)
+        B = int(B)
+
+        if my_bet is not None or opp_bet is not None:
+            mb = float(my_bet or 0.0)
+            ob = float(opp_bet or 0.0)
+
+            def pay(i, j):
+                if i > j:
+                    return ob
+                elif i < j:
+                    return -mb
+                else:
+                    return 0.5 * (ob - mb)
+        else:
+            P = float(resolved_pot if resolved_pot is not None else 1.0)
+
+            def pay(i, j):
+                if i > j:
+                    return P
+                elif i < j:
+                    return -P
+                else:
+                    return 0.5 * P
+
+        ev_p = 0.0
+        for i in range(B):
+            pi = p[i]
+            if pi == 0.0:
+                continue
+            row = 0.0
+            for j in range(B):
+                v_ij = pay(i, j)
+                v_ji = pay(j, i)
+                kij = 0.5 * (v_ij - v_ji)
+                row += q[j] * kij
+            ev_p += pi * row
+
+        ev_o = -ev_p
+        return ev_p, ev_o
 
 	def _normalize_range(self, r):
 		out = {int(k): float(v) for k, v in dict(r).items()}
