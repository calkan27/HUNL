--- a/hand_clusterer_features.py
+++ b/hand_clusterer_features.py
@@ -75,31 +75,14 @@
 		return total / den if den > 0 else 0.0
 
 def _emd_distance(self, sig1: np.ndarray, sig2: np.ndarray) -> float:
-	a = np.asarray(sig1, dtype=float).ravel()
-	b = np.asarray(sig2, dtype=float).ravel()
-	n = min(a.size, b.size)
-	if n == 0:
-		return 0.0
-	return float(np.linalg.norm(a[:n] - b[:n]))
+    a = np.asarray(sig1, dtype=np.float64).ravel()
+    b = np.asarray(sig2, dtype=np.float64).ravel()
+    na = float(np.linalg.norm(a))
+    nb = float(np.linalg.norm(b))
+    if na > 0.0:
+        a = a / na
+    if nb > 0.0:
+        b = b / nb
+    d = a - b
+    return float(np.sqrt(np.dot(d, d)))
 
-
-	def _calculate_payoff(self, player_hand: List[str], opponent_hand: List[str], board: List[str], pot_size: float) -> float:
-		result = self.cfr_solver._player_wins(player_hand, opponent_hand, board)
-		if result == 1:
-			return float(pot_size)
-		elif result == -1:
-			return -float(pot_size)
-		else:
-			return 0.0
-
-    def calculate_hand_distance(self, features1: np.ndarray, features2: np.ndarray) -> float:
-        a = np.asarray(features1, dtype=np.float64).ravel()
-        b = np.asarray(features2, dtype=np.float64).ravel()
-        na = float(np.linalg.norm(a))
-        nb = float(np.linalg.norm(b))
-        if na > 0.0:
-            a = a / na
-        if nb > 0.0:
-            b = b / nb
-        d = a - b
-        return float(np.sqrt(np.dot(d, d)))
