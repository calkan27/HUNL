--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -681,58 +681,66 @@
 			self._preflop_cache_stats["evictions"] += 1
 
 
-	def predict_counterfactual_values(self, node, player):
-		if not hasattr(self, "_diag_cfv_calls"):
-			self._diag_cfv_calls = {"preflop": 0, "flop": 0, "turn": 0, "river": 0}
-		stage = self.get_stage(node)
-		if stage in self._diag_cfv_calls:
-			self._diag_cfv_calls[stage] += 1
-		if stage == 'river':
-			def wins_fn(ph, oh, board):
-				return self._player_wins(ph, oh, board)
-			cf = self.river_endgame.compute_cluster_cfvs(self.clusters, node, player, wins_fn, best_hand, hand_rank)
-			out = {}
-			for cid, val in cf.items():
-				out[int(cid)] = val
-			return out
-		if stage not in self.models:
-			counterfactual_values = {}
-			for cluster_id in node.player_ranges[player]:
-				counterfactual_values[cluster_id] = [0.0] * len(ActionType)
-			return counterfactual_values
-		if stage == 'preflop':
-			input_vector = self.prepare_input_vector_preflop(node)
-		else:
-			input_vector = self.prepare_input_vector(node)
-		input_tensor = torch.tensor([input_vector], dtype=torch.float32).to(self.device)
-		stage_model = self.models[stage]
-		with torch.no_grad():
-			v1, v2 = stage_model(input_tensor)
-			K = self.num_clusters
-			if stage == 'preflop':
-				start_r1 = 1
-				end_r1 = start_r1 + K
-				start_r2 = end_r1
-				end_r2 = start_r2 + K
-			else:
-				start_r1 = 1 + len(DECK)
-				end_r1 = start_r1 + K
-				start_r2 = end_r1
-				end_r2 = start_r2 + K
-			r1 = input_tensor[:, start_r1:end_r1]
-			r2 = input_tensor[:, start_r2:end_r2]
-			v1_adj, v2_adj = stage_model.enforce_zero_sum(r1, r2, v1, v2)
-		pred = v1_adj if player == 0 else v2_adj
-		counterfactual_values = {}
-		for cluster_id in node.player_ranges[player]:
-			idx = int(cluster_id)
-			if 0 <= idx < self.num_clusters:
-				scalar = float(pred[0][idx].item())
-			else:
-				s = 0.0
-				scalar = s
-			counterfactual_values[cluster_id] = [scalar] * len(ActionType)
-		return counterfactual_values
+    def predict_counterfactual_values(self, node, player):
+            if not hasattr(self, "_diag_cfv_calls"):
+                self._diag_cfv_calls = {"preflop": 0, "flop": 0, "turn": 0, "river": 0}
+            stage = self.get_stage(node)
+            if stage in self._diag_cfv_calls:
+                self._diag_cfv_calls[stage] += 1
+            if stage == 'river':
+                def wins_fn(ph, oh, board):
+                    return self._player_wins(ph, oh, board)
+                cf = self.river_endgame.compute_cluster_cfvs(self.clusters, node, player, wins_fn, best_hand, hand_rank)
+                out = {}
+                for cid, val in cf.items():
+                    out[int(cid)] = val
+                return out
+            if stage not in self.models:
+                counterfactual_values = {}
+                for cluster_id in node.player_ranges[player]:
+                    counterfactual_values[cluster_id] = [0.0] * len(ActionType)
+                return counterfactual_values
+            if stage == 'preflop':
+                input_vector = self.prepare_input_vector_preflop(node)
+            else:
+                input_vector = self.prepare_input_vector(node)
+            input_tensor = torch.tensor([input_vector], dtype=torch.float32).to(self.device)
+            stage_model = self.models[stage]
+            with torch.no_grad():
+                v1, v2 = stage_model(input_tensor)
+                K = self.num_clusters
+                if stage == 'preflop':
+                    start_r1 = 1
+                    end_r1 = start_r1 + K
+                    start_r2 = end_r1
+                    end_r2 = start_r2 + K
+                else:
+                    start_r1 = 1 + len(DECK)
+                    end_r1 = start_r1 + K
+                    start_r2 = end_r1
+                    end_r2 = start_r2 + K
+                r1 = input_tensor[:, start_r1:end_r1]
+                r2 = input_tensor[:, start_r2:end_r2]
+                v1_adj, v2_adj = stage_model.enforce_zero_sum(r1, r2, v1, v2)
+                try:
+                    s1 = torch.sum(r1 * v1_adj, dim=1, keepdim=True)
+                    s2 = torch.sum(r2 * v2_adj, dim=1, keepdim=True)
+                    res = torch.abs(s1 + s2).view(-1).detach().cpu().tolist()
+                    if hasattr(self, "_zs_residual_samples"):
+                        self._zs_residual_samples.extend([float(x) for x in res])
+                except Exception:
+                    pass
+            pred = v1_adj if player == 0 else v2_adj
+            counterfactual_values = {}
+            for cluster_id in node.player_ranges[player]:
+                idx = int(cluster_id)
+                if 0 <= idx < self.num_clusters:
+                    scalar = float(pred[0][idx].item())
+                else:
+                    s = 0.0
+                    scalar = s
+                counterfactual_values[cluster_id] = [scalar] * len(ActionType)
+            return counterfactual_values
 
 	def prepare_input_vector(self, node):
 		total_initial = sum(node.public_state.initial_stacks) if getattr(node.public_state, "initial_stacks", None) else 1.0
