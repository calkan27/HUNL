--- a/resolver_integration.py
+++ b/resolver_integration.py
@@ -102,89 +102,90 @@
 
 
 def resolve_at_with_diag(public_state, r_us: Dict[int, float], w_opp: Dict[int, float], config: Optional[Dict[str, Any]] = None, value_server: Optional[ValueServer] = None) -> Tuple[Dict[Any, float], Dict[int, float], Dict[int, float], Dict[str, Any]]:
-	if config is None:
-		config = {}
-	stage = _stage_from_round(int(getattr(public_state, "current_round", 0)))
-	K = int(len(r_us))
-	r_our_vec = _to_vec(r_us, K)
-	r_opp_init = config.get("r_opp_init", None)
-	r_opp_vec = _to_vec(r_opp_init, K) if isinstance(r_opp_init, dict) else ([1.0 / float(K)] * K if K > 0 else [])
-	w_vec = _to_vec(w_opp, K)
-	vs = _ensure_value_server(config, value_server)
-	c_before = dict(vs.get_counters()) if hasattr(vs, "get_counters") else {}
-	user_depth = int(config.get("depth_limit", 1))
-	depth_limit, bet_fractions, include_all_in = _depth_and_bets(stage, user_depth, config)
-	root = _build_root(public_state, depth_limit, bet_fractions, include_all_in)
-	turn_net_calls = {"count": 0}
-	def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
-		total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
-		if total_initial <= 0.0:
-			total_initial = 1.0
-		if bool(getattr(ps, "is_terminal", False)):
-			u = ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0]
-			val = float(u[int(pov_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
-			p = float(getattr(ps, "pot_size", 0.0))
-			out = (val / p) if p > 0.0 else 0.0
-			return torch.tensor([out], dtype=torch.float32)
-		cr_loc = int(getattr(ps, "current_round", 0))
-		if cr_loc >= 2:
-			turn_net_calls["count"] += 0
-			return torch.tensor([0.0], dtype=torch.float32)
-		pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
-		bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
-		x = [pot_norm] + list(bvec) + list(r1) + list(r2)
-		xt = torch.tensor([x], dtype=torch.float32)
-		v1, v2 = vs.query("flop", xt, scale_to_pot=False, as_numpy=False)
-		out = v1 if int(pov_player) == 0 else v2
-		return out[0]
-	T = int(config.get("iterations", 1000))
-	root_policy, node_values, opp_cfv = _solve_subgame(root, r_our_vec, r_opp_vec, w_vec, depth_limit, bet_fractions, include_all_in, T, _leaf_value_fn, config)
-	c_after = dict(vs.get_counters()) if hasattr(vs, "get_counters") else {}
-	flop_queries = int(c_after.get("flop", 0) - int(c_before.get("flop", 0)))
-	turn_queries = int(c_after.get("turn", 0) - int(c_before.get("turn", 0)))
-	allowed_actions = set()
-	if any(abs(float(f) - 0.5) < 1e-9 for f in bet_fractions):
-		allowed_actions.add(ActionType.HALF_POT_BET)
-	if any(abs(float(f) - 1.0) < 1e-9 for f in bet_fractions):
-		allowed_actions.add(ActionType.POT_SIZED_BET)
-	if any(abs(float(f) - 2.0) < 1e-9 for f in bet_fractions):
-		allowed_actions.add(ActionType.TWO_POT_BET)
-	allowed_actions.add(ActionType.FOLD)
-	allowed_actions.add(ActionType.CALL)
-	if include_all_in:
-		allowed_actions.add(ActionType.ALL_IN)
-	menu_ok = True
-	for a in list(root_policy.keys()):
-		if a not in allowed_actions:
-			menu_ok = False
-			break
-	rm1 = float(sum(r_our_vec))
-	rm2 = float(sum(r_opp_vec))
-	range_mass_ok = (abs(rm1 - 1.0) <= 1e-9 and abs(rm2 - 1.0) <= 1e-9)
-	turn_leaf_net_ok = (stage != "turn") or (turn_queries == 0)
-	policy_simple = {a: float(p) for a, p in root_policy.items()}
-	our_cfv_vec = {}
-	if isinstance(node_values, dict):
-		for i, v in node_values.items():
-			try:
-				our_cfv_vec[int(i)] = float(v)
-			except Exception:
-				continue
-	diag = {
-		"iterations": int(T),
-		"depth_limit": int(depth_limit),
-		"stage": str(stage),
-		"bet_fractions": [float(x) for x in bet_fractions],
-		"include_all_in": bool(include_all_in),
-		"K": int(K),
-		"range_mass_ok": bool(range_mass_ok),
-		"policy_actions_ok": bool(menu_ok),
-		"flop_net_queries": int(flop_queries),
-		"turn_net_queries": int(turn_queries),
-		"turn_leaf_net_ok": bool(turn_leaf_net_ok),
-		"preflop_cache": {},
-	}
-	return policy_simple, {int(k): float(v) for k, v in opp_cfv.items()}, our_cfv_vec, diag
+        if config is None:
+                config = {}
+        stage = _stage_from_round(int(getattr(public_state, "current_round", 0)))
+        K = int(len(r_us))
+        r_our_vec = _to_vec(r_us, K)
+        r_opp_init = config.get("r_opp_init", None)
+        r_opp_vec = _to_vec(r_opp_init, K) if isinstance(r_opp_init, dict) else ([1.0 / float(K)] * K if K > 0 else [])
+        w_vec = _to_vec(w_opp, K)
+        vs = _ensure_value_server(config, value_server)
+        c_before = dict(vs.get_counters()) if hasattr(vs, "get_counters") else {}
+        user_depth = int(config.get("depth_limit", 1))
+        depth_limit, bet_fractions, include_all_in = _depth_and_bets(stage, user_depth, config)
+        root = _build_root(public_state, depth_limit, bet_fractions, include_all_in)
+        def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
+                total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
+                if total_initial <= 0.0:
+                        total_initial = 1.0
+                if bool(getattr(ps, "is_terminal", False)):
+                        u = ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0]
+                        val = float(u[int(pov_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
+                        p = float(getattr(ps, "pot_size", 0.0))
+                        out = (val / p) if p > 0.0 else 0.0
+                        return torch.tensor([out], dtype=torch.float32)
+                cr_loc = int(getattr(ps, "current_round", 0))
+                if cr_loc >= 2:
+                        return torch.tensor([0.0], dtype=torch.float32)
+                pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
+                bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
+                x = [pot_norm] + list(bvec) + list(r1) + list(r2)
+                xt = torch.tensor([x], dtype=torch.float32)
+                v1, v2 = vs.query("flop", xt, scale_to_pot=False, as_numpy=False)
+                out = v1 if int(pov_player) == 0 else v2
+                return out[0]
+        T = int(config.get("iterations", 1000))
+        root_policy, node_values, opp_cfv_raw = _solve_subgame(root, r_our_vec, r_opp_vec, w_vec, depth_limit, bet_fractions, include_all_in, T, _leaf_value_fn, config)
+        c_after = dict(vs.get_counters()) if hasattr(vs, "get_counters") else {}
+        flop_queries = int(c_after.get("flop", 0) - int(c_before.get("flop", 0)))
+        turn_queries = int(c_after.get("turn", 0) - int(c_before.get("turn", 0)))
+        proposed_upper = {int(k): float(v) for k, v in dict(opp_cfv_raw or {}).items()}
+        updated_upper = _update_opp_upper_monotone({int(k): float(v) for k, v in w_opp.items()}, proposed_upper)
+        menu_ok = True
+        allowed_actions = set()
+        if any(abs(float(f) - 0.5) < 1e-9 for f in bet_fractions):
+                allowed_actions.add(ActionType.HALF_POT_BET)
+        if any(abs(float(f) - 1.0) < 1e-9 for f in bet_fractions):
+                allowed_actions.add(ActionType.POT_SIZED_BET)
+        if any(abs(float(f) - 2.0) < 1e-9 for f in bet_fractions):
+                allowed_actions.add(ActionType.TWO_POT_BET)
+        allowed_actions.add(ActionType.FOLD)
+        allowed_actions.add(ActionType.CALL)
+        if include_all_in:
+                allowed_actions.add(ActionType.ALL_IN)
+        for a in list(root_policy.keys()):
+                if a not in allowed_actions:
+                        menu_ok = False
+                        break
+        rm1 = float(sum(r_our_vec))
+        rm2 = float(sum(r_opp_vec))
+        range_mass_ok = (abs(rm1 - 1.0) <= 1e-9 and abs(rm2 - 1.0) <= 1e-9)
+        turn_leaf_net_ok = (stage != "turn") or (turn_queries == 0)
+        our_cfv_vec = {}
+        if isinstance(node_values, dict):
+                for i, v in node_values.items():
+                        try:
+                                our_cfv_vec[int(i)] = float(v)
+                        except Exception:
+                                continue
+        diag = {
+                "iterations": int(T),
+                "depth_limit": int(depth_limit),
+                "stage": str(stage),
+                "bet_fractions": [float(x) for x in bet_fractions],
+                "include_all_in": bool(include_all_in),
+                "K": int(K),
+                "range_mass_ok": bool(range_mass_ok),
+                "policy_actions_ok": bool(menu_ok),
+                "flop_net_queries": int(flop_queries),
+                "turn_net_queries": int(turn_queries),
+                "turn_leaf_net_ok": bool(turn_leaf_net_ok),
+                "preflop_cache": {},
+                "updated_opp_upper_count": int(len(updated_upper)),
+        }
+        return {a: float(p) for a, p in root_policy.items()}, dict(updated_upper), our_cfv_vec, diag
+
 
 def resolve_at(public_state, r_us: Dict[int, float], w_opp: Dict[int, float], config: Optional[Dict[str, Any]] = None, value_server: Optional[ValueServer] = None) -> Tuple[Dict[Any, float], Dict[int, float], Dict[int, float]]:
 	pol, w_next, our_cfv, diag = resolve_at_with_diag(public_state, r_us, w_opp, config=config, value_server=value_server)
