--- a/cfv_network.py
+++ b/cfv_network.py
@@ -48,25 +48,23 @@
 		p2 = self.output_player2_values(h)
 		return p1, p2
 
-	def enforce_zero_sum(self, player1_range, player2_range, player1_values, player2_values):
-		eps = 1e-7
-		r1 = player1_range
-		r2 = player2_range
-		s1 = torch.sum(r1, dim=1, keepdim=True)
-		s2 = torch.sum(r2, dim=1, keepdim=True)
-		has1 = (s1 > 0).to(player1_values.dtype)
-		has2 = (s2 > 0).to(player2_values.dtype)
-		K = player1_values.shape[1]
-		u = player1_values.new_full((player1_values.shape[0], K), 1.0 / max(1, K))
-		w1 = torch.where((has1 > 0).expand_as(r1), r1 / torch.clamp(s1, min=eps), u)
-		w2 = torch.where((has2 > 0).expand_as(r2), r2 / torch.clamp(s2, min=eps), u)
-		sv1 = torch.sum(w1 * player1_values, dim=1, keepdim=True)
-		sv2 = torch.sum(w2 * player2_values, dim=1, keepdim=True)
-		den = torch.clamp(has1 + has2, min=1.0)
-		delta = (sv1 + sv2) / den
-		f1 = player1_values - delta
-		f2 = player2_values - delta
-		return f1, f2
+    def enforce_zero_sum(self, player1_range, player2_range, player1_values, player2_values):
+        eps = 1e-7
+        r1 = player1_range
+        r2 = player2_range
+        s1 = torch.sum(r1, dim=1, keepdim=True)
+        s2 = torch.sum(r2, dim=1, keepdim=True)
+        has1 = (s1 > eps).to(player1_values.dtype)
+        has2 = (s2 > eps).to(player2_values.dtype)
+        r1n = r1 / torch.clamp(s1, min=eps)
+        r2n = r2 / torch.clamp(s2, min=eps)
+        sv1 = has1 * torch.sum(r1n * player1_values, dim=1, keepdim=True)
+        sv2 = has2 * torch.sum(r2n * player2_values, dim=1, keepdim=True)
+        den = has1 + has2
+        delta = torch.where(den > 0.0, (sv1 + sv2) / den, torch.zeros_like(sv1))
+        f1 = player1_values - delta
+        f2 = player2_values - delta
+        return f1, f2
 
 	def predict_with_zero_sum(self, input_tensor, player1_range, player2_range):
 		p1, p2 = self(input_tensor)
