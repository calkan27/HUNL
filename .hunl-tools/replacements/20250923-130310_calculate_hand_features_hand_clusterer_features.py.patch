--- a/hand_clusterer_features.py
+++ b/hand_clusterer_features.py
@@ -18,33 +18,25 @@
 
 
 class HandClustererFeaturesMixin:
-	def calculate_hand_features(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> np.ndarray:
-		"""
-		Compute normalized 3-dim feature vector for a hand:
-		  [ equity_vs_range, potential_equity_improvement, cfv_proxy_or_0 ]
-		Caches by (hand, board, opponent_range signature, pot).
-		"""
-		board_key = ",".join(board)
-		range_sig = self._opponent_range_signature(opponent_range)
-		cache_key = f"hand={hand}|board={board_key}|opp={range_sig}|pot={float(pot_size):.6f}"
-		if cache_key in self._cache:
-			self._cache_hits += 1
-			return self._cache[cache_key]
-		self._cache_misses += 1
-
-		equity = self._calculate_equity(hand, board, opponent_range)
-		potential_equity = self._calculate_potential_equity_improvement(hand, board, opponent_range)
-
-		if getattr(self, "use_cfv_in_features", True):
-			cfv_proxy = self._calculate_counterfactual_value(hand, board, opponent_range, pot_size)
-		else:
-			cfv_proxy = 0.0
-
-		features = np.array([equity, potential_equity, cfv_proxy], dtype=float)
-		norm = float(np.linalg.norm(features))
-		features = (features / norm) if norm > 0.0 else features
-		self._cache[cache_key] = features
-		return features
+    def calculate_hand_features(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> np.ndarray:
+        board_key = ",".join(board)
+        range_sig = self._opponent_range_signature(opponent_range)
+        cache_key = f"hand={hand}|board={board_key}|opp={range_sig}"
+        if cache_key in self._cache:
+            self._cache_hits += 1
+            return self._cache[cache_key]
+        self._cache_misses += 1
+        equity = self._calculate_equity(hand, board, opponent_range)
+        potential_equity = self._calculate_potential_equity_improvement(hand, board, opponent_range)
+        if getattr(self, "use_cfv_in_features", True):
+            cfv_proxy = self._calculate_counterfactual_value(hand, board, opponent_range, 1.0)
+        else:
+            cfv_proxy = 0.0
+        features = np.array([equity, potential_equity, cfv_proxy], dtype=float)
+        norm = float(np.linalg.norm(features))
+        features = (features / norm) if norm > 0.0 else features
+        self._cache[cache_key] = features
+        return features
 
 	def _calculate_equity(self, hand: str, board: List[str], opponent_range: Dict[Any, float]) -> float:
 		"""
