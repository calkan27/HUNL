--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -580,31 +580,39 @@
 					vals.append(val)
 				out[int(cid)] = [float(min(vals) if vals else 0.0)]
 		return out
-	def turn_label_targets_solve_to_terminal(self, node):
-		old_depth = int(getattr(self, "depth_limit", 1))
-		try:
-			self.depth_limit = 99
-			self.run_cfr(node)
-			v0 = self._expected_cfv_vector(node, player=0)
-			v1 = self._expected_cfv_vector(node, player=1)
-			K = int(self.num_clusters)
-			out0 = [0.0] * K
-			out1 = [0.0] * K
-			for cid in range(K):
-				a = v0.get(int(cid), [0.0])
-				b = v1.get(int(cid), [0.0])
-				va = float(a[0] if isinstance(a, (list, tuple)) and len(a) > 0 else a)
-				vb = float(b[0] if isinstance(b, (list, tuple)) and len(b) > 0 else b)
-				out0[cid] = va
-				out1[cid] = vb
-			p = float(getattr(node.public_state, "pot_size", 0.0))
-			if p <= 0.0:
-				return out0, out1
-			i = 0
-			while i < K:
-				out0[i] = out0[i] / p
-				out1[i] = out1[i] / p
-				i += 1
-			return out0, out1
-		finally:
-			self.depth_limit = old_depth
+    def turn_label_targets_solve_to_terminal(self, node):
+        old_depth = int(getattr(self, "depth_limit", 1))
+        self._ensure_sparse_schedule()
+        round_flags_backup = {int(k): {"half_pot": bool(v.get("half_pot", True)), "two_pot": bool(v.get("two_pot", False))} for k, v in getattr(self, "_round_actions", {}).items()}
+        for r in (0, 1, 2, 3):
+            self._round_actions[int(r)] = {"half_pot": False, "two_pot": False}
+        snap_cards = self._push_no_card_abstraction_for_node(node)
+        try:
+            self.depth_limit = 99
+            self.run_cfr(node)
+            v0 = self._expected_cfv_vector(node, player=0)
+            v1 = self._expected_cfv_vector(node, player=1)
+            K = int(self.num_clusters)
+            out0 = [0.0] * K
+            out1 = [0.0] * K
+            for cid in range(K):
+                a = v0.get(int(cid), [0.0])
+                b = v1.get(int(cid), [0.0])
+                va = float(a[0] if isinstance(a, (list, tuple)) and len(a) > 0 else a)
+                vb = float(b[0] if isinstance(b, (list, tuple)) and len(b) > 0 else b)
+                out0[cid] = va
+                out1[cid] = vb
+            p = float(getattr(node.public_state, "pot_size", 0.0))
+            if p <= 0.0:
+                return out0, out1
+            i = 0
+            while i < K:
+                out0[i] = out0[i] / p
+                out1[i] = out1[i] / p
+                i += 1
+            return out0, out1
+        finally:
+            self._pop_no_card_abstraction(snap_cards, node)
+            self._round_actions = round_flags_backup
+            self.depth_limit = old_depth
+
