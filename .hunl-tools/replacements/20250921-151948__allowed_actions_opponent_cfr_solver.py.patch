--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -786,34 +786,53 @@
             out.append(ActionType.ALL_IN)
         return out
 
-	def _allowed_actions_opponent(self, ps):
-		out = []
-		p = ps.current_player
-		o = (p + 1) % 2
-		my_bet = ps.current_bets[p]
-		opp_bet = ps.current_bets[o]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-		min_raise_inc = ps._min_raise_size()
-		if to_call > 0:
-			out.append(ActionType.FOLD)
-		out.append(ActionType.CALL)
-		if to_call == 0:
-			if ps.stacks[p] > 0:
-				pot = max(min_raise_inc, int(ps.pot_size))
-				if ps.stacks[p] >= pot and pot > 0:
-					out.append(ActionType.POT_SIZED_BET)
-				out.append(ActionType.ALL_IN)
-		else:
-			remaining_after_call = ps.stacks[p] - to_call
-			if remaining_after_call > 0:
-				pot_after_call = ps.pot_size + to_call
-				pot = max(min_raise_inc, int(pot_after_call))
-				if remaining_after_call >= pot and pot > 0:
-					out.append(ActionType.POT_SIZED_BET)
-			out.append(ActionType.ALL_IN)
-		return out
+    def _allowed_actions_opponent(self, ps):
+        self._ensure_sparse_schedule()
+        out = []
+        p = ps.current_player
+        o = (p + 1) % 2
+        my_bet = ps.current_bets[p]
+        opp_bet = ps.current_bets[o]
+        to_call = opp_bet - my_bet
+        if to_call < 0:
+            to_call = 0
+        flags = self._round_actions.get(int(ps.current_round), {"half_pot": True, "two_pot": False})
+        min_raise_inc = ps._min_raise_size()
+        if to_call > 0:
+            out.append(ActionType.FOLD)
+        out.append(ActionType.CALL)
+        if to_call == 0:
+            if ps.stacks[p] > 0:
+                if flags.get("half_pot", False):
+                    hp = max(min_raise_inc, int(ps.pot_size * 0.5))
+                    if ps.stacks[p] >= hp and hp > 0:
+                        out.append(ActionType.HALF_POT_BET)
+                pt = max(min_raise_inc, int(ps.pot_size))
+                if ps.stacks[p] >= pt and pt > 0:
+                    out.append(ActionType.POT_SIZED_BET)
+                if flags.get("two_pot", False):
+                    tp = max(min_raise_inc, int(ps.pot_size * 2.0))
+                    if ps.stacks[p] >= tp and tp > 0:
+                        out.append(ActionType.TWO_POT_BET)
+                out.append(ActionType.ALL_IN)
+        else:
+            remaining_after_call = ps.stacks[p] - to_call
+            if remaining_after_call > 0:
+                pot_after_call = ps.pot_size + to_call
+                if flags.get("half_pot", False):
+                    hp = max(min_raise_inc, int(pot_after_call * 0.5))
+                    if remaining_after_call >= hp and hp > 0:
+                        out.append(ActionType.HALF_POT_BET)
+                pt = max(min_raise_inc, int(pot_after_call))
+                if remaining_after_call >= pt and pt > 0:
+                    out.append(ActionType.POT_SIZED_BET)
+                if flags.get("two_pot", False):
+                    tp = max(min_raise_inc, int(pot_after_call * 2.0))
+                    if remaining_after_call >= tp and tp > 0:
+                        out.append(ActionType.TWO_POT_BET)
+            out.append(ActionType.ALL_IN)
+        return out
+
 	def _mask_strategy(self, strategy, allowed_actions):
 		m = [0.0] * len(strategy)
 		allowed_idx = [a.value for a in allowed_actions]
