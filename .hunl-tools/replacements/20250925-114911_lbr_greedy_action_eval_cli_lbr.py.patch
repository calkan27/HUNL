--- a/eval_cli_lbr.py
+++ b/eval_cli_lbr.py
@@ -86,51 +86,52 @@
 
 def lbr_greedy_action(ps: PublicState, solver: CFRSolver, lbr_player: int, iters_after: int, freq_log: Dict[str, Dict[str, int]]) -> ActionType:
 
-	if int(ps.current_round) != 1 or int(ps.current_player) != int(lbr_player):
-		return _engine_policy_action(solver, GameNode(ps), iters=iters_after)
-
-	menu = _sparse_menu(ps)
-	if not menu:
-		return ActionType.CALL
-
-	best: Optional[ActionType] = None
-	best_ev: Optional[float] = None
-
-	for a in menu:
-		ps2 = ps.update_state(GameNode(ps), Action(a))
-		node = GameNode(ps2)
-		K = solver.num_clusters
-		u = 1.0 / float(K) if K > 0 else 0.0
-		node.player_ranges[0] = {i: u for i in range(K)}
-		node.player_ranges[1] = {i: u for i in range(K)}
-
-		cur = node
-		guard = 0
-		while not cur.public_state.is_terminal and guard < 200:
-			guard += 1
-			act = _engine_policy_action(solver, cur, iters=iters_after)
-			new_ps = cur.public_state.update_state(cur, Action(act))
-			if not _no_negative_pot_delta(cur.public_state, new_ps):
-				break
-			cur = GameNode(new_ps)
-			cur.player_ranges[0] = dict(node.player_ranges[0])
-			cur.player_ranges[1] = dict(node.player_ranges[1])
-
-		ev = solver._calculate_terminal_utility(cur, player=int(lbr_player)) if cur.public_state.is_terminal else 0.0
-		if best_ev is None or ev > best_ev:
-			best_ev = ev
-			best = a
-
-	key = "flop" if int(ps.current_round) == 1 else "other"
-	if key not in freq_log:
-		freq_log[key] = {"FOLD": 0, "CALL": 0, "POT": 0, "ALL_IN": 0}
-	name = ("FOLD" if best == ActionType.FOLD else
-			"CALL" if best == ActionType.CALL else
-			"POT" if best == ActionType.POT_SIZED_BET else
-			"ALL_IN")
-	freq_log[key][name] = freq_log[key].get(name, 0) + 1
-	return best if best is not None else ActionType.CALL
-
+        if int(ps.current_round) != 1 or int(ps.current_player) != int(lbr_player):
+                return _engine_policy_action(solver, GameNode(ps), iters=iters_after)
+
+        menu = _sparse_menu(ps)
+        if not menu:
+                return ActionType.CALL
+
+        best: Optional[ActionType] = None
+        best_ev: Optional[float] = None
+
+        for a in menu:
+                ps2 = ps.update_state(GameNode(ps), Action(a))
+                if getattr(ps2, "is_terminal", False) and hasattr(ps2, "terminal_utility"):
+                        u = ps2.terminal_utility()
+                        ev = float(u[int(lbr_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
+                else:
+                        node = GameNode(ps2)
+                        K = solver.num_clusters
+                        u0 = 1.0 / float(K) if K > 0 else 0.0
+                        node.player_ranges[0] = {i: u0 for i in range(K)}
+                        node.player_ranges[1] = {i: u0 for i in range(K)}
+                        cur = node
+                        guard = 0
+                        while not cur.public_state.is_terminal and guard < 200:
+                                guard += 1
+                                act = _engine_policy_action(solver, cur, iters=iters_after)
+                                new_ps = cur.public_state.update_state(cur, Action(act))
+                                if not _no_negative_pot_delta(cur.public_state, new_ps):
+                                        break
+                                cur = GameNode(new_ps)
+                                cur.player_ranges[0] = dict(node.player_ranges[0])
+                                cur.player_ranges[1] = dict(node.player_ranges[1])
+                        ev = solver._calculate_terminal_utility(cur, player=int(lbr_player)) if cur.public_state.is_terminal else 0.0
+                if best_ev is None or ev > best_ev:
+                        best_ev = ev
+                        best = a
+
+        key = "flop" if int(ps.current_round) == 1 else "other"
+        if key not in freq_log:
+                freq_log[key] = {"FOLD": 0, "CALL": 0, "POT": 0, "ALL_IN": 0}
+        name = ("FOLD" if best == ActionType.FOLD else
+                        "CALL" if best == ActionType.CALL else
+                        "POT" if best == ActionType.POT_SIZED_BET else
+                        "ALL_IN")
+        freq_log[key][name] = freq_log[key].get(name, 0) + 1
+        return best if best is not None else ActionType.CALL
 
 def run_lbr_eval(
 		episodes: int = 10000,
