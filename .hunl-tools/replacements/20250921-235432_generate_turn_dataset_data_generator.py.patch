--- a/data_generator.py
+++ b/data_generator.py
@@ -461,41 +461,37 @@
 		game_node.player_ranges[public_state.current_player] = r_self
 		game_node.player_ranges[(public_state.current_player + 1) % 2] = r_opp
 		return game_node
-	def generate_turn_dataset(self, num_situations, out_dir, chunk_size=50000, seed=2027):
-		rng = random.Random(int(seed))
-		meta = {
-			"schema": "cfv.dataset.turn.v1",
-			"created_at": int(time.time()),
-			"stage": "turn",
-			"num_clusters": int(self.num_clusters),
-			"pot_sampler": self.pot_sampler_spec(),
-			"range_generator": self.range_generator_spec(),
-		}
-		count = 0
-		chunk = []
-		chunk_idx = 0
-		while count < int(num_situations):
-			node = self._sample_turn_situation(rng)
-			self.cfr_solver.total_iterations = 1000
-			self.cfr_solver.depth_limit = max(1, int(getattr(self, "depth_limit", 1)))
-			self.cfr_solver.run_cfr(node)
-			cf = self.compute_counterfactual_values(node)
-			bucketed = self.bucket_player_ranges([node.player_ranges[0], node.player_ranges[1]])
-			iv = self.prepare_input_vector(bucketed, node.public_state.board_cards, node.public_state.pot_size, node.public_state.actions)
-			rec = {
-				"input_vector": iv,
-				"target_v1": [float(x) for x in next(iter(cf[0].values()))],
-				"target_v2": [float(x) for x in next(iter(cf[1].values()))],
-			}
-			chunk.append(rec)
-			count += 1
-			if len(chunk) >= int(chunk_size):
-				self._persist_npz_chunk(chunk, out_dir, "turn", chunk_idx, meta)
-				chunk = []
-				chunk_idx += 1
-		if chunk:
-			self._persist_npz_chunk(chunk, out_dir, "turn", chunk_idx, meta)
-		return {"written_chunks": int(chunk_idx + (1 if chunk else 0))}
+    def generate_turn_dataset(self, num_situations, out_dir, chunk_size=50000, seed=2027):
+        rng = random.Random(int(seed))
+        meta = {
+            "schema": "cfv.dataset.turn.v2",
+            "created_at": int(time.time()),
+            "stage": "turn",
+            "num_clusters": int(self.num_clusters),
+            "pot_sampler": self.pot_sampler_spec(),
+            "range_generator": self.range_generator_spec(),
+        }
+        count = 0
+        chunk = []
+        chunk_idx = 0
+        while count < int(num_situations):
+            node = self._sample_turn_situation(rng)
+            self.cfr_solver.total_iterations = 1000
+            self.cfr_solver.depth_limit = max(1, int(getattr(self, "depth_limit", 1)))
+            t1, t2 = self.cfr_solver.turn_bucket_targets(node)
+            bucketed = self.bucket_player_ranges([node.player_ranges[0], node.player_ranges[1]])
+            iv = self.prepare_input_vector(bucketed, node.public_state.board_cards, node.public_state.pot_size, node.public_state.actions)
+            rec = {"input_vector": iv, "target_v1": [float(x) for x in t1], "target_v2": [float(x) for x in t2]}
+            chunk.append(rec)
+            count += 1
+            if len(chunk) >= int(chunk_size):
+                self._persist_npz_chunk(chunk, out_dir, "turn", chunk_idx, meta)
+                chunk = []
+                chunk_idx += 1
+        if chunk:
+            self._persist_npz_chunk(chunk, out_dir, "turn", chunk_idx, meta)
+        return {"written_chunks": int(chunk_idx + (1 if chunk else 0))}
+
 	def range_generator_spec(self):
 		return {
 			"name": "recursive_R.v1",
