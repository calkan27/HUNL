--- a/public_state.py
+++ b/public_state.py
@@ -475,62 +475,63 @@
 		return self
 
 
-	def apply_exogenous_opponent_bet(self, bettor, amount):
-		if self.is_terminal:
-			return self
-		if bettor not in (0, 1):
-			return self
-		if amount is None:
-			return self
-		other = (bettor + 1) % 2
-		prev_my = int(self.current_bets[bettor])
-		prev_opp = int(self.current_bets[other])
-		prev_to_call = prev_opp - prev_my
-		if prev_to_call < 0:
-			prev_to_call = 0
-		a = float(amount)
-		if a < 0:
-			a = 0.0
-		avail = float(self.stacks[bettor])
-		delta = a if a <= avail else avail
-		if delta <= 0.0:
-			return self
-		self.stacks[bettor] = self.stacks[bettor] - delta
-		self.current_bets[bettor] = self.current_bets[bettor] + delta
-		self.pot_size = self.pot_size + delta
-		new_my = int(self.current_bets[bettor])
-		new_opp = int(self.current_bets[other])
-		inc = 0
-		if new_my > prev_opp:
-			if prev_to_call == 0:
-				inc = new_my - prev_my
-			else:
-				inc = new_my - prev_opp
-			if inc < 0:
-				inc = 0
-		if inc > 0:
-			self.last_raiser = int(bettor)
-			self.last_raise_increment = int(inc)
-		if self.players_in_hand.count(True) == 1:
-			self.is_terminal = True
-		if not self.is_terminal:
-			if self.current_bets[bettor] == self.current_bets[other]:
-				self._advance_street_if_closed(actor=bettor)
-				self._fast_forward_to_showdown_if_allin_locked()
-		if not self.is_terminal:
-			if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
-				self.current_player = other
-		if self.pot_size < 0:
-			self.pot_size = 0
-		i = 0
-		while i < 2:
-			if self.stacks[i] > self.initial_stacks[i]:
-				self.stacks[i] = self.initial_stacks[i]
-			if self.current_bets[i] < 0:
-				self.current_bets[i] = 0
-			i = i + 1
-		self.last_action = ("EXOGENOUS_BET", int(bettor), float(delta))
-		return self
+    def apply_exogenous_opponent_bet(self, bettor, amount):
+        if self.is_terminal:
+            return self
+        if bettor not in (0, 1):
+            return self
+        if amount is None:
+            return self
+        other = (bettor + 1) % 2
+        prev_my = int(self.current_bets[bettor])
+        prev_opp = int(self.current_bets[other])
+        prev_to_call = prev_opp - prev_my
+        if prev_to_call < 0:
+            prev_to_call = 0
+        a = float(amount)
+        if a < 0:
+            a = 0.0
+        avail = float(self.stacks[bettor])
+        delta = a if a <= avail else avail
+        if delta <= 0.0:
+            return self
+        self.stacks[bettor] = self.stacks[bettor] - delta
+        self.current_bets[bettor] = self.current_bets[bettor] + delta
+        self.pot_size = self.pot_size + delta
+        new_my = int(self.current_bets[bettor])
+        new_opp = int(self.current_bets[other])
+        inc = 0
+        if new_my > prev_opp:
+            if prev_to_call == 0:
+                inc = new_my - prev_my
+            else:
+                inc = new_my - prev_opp
+            if inc < 0:
+                inc = 0
+        if inc > 0:
+            self.last_raiser = int(bettor)
+            self.last_raise_increment = int(inc)
+            self.last_raise_was_allin_below_min = None
+        if self.players_in_hand.count(True) == 1:
+            self.is_terminal = True
+        if not self.is_terminal:
+            if self.current_bets[bettor] == self.current_bets[other]:
+                self._advance_street_if_closed(actor=bettor)
+                self._fast_forward_to_showdown_if_allin_locked()
+        if not self.is_terminal:
+            if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
+                self.current_player = other
+        if self.pot_size < 0:
+            self.pot_size = 0
+        i = 0
+        while i < 2:
+            if self.stacks[i] > self.initial_stacks[i]:
+                self.stacks[i] = self.initial_stacks[i]
+            if self.current_bets[i] < 0:
+                self.current_bets[i] = 0
+            i = i + 1
+        self.last_action = ("EXOGENOUS_BET", int(bettor), float(delta))
+        return self
 
 	def legal_actions(self):
 		p = self.current_player
