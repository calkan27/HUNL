--- a/smoke_eval_checks.py
+++ b/smoke_eval_checks.py
@@ -61,26 +61,26 @@
 	return True
 
 
-def pot_monotonicity_ok_sequence(ps, steps: int = 6) -> bool:
-
-	seq_ok = True
-	cur = ps
-	i = 0
-	while i < steps and not cur.is_terminal:
-		before = cur.pot_size
-		if cur.current_bets[cur.current_player] == cur.current_bets[(cur.current_player + 1) % 2]:
-			menu = [ActionType.CALL, ActionType.HALF_POT_BET, ActionType.POT_SIZED_BET, ActionType.ALL_IN]
-		else:
-			menu = [ActionType.FOLD, ActionType.CALL, ActionType.ALL_IN]
-		a = random.choice(menu) if menu else ActionType.CALL
-		cur = cur.update_state(GameNode(cur), Action(a))
-		after = cur.pot_size
-		if after + 1e-12 < before:
-			seq_ok = False
-			break
-		i += 1
-	return seq_ok
-
+def pot_monotonicity_ok_sequence(ps, steps: int = 6, allowed_actions=None) -> bool:
+        seq_ok = True
+        cur = ps
+        i = 0
+        default_allowed = {ActionType.FOLD, ActionType.CALL, ActionType.POT_SIZED_BET, ActionType.ALL_IN}
+        allowed = set(allowed_actions) if allowed_actions is not None else default_allowed
+        while i < steps and not cur.is_terminal:
+                before = cur.pot_size
+                legal = list(cur.legal_actions()) if hasattr(cur, "legal_actions") else []
+                menu = [a for a in legal if a in allowed] if legal else []
+                if not menu:
+                        menu = [ActionType.CALL] if ActionType.CALL in legal else (legal if legal else [ActionType.CALL])
+                a = random.choice(menu)
+                cur = cur.update_state(GameNode(cur), Action(a))
+                after = cur.pot_size
+                if after + 1e-12 < before:
+                        seq_ok = False
+                        break
+                i += 1
+        return seq_ok
 
 def verify_outer_zero_sum_residual(models: dict, K: int, samples: int = 1000, tol: float = 1e-6, seed: int = 1729) -> Dict[str, dict]:
 
