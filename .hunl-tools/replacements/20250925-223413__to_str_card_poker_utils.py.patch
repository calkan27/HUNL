--- a/poker_utils.py
+++ b/poker_utils.py
@@ -30,48 +30,97 @@
 
 
 def _to_str_card(c):
-
-	if isinstance(c, str):
-		s = c
-	elif isinstance(c, (list, tuple)):
-		parts = []
-		i = 0
-		while i < len(c):
-			parts.append(_bi.str(c[i]))
-			i += 1
-		s = "".join(parts)
-	else:
-		s = _bi.str(c)
-
-	s = s.strip().upper()
-
-	if len(s) >= 2 and (s[0] in RANKS) and (s[1] in SUITS):
-		return s[0] + s[1]
-	if len(s) >= 2 and (s[0] in SUITS) and (s[1] in RANKS):
-		return s[1] + s[0]
-	if len(s) >= 3 and s[0] == "1" and s[1] == "0" and (s[2] in SUITS):
-		return "T" + s[2]
-
-	r_pick = None
-	t_pick = None
-	i = 0
-	while i < len(s):
-		ch = s[i]
-		if (r_pick is None) and (ch == "1") and (i + 1 < len(s)) and (s[i + 1] == "0"):
-			r_pick = "T"
-			i += 1
-		elif (r_pick is None) and (ch in RANKS):
-			r_pick = ch
-		elif (t_pick is None) and (ch in SUITS):
-			t_pick = ch
-		if (r_pick is not None) and (t_pick is not None):
-			break
-		i += 1
-
-	if (r_pick is not None) and (t_pick is not None):
-		return r_pick + t_pick
-
-	return s[:2]
+        # Robustly normalize to canonical "RS" (e.g., "TH", "9D") without risking
+        # recursive __str__/upper() paths. Accepts "JH", ("J","H"), ["10","c"], or
+        # arbitrary objects with informative __str__.
+        RSET = set(RANKS)  # "23456789TJQKA"
+        SSET = set(SUITS)  # "CDHS"
+
+        def _upper_ascii(s):
+                out = []
+                i = 0
+                while i < len(s):
+                        ch = s[i]
+                        o = ch
+                        oc = ord(ch)
+                        if 97 <= oc <= 122:
+                                o = chr(oc - 32)
+                        out.append(o)
+                        i += 1
+                return "".join(out)
+
+        def _strip_spaces(s):
+                buf = []
+                i = 0
+                while i < len(s):
+                        ch = s[i]
+                        if not ch.isspace():
+                                buf.append(ch)
+                        i += 1
+                return "".join(buf)
+
+        def _normalize_token(s):
+                return _upper_ascii(_strip_spaces(s))
+
+        def _pick_rank_suit(s):
+                # s is uppercase, no spaces
+                if len(s) >= 3 and s[0] == "1" and s[1] == "0" and (s[2] in SSET):
+                        return "T", s[2]
+                if len(s) >= 2 and (s[0] in RSET) and (s[1] in SSET):
+                        return s[0], s[1]
+                if len(s) >= 2 and (s[0] in SSET) and (s[1] in RSET):
+                        return s[1], s[0]
+                r_pick = None
+                t_pick = None
+                i = 0
+                while i < len(s):
+                        ch = s[i]
+                        if r_pick is None:
+                                if (ch == "1") and (i + 1 < len(s)) and (s[i + 1] == "0"):
+                                        r_pick = "T"
+                                        i += 1
+                                elif ch in RSET:
+                                        r_pick = ch
+                        if (t_pick is None) and (ch in SSET):
+                                t_pick = ch
+                        if (r_pick is not None) and (t_pick is not None):
+                                break
+                        i += 1
+                return r_pick, t_pick
+
+        # Case 1: direct string
+        if isinstance(c, str):
+                s = _normalize_token(c)
+                r, t = _pick_rank_suit(s)
+                return (r + t) if (r and t) else s[:2]
+
+        # Case 2: pair-like container
+        if isinstance(c, (list, tuple)):
+                a = c[0] if len(c) >= 1 else ""
+                b = c[1] if len(c) >= 2 else ""
+                as_ = _normalize_token(a if isinstance(a, str) else f"{a}")
+                bs_ = _normalize_token(b if isinstance(b, str) else f"{b}")
+
+                # try rank-from-first, suit-from-second
+                r1 = "T" if (as_.startswith("10")) else (as_[0] if as_ else None)
+                t1 = bs_[0] if bs_ else None
+                if (r1 in RSET) and (t1 in SSET):
+                        return r1 + t1
+
+                # try swapped
+                r2 = "T" if (bs_.startswith("10")) else (bs_[0] if bs_ else None)
+                t2 = as_[0] if as_ else None
+                if (r2 in RSET) and (t2 in SSET):
+                        return r2 + t2
+
+                flat = _normalize_token(as_ + bs_)
+                r, t = _pick_rank_suit(flat)
+                return (r + t) if (r and t) else flat[:2]
+
+        # Case 3: other types â€” stringify cautiously, then parse
+        s_flat = _normalize_token(f"{c}")
+        r, t = _pick_rank_suit(s_flat)
+        return (r + t) if (r and t) else s_flat[:2]
 
 def _normalize_cards(card_iterable):
 	out = []
