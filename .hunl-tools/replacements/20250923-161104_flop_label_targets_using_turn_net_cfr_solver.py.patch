--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -520,27 +520,34 @@
 			except Exception:
 				pass
 		return True
-	def flop_label_targets_using_turn_net(self, node):
-		old_flag = bool(getattr(self, "_label_pot_fraction", False))
-		self._label_pot_fraction = True
-		old_depth = int(getattr(self, "depth_limit", 1))
-		try:
-			self.depth_limit = max(1, old_depth)
-			self.run_cfr(node)
-			v0 = self._expected_cfv_vector(node, player=0)
-			v1 = self._expected_cfv_vector(node, player=1)
-			K = int(self.num_clusters)
-			out0 = [0.0] * K
-			out1 = [0.0] * K
-			for cid in range(K):
-				a = v0.get(int(cid), [0.0])
-				b = v1.get(int(cid), [0.0])
-				out0[cid] = float(a[0] if isinstance(a, (list, tuple)) and len(a) > 0 else a)
-				out1[cid] = float(b[0] if isinstance(b, (list, tuple)) and len(b) > 0 else b)
-			return out0, out1
-		finally:
-			self._label_pot_fraction = old_flag
-			self.depth_limit = old_depth
+    def flop_label_targets_using_turn_net(self, node):
+        old_flag = bool(getattr(self, "_label_pot_fraction", False))
+        self._label_pot_fraction = True
+        old_depth = int(getattr(self, "depth_limit", 1))
+        self._ensure_sparse_schedule()
+        round_flags_backup = {int(k): {"half_pot": bool(v.get("half_pot", True)), "two_pot": bool(v.get("two_pot", False))} for k, v in getattr(self, "_round_actions", {}).items()}
+        for r in (0, 1, 2, 3):
+            self._round_actions[int(r)] = {"half_pot": False, "two_pot": False}
+        snap_cards = self._push_no_card_abstraction_for_node(node)
+        try:
+            self.depth_limit = max(1, old_depth)
+            self.run_cfr(node)
+            v0 = self._expected_cfv_vector(node, player=0)
+            v1 = self._expected_cfv_vector(node, player=1)
+            K = int(self.num_clusters)
+            out0 = [0.0] * K
+            out1 = [0.0] * K
+            for cid in range(K):
+                a = v0.get(int(cid), [0.0])
+                b = v1.get(int(cid), [0.0])
+                out0[cid] = float(a[0] if isinstance(a, (list, tuple)) and len(a) > 0 else a)
+                out1[cid] = float(b[0] if isinstance(b, (list, tuple)) and len(b) > 0 else b)
+            return out0, out1
+        finally:
+            self._pop_no_card_abstraction(snap_cards, node)
+            self._round_actions = round_flags_backup
+            self._label_pot_fraction = old_flag
+            self.depth_limit = old_depth
 
 	def _expected_cfv_vector(self, node, player):
 		A = len(ActionType)
