--- a/cfv_trainer.py
+++ b/cfv_trainer.py
@@ -131,24 +131,31 @@
 
 
 def _eval_loss_cfv(model, train_samples, val_samples, split, batch_size, device, criterion, K: int):
+        model.eval()
+        total_huber = 0.0
+        total_mae = 0.0
+        count = 0
+        residual_max = 0.0
+        with torch.no_grad():
+                source = val_samples if split == "val" else train_samples
+                for xb, y1b, y2b in _cfv_batcher(source, batch_size, shuffle=False, device=device):
+                        r1b, r2b = _ranges_from_inputs(xb, K)
+                        p1, p2 = model(xb)
+                        f1, f2 = model.enforce_zero_sum(r1b, r2b, p1, p2)
+                        l1 = criterion(f1, y1b)
+                        l2 = criterion(f2, y2b)
+                        l = 0.5 * (l1 + l2)
+                        mae = 0.5 * (torch.mean(torch.abs(f1 - y1b)) + torch.mean(torch.abs(f2 - y2b)))
+                        s1 = torch.sum(r1b * f1, dim=1)
+                        s2 = torch.sum(r2b * f2, dim=1)
+                        res = torch.abs(s1 + s2)
+                        bs = xb.shape[0]
+                        total_huber += float(l.item()) * bs
+                        total_mae += float(mae.item()) * bs
+                        count += bs
+                        mx = float(torch.max(res).item()) if res.numel() > 0 else 0.0
+                        if mx > residual_max:
+                                residual_max = mx
+        den = max(1, count)
+        return total_huber / den, total_mae / den, residual_max
 
-	model.eval()
-	total_huber = 0.0
-	total_mae = 0.0
-	count = 0
-	with torch.no_grad():
-		source = val_samples if split == "val" else train_samples
-		for xb, y1b, y2b in _cfv_batcher(source, batch_size, shuffle=False, device=device):
-			r1b, r2b = _ranges_from_inputs(xb, K)
-			p1, p2 = model(xb)
-			f1, f2 = model.enforce_zero_sum(r1b, r2b, p1, p2)
-			l1 = criterion(f1, y1b)
-			l2 = criterion(f2, y2b)
-			l = 0.5 * (l1 + l2)
-			mae = 0.5 * (torch.mean(torch.abs(f1 - y1b)) + torch.mean(torch.abs(f2 - y2b)))
-			bs = xb.shape[0]
-			total_huber += float(l.item()) * bs
-			total_mae += float(mae.item()) * bs
-			count += bs
-	den = max(1, count)
-	return total_huber / den, total_mae / den
