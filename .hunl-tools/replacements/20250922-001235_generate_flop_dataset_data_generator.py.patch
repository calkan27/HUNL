--- a/data_generator.py
+++ b/data_generator.py
@@ -525,65 +525,43 @@
 				 meta_pot_spec=str(meta.get("pot_sampler","")),
 				 meta_range_spec=str(meta.get("range_generator","")))
 		return out_path
-	def generate_flop_dataset(self, num_situations, out_dir, chunk_size=50000, seed=2027, persist_format="npz"):
-		rng = random.Random(int(seed))
-		meta = {
-			"schema": "cfv.dataset.flop.v1",
-			"created_at": int(time.time()),
-			"stage": "flop",
-			"num_clusters": int(self.num_clusters),
-			"pot_sampler": self.pot_sampler_spec(),
-			"range_generator": self.range_generator_spec(),
-		}
-		count = 0
-		chunk = []
-		chunk_idx = 0
-		while count < int(num_situations):
-			node_flop = self._sample_flop_situation(rng)
-			public_flop = node_flop.public_state.clone()
-			used = set(public_flop.board_cards + public_flop.hole_cards[0] + public_flop.hole_cards[1])
-			avail = [c for c in DECK if c not in used]
-			if not avail:
-				continue
-			turn_card = rng.choice(avail)
-			public_turn = public_flop.clone()
-			public_turn.current_round = 2
-			public_turn.board_cards = list(public_flop.board_cards) + [turn_card]
-			public_turn.current_bets = [0, 0]
-			public_turn.last_raiser = None
-			public_turn.pot_size = float(public_flop.pot_size)
-			public_turn.current_player = (public_turn.dealer + 1) % 2
-			node_turn = GameNode(public_turn)
-			node_turn.player_ranges = [dict(node_flop.player_ranges[0]), dict(node_flop.player_ranges[1])]
-			self.cfr_solver.clusters = dict(self.clusters) if hasattr(self, "clusters") else dict(self.cfr_solver.clusters)
-			cf0 = self.cfr_solver.predict_counterfactual_values(node_turn, player=0)
-			cf1 = self.cfr_solver.predict_counterfactual_values(node_turn, player=1)
-			K = int(self.num_clusters)
-			t1 = [0.0] * K
-			t2 = [0.0] * K
-			for i in range(K):
-				v0 = cf0.get(i, [0.0])
-				v1 = cf1.get(i, [0.0])
-				t1[i] = float(v0[0] if isinstance(v0, (list, tuple)) else v0)
-				t2[i] = float(v1[0] if isinstance(v1, (list, tuple)) else v1)
-			bucketed = self.bucket_player_ranges([node_flop.player_ranges[0], node_flop.player_ranges[1]])
-			iv = self.prepare_input_vector(bucketed, public_flop.board_cards, public_flop.pot_size, public_flop.actions)
-			rec = {"input_vector": iv, "target_v1": t1, "target_v2": t2}
-			chunk.append(rec)
-			count += 1
-			if len(chunk) >= int(chunk_size):
-				if str(persist_format).lower() == "npz":
-					self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
-				else:
-					self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
-				chunk = []
-				chunk_idx += 1
-		if chunk:
-			if str(persist_format).lower() == "npz":
-				self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
-			else:
-				self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
-		return {"written_chunks": int(chunk_idx + (1 if chunk else 0))}
+    def generate_flop_dataset(self, num_situations, out_dir, chunk_size=50000, seed=2027, persist_format="npz"):
+        rng = random.Random(int(seed))
+        meta = {
+            "schema": "cfv.dataset.flop.v2",
+            "created_at": int(time.time()),
+            "stage": "flop",
+            "num_clusters": int(self.num_clusters),
+            "pot_sampler": self.pot_sampler_spec(),
+            "range_generator": self.range_generator_spec(),
+        }
+        count = 0
+        chunk = []
+        chunk_idx = 0
+        while count < int(num_situations):
+            node_flop = self._sample_flop_situation(rng)
+            self.cfr_solver.total_iterations = 1000
+            self.cfr_solver.depth_limit = max(1, int(getattr(self, "depth_limit", 1)))
+            t1, t2 = self.cfr_solver.flop_label_targets_using_turn_net(node_flop)
+            bucketed = self.bucket_player_ranges([node_flop.player_ranges[0], node_flop.player_ranges[1]])
+            iv = self.prepare_input_vector(bucketed, node_flop.public_state.board_cards, node_flop.public_state.pot_size, node_flop.public_state.actions)
+            rec = {"input_vector": iv, "target_v1": [float(x) for x in t1], "target_v2": [float(x) for x in t2]}
+            chunk.append(rec)
+            count += 1
+            if len(chunk) >= int(chunk_size):
+                if str(persist_format).lower() == "npz":
+                    self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
+                else:
+                    self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
+                chunk = []
+                chunk_idx += 1
+        if chunk:
+            if str(persist_format).lower() == "npz":
+                self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
+            else:
+                self._persist_npz_chunk(chunk, out_dir, "flop", chunk_idx, meta)
+        return {"written_chunks": int(chunk_idx + (1 if chunk else 0))}
+
 	def generate_flop_dataset_using_turn(self, turn_model, num_situations, out_dir=None, chunk_size=50000, seed=2027):
 		rng = random.Random(int(seed))
 		meta = {
