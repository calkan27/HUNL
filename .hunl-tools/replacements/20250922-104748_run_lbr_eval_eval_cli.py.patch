--- a/eval_cli.py
+++ b/eval_cli.py
@@ -306,64 +306,74 @@
 	freq_log[key][name] = freq_log[key].get(name, 0) + 1
 	return best if best is not None else ActionType.CALL
 def run_lbr_eval(episodes: int = 10000, seed: int = 1729, cfg: ResolveConfig = None, policy_iters_agent: int = 2, policy_iters_after_lbr: int = 2):
-	random.seed(seed)
-	if cfg is None:
-		cfg = ResolveConfig.from_env({})
-	agent_solver = CFRSolver(config=cfg)
-	agent_solver.load_models()
-	K = agent_solver.num_clusters
-	u = 1.0 / float(K) if K > 0 else 0.0
-	freq = {"flop": {"FOLD": 0, "CALL": 0, "POT": 0, "ALL_IN": 0}}
-	results = []
-	i = 0
-	while i < int(episodes):
-		i += 1
-		ps = PublicState(initial_stacks=[200, 200], board_cards=None, dealer=(i % 2))
-		ps.current_round = 0
-		ps.current_player = ps.dealer
-		node = GameNode(ps)
-		node.player_ranges[0] = {j: u for j in range(K)}
-		node.player_ranges[1] = {j: u for j in range(K)}
-		last_ps = ps
-		guard = 0
-		while not node.public_state.is_terminal and guard < 400:
-			guard += 1
-			cur_ps = node.public_state
-			if int(cur_ps.current_round) == 1 and int(cur_ps.current_player) == 1:
-				act = lbr_greedy_action(cur_ps, agent_solver, lbr_player=1, iters_after=policy_iters_after_lbr, freq_log=freq)
-			else:
-				act = _engine_policy_action(agent_solver, node, iters=policy_iters_agent)
-			new_ps = cur_ps.update_state(node, Action(act))
-			if not _no_negative_pot_delta(cur_ps, new_ps):
-				break
-			node = GameNode(new_ps)
-			node.player_ranges[0] = {j: u for j in range(K)}
-			node.player_ranges[1] = {j: u for j in range(K)}
-			last_ps = cur_ps
-		res = node.public_state.terminal_utility() if hasattr(node.public_state, "terminal_utility") else [0.0, 0.0]
-		results.append(float(res[0]))
-	diag = agent_solver.get_last_diagnostics()
-	mean = sum(results) / float(len(results) if results else 1)
-	bb = 2.0
-	mbbg = (mean / bb) * 1000.0
-	var = 0.0
-	for r in results:
-		d = r - mean
-		var += d * d
-	var = var / float(len(results) - 1 if len(results) > 1 else 1)
-	se = math.sqrt(var / float(len(results) if results else 1))
-	l95 = mbbg - 1.96 * ((se / bb) * 1000.0)
-	u95 = mbbg + 1.96 * ((se / bb) * 1000.0)
-	out = {
-		"episodes": int(episodes),
-		"mbb_per_game": float(mbbg),
-		"ci95": [float(l95), float(u95)],
-		"freq": {"flop": {k: int(v) for k, v in freq.get("flop", {}).items()}},
-		"sanity": {
-			"zero_sum_residual_max_ok": _zero_sum_residual_ok_from_solver(agent_solver, tol=1e-6)
-		}
-	}
-	return out
+        random.seed(seed)
+        if cfg is None:
+                cfg = ResolveConfig.from_env({})
+        agent_solver = CFRSolver(config=cfg)
+        agent_solver.load_models()
+        K = agent_solver.num_clusters
+        u = 1.0 / float(K) if K > 0 else 0.0
+        freq = {"flop": {"FOLD": 0, "CALL": 0, "POT": 0, "ALL_IN": 0}}
+        results = []
+        residual_max = 0.0
+        i = 0
+        while i < int(episodes):
+                i += 1
+                ps = PublicState(initial_stacks=[200, 200], board_cards=None, dealer=(i % 2))
+                ps.current_round = 0
+                ps.current_player = ps.dealer
+                node = GameNode(ps)
+                node.player_ranges[0] = {j: u for j in range(K)}
+                node.player_ranges[1] = {j: u for j in range(K)}
+                last_ps = ps
+                guard = 0
+                while not node.public_state.is_terminal and guard < 400:
+                        guard += 1
+                        cur_ps = node.public_state
+                        if not _mass_conservation_ok_ranges(node.player_ranges[0], node.player_ranges[1], tol=1e-12):
+                                raise ValueError("LBRInvariantRangeMass")
+                        if int(cur_ps.current_round) == 1 and int(cur_ps.current_player) == 1:
+                                act = lbr_greedy_action(cur_ps, agent_solver, lbr_player=1, iters_after=policy_iters_after_lbr, freq_log=freq)
+                        else:
+                                act = _engine_policy_action(agent_solver, node, iters=policy_iters_agent)
+                                dg = agent_solver.get_last_diagnostics()
+                                if isinstance(dg, dict):
+                                        residual_max = max(residual_max, float(dg.get("zero_sum_residual", 0.0)))
+                        new_ps = cur_ps.update_state(node, Action(act))
+                        if int(new_ps.current_round) - int(cur_ps.current_round) > 1 or int(new_ps.current_round) < int(cur_ps.current_round):
+                                raise ValueError("LBRIllegalStreetJump")
+                        if not _no_negative_pot_delta(cur_ps, new_ps):
+                                raise ValueError("LBRNegativePotDelta")
+                        node = GameNode(new_ps)
+                        node.player_ranges[0] = {j: u for j in range(K)}
+                        node.player_ranges[1] = {j: u for j in range(K)}
+                        last_ps = cur_ps
+                res = node.public_state.terminal_utility() if hasattr(node.public_state, "terminal_utility") else [0.0, 0.0]
+                results.append(float(res[0]))
+        mean = sum(results) / float(len(results) if results else 1)
+        bb = 2.0
+        mbbg = (mean / bb) * 1000.0
+        import math
+        var = 0.0
+        for r in results:
+                d = r - mean
+                var += d * d
+        var = var / float(len(results) - 1 if len(results) > 1 else 1)
+        se = math.sqrt(var / float(len(results) if results else 1))
+        l95 = mbbg - 1.96 * ((se / bb) * 1000.0)
+        u95 = mbbg + 1.96 * ((se / bb) * 1000.0)
+        out = {
+                "episodes": int(episodes),
+                "mbb_per_game": float(mbbg),
+                "ci95": [float(l95), float(u95)],
+                "accept": bool(u95 <= -300.0),
+                "freq": {"flop": {k: int(v) for k, v in freq.get("flop", {}).items()}},
+                "sanity": {
+                        "zero_sum_residual_max": float(residual_max),
+                        "zero_sum_residual_max_ok": bool(residual_max <= 1e-6)
+                }
+        }
+        return out
 
 def _diag_from_solver(ps, K, r_us, r_opp):
 	try:
