--- a/river_endgame.py
+++ b/river_endgame.py
@@ -235,31 +235,33 @@
 			ev_o_by_cluster[int(oid)] = ev_o
 		return ev_p_by_cluster, ev_o_by_cluster
 
-	def compute_cluster_cfvs(self, clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn):
-		board = list(node.public_state.board_cards)
-		board_list_norm = [str(c)[0].upper() + str(c)[1].lower() for c in board]
-		board_set_upper = set(str(c).upper() for c in board)
-		resolved_pot = self._resolved_pot(node)
-		my = int(player)
-		opp = (my + 1) % 2
-		my_range = self._normalize_range(node.player_ranges[my])
-		opp_range = self._normalize_range(node.player_ranges[opp])
-		if not hasattr(self, "_river_cache"):
-			self._river_cache = {}
-		sig = self._node_signature(node, my_range, opp_range)
-		if sig in self._river_cache and isinstance(self._river_cache[sig], dict) and my in self._river_cache[sig]:
-			return dict(self._river_cache[sig][my])
-		if self.num_buckets is None or self.num_buckets <= 0:
-			ev_p_by_cluster, ev_o_by_cluster = self._ev_no_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot)
-		else:
-			ev_p_by_cluster, ev_o_by_cluster = self._ev_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, best_hand_fn, hand_rank_fn, resolved_pot)
-			if ev_p_by_cluster is None:
-				ev_p_by_cluster, ev_o_by_cluster = self._ev_no_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot)
-		scale = (1.0 / float(resolved_pot)) if resolved_pot > 0.0 else 1.0
-		my_vals = {int(cid): float(ev_p_by_cluster.get(int(cid), 0.0) * scale) for cid in my_range.keys()}
-		opp_vals = {int(oid): float(ev_o_by_cluster.get(int(oid), 0.0) * scale) for oid in opp_range.keys()}
-		self._river_cache[sig] = {my: dict(my_vals), opp: dict(opp_vals)}
-		return dict(self._river_cache[sig][my])
+    def compute_cluster_cfvs(self, clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn):
+        board = list(node.public_state.board_cards)
+        board_list_norm = [str(c)[0].upper() + str(c)[1].lower() for c in board]
+        board_set_upper = set(str(c).upper() for c in board)
+        resolved_pot = self._resolved_pot(node)
+        my = int(player)
+        opp = (my + 1) % 2
+        my_range = self._normalize_range(node.player_ranges[my])
+        opp_range = self._normalize_range(node.player_ranges[opp])
+        if not hasattr(self, "_river_cache"):
+            self._river_cache = {}
+        sig = self._node_signature(node, my_range, opp_range)
+        if sig in self._river_cache and isinstance(self._river_cache[sig], dict) and my in self._river_cache[sig]:
+            return dict(self._river_cache[sig][my])
+        if self.num_buckets is None or self.num_buckets <= 0:
+            ev_p_by_cluster, ev_o_by_cluster = self._ev_no_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot)
+        else:
+            ev_p_by_cluster, ev_o_by_cluster = self._ev_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, best_hand_fn, hand_rank_fn, resolved_pot)
+            if ev_p_by_cluster is None:
+                ev_p_by_cluster, ev_o_by_cluster = self._ev_no_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot)
+        scale = (1.0 / float(resolved_pot)) if resolved_pot > 0.0 else 1.0
+        my_vals_scalar = {int(cid): float(ev_p_by_cluster.get(int(cid), 0.0) * scale) for cid in my_range.keys()}
+        opp_vals_scalar = {int(oid): float(ev_o_by_cluster.get(int(oid), 0.0) * scale) for oid in opp_range.keys()}
+        my_vals = {int(k): [float(v)] * 4 for k, v in my_vals_scalar.items()}
+        opp_vals = {int(k): [float(v)] * 4 for k, v in opp_vals_scalar.items()}
+        self._river_cache[sig] = {my: dict(my_vals), opp: dict(opp_vals)}
+        return dict(self._river_cache[sig][my])
 
 	def _resolved_pot(self, node):
 		ps = node.public_state
