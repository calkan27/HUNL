--- a/river_endgame.py
+++ b/river_endgame.py
@@ -70,53 +70,81 @@
 		else:
 			return 0.5 * P
 
-	def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
-		p = list(my_bucket_probs)
-		q = list(opp_bucket_probs)
-
-		def _norm(v):
-			s = sum(v) or 0.0
-			if s > 0.0:
-				return [float(x) / s for x in v]
-			return [0.0] * len(v)
-
-		p = _norm(p)
-		q = _norm(q)
-		B = int(B)
-
-		if my_bet is not None or opp_bet is not None:
-			mb = float(my_bet or 0.0)
-			ob = float(opp_bet or 0.0)
-			def pay(i, j):
-				if i > j:
-					return ob
-				elif i < j:
-					return -mb
-				else:
-					return 0.5 * (ob - mb)
-		else:
-			P = float(resolved_pot if resolved_pot is not None else 1.0)
-			def pay(i, j):
-				if i > j:
-					return P
-				elif i < j:
-					return -P
-				else:
-					return 0.5 * P
-
-		ev_p = 0.0
-		for i in range(B):
-			if p[i] == 0.0:
-				continue
-			row = 0.0
-			for j in range(B):
-				if q[j] == 0.0:
-					continue
-				row += q[j] * pay(i, j)
-			ev_p += p[i] * row
-
-		ev_o = -ev_p
-		return ev_p, ev_o
+    def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
+        p = list(my_bucket_probs)
+        q = list(opp_bucket_probs)
+
+        def _norm(v):
+            s = sum(v) or 0.0
+            if s > 0.0:
+                return [float(x) / s for x in v]
+            return [0.0] * len(v)
+
+        p = _norm(p)
+        q = _norm(q)
+        B = int(B)
+
+        if my_bet is not None or opp_bet is not None:
+            mb = float(my_bet or 0.0)
+            ob = float(opp_bet or 0.0)
+            def pay_p(i, j):
+                if i > j:
+                    return ob
+                elif i < j:
+                    return -mb
+                else:
+                    if abs(ob - mb) < 1e-12:
+                        return 0.0
+                    return 0.5 * (ob - mb)
+            def pay_opp(i, j):
+                if i > j:
+                    return mb
+                elif i < j:
+                    return -ob
+                else:
+                    if abs(ob - mb) < 1e-12:
+                        return 0.0
+                    return 0.5 * (mb - ob)
+        else:
+            P = float(resolved_pot if resolved_pot is not None else 1.0)
+            def pay_p(i, j):
+                if i > j:
+                    return P
+                elif i < j:
+                    return -P
+                else:
+                    return 0.0
+            def pay_opp(i, j):
+                if i > j:
+                    return P
+                elif i < j:
+                    return -P
+                else:
+                    return 0.0
+
+        ev_p = 0.0
+        for i in range(B):
+            if p[i] == 0.0:
+                continue
+            row = 0.0
+            for j in range(B):
+                if q[j] == 0.0:
+                    continue
+                row += q[j] * pay_p(i, j)
+            ev_p += p[i] * row
+
+        ev_opp_direct = 0.0
+        for i in range(B):
+            if q[i] == 0.0:
+                continue
+            row = 0.0
+            for j in range(B):
+                if p[j] == 0.0:
+                    continue
+                row += p[j] * pay_opp(i, j)
+            ev_opp_direct += q[i] * row
+
+        return ev_p, -ev_opp_direct
 
 	def _normalize_range(self, r):
 		out = {int(k): float(v) for k, v in dict(r).items()}
