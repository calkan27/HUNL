--- a/public_state.py
+++ b/public_state.py
@@ -398,65 +398,67 @@
 				new_state.current_bets[i] = 0
 		return new_state
 
-	def apply_exogenous_opponent_all_in(self, bettor):
-		if self.is_terminal:
-			return self
-		if bettor not in (0, 1):
-			return self
-		other = (bettor + 1) % 2
-		my_bet = self.current_bets[bettor]
-		opp_bet = self.current_bets[other]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-		caller_stack_before = self.stacks[bettor]
-		matched = caller_stack_before if caller_stack_before < to_call else to_call
-		self.stacks[bettor] = caller_stack_before - matched
-		self.current_bets[bettor] = self.current_bets[bettor] + matched
-		self.pot_size = self.pot_size + matched
-		if matched < to_call:
-			excess = to_call - matched
-			self.current_bets[other] = self.current_bets[other] - excess
-			self.stacks[other] = self.stacks[other] + excess
-			self.pot_size = self.pot_size - excess
-			self._advance_street_if_closed(actor=bettor)
-			self._fast_forward_to_showdown_if_allin_locked()
-		else:
-			all_in_amount_remaining = self.stacks[bettor]
-			if all_in_amount_remaining < 0:
-				all_in_amount_remaining = 0
-			if all_in_amount_remaining > 0:
-				self.current_bets[bettor] = self.current_bets[bettor] + all_in_amount_remaining
-				self.stacks[bettor] = 0
-				self.pot_size = self.pot_size + all_in_amount_remaining
-				increment_above_call = all_in_amount_remaining
-				min_raise_inc = self._min_raise_size()
-				if to_call == 0:
-					self.last_raiser = bettor
-					self.last_raise_increment = all_in_amount_remaining
-				else:
-					if increment_above_call >= min_raise_inc:
-						self.last_raiser = bettor
-						self.last_raise_increment = increment_above_call
-		if self.current_bets[bettor] == self.current_bets[other]:
-			self._advance_street_if_closed(actor=bettor)
-			self._fast_forward_to_showdown_if_allin_locked()
-		if not self.is_terminal:
-			if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
-				self.current_player = other
-		if self.players_in_hand.count(True) == 1:
-			self.is_terminal = True
-		if self.pot_size < 0:
-			self.pot_size = 0
-		i = 0
-		while i < 2:
-			if self.stacks[i] > self.initial_stacks[i]:
-				self.stacks[i] = self.initial_stacks[i]
-			if self.current_bets[i] < 0:
-				self.current_bets[i] = 0
-			i = i + 1
-		self.last_action = ("EXOGENOUS_ALL_IN", int(bettor))
-		return self
+    def apply_exogenous_opponent_all_in(self, bettor):
+        if self.is_terminal:
+            return self
+        if bettor not in (0, 1):
+            return self
+        prev_pot = float(self.pot_size)
+        other = (bettor + 1) % 2
+        my_bet = self.current_bets[bettor]
+        opp_bet = self.current_bets[other]
+        to_call = opp_bet - my_bet
+        if to_call < 0:
+            to_call = 0
+        caller_stack_before = self.stacks[bettor]
+        matched = caller_stack_before if caller_stack_before < to_call else to_call
+        self.stacks[bettor] = caller_stack_before - matched
+        self.current_bets[bettor] = self.current_bets[bettor] + matched
+        self.pot_size = self.pot_size + matched
+        if matched < to_call:
+            excess = to_call - matched
+            self.current_bets[other] = self.current_bets[other] - excess
+            self.stacks[other] = self.stacks[other] + excess
+            self.pot_size = self.pot_size - excess
+            self._advance_street_if_closed(actor=bettor)
+            self._fast_forward_to_showdown_if_allin_locked()
+        else:
+            all_in_amount_remaining = self.stacks[bettor]
+            if all_in_amount_remaining < 0:
+                all_in_amount_remaining = 0
+            if all_in_amount_remaining > 0:
+                self.current_bets[bettor] = self.current_bets[bettor] + all_in_amount_remaining
+                self.stacks[bettor] = 0
+                self.pot_size = self.pot_size + all_in_amount_remaining
+                increment_above_call = all_in_amount_remaining
+                min_raise_inc = self._min_raise_size()
+                if to_call == 0:
+                    self.last_raiser = bettor
+                    self.last_raise_increment = all_in_amount_remaining
+                else:
+                    if increment_above_call >= min_raise_inc:
+                        self.last_raiser = bettor
+                        self.last_raise_increment = increment_above_call
+        if self.current_bets[bettor] == self.current_bets[other]:
+            self._advance_street_if_closed(actor=bettor)
+            self._fast_forward_to_showdown_if_allin_locked()
+        if not self.is_terminal:
+            if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
+                self.current_player = other
+        if self.players_in_hand.count(True) == 1:
+            self.is_terminal = True
+        if self.pot_size < 0:
+            self.pot_size = 0
+        i = 0
+        while i < 2:
+            if self.stacks[i] > self.initial_stacks[i]:
+                self.stacks[i] = self.initial_stacks[i]
+            if self.current_bets[i] < 0:
+                self.current_bets[i] = 0
+            i = i + 1
+        self.last_action = ("EXOGENOUS_ALL_IN", int(bettor))
+            self._assert_invariants(prev_pot=prev_pot)
+            return self
 
 	def apply_exogenous_opponent_check(self, checker):
 		if self.is_terminal:
