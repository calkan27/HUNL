--- a/agent.py
+++ b/agent.py
@@ -61,73 +61,32 @@
 		return (tuple(ps.board_cards), int(ps.current_round), (int(ps.current_bets[0]), int(ps.current_bets[1])), int(ps.pot_size), int(ps.current_player) if ps.current_player is not None else -1, int(ps.dealer), bool(ps.is_terminal), bool(ps.is_showdown), (bool(ps.players_in_hand[0]), bool(ps.players_in_hand[1])))
 
     def act(self, public_state, our_private_cards):
-        node = GameNode(public_state)
-        cid = self._bucketize_own_hand(list(our_private_cards), list(public_state.board_cards))
+            node = GameNode(public_state)
+            cid = self._bucketize_own_hand(list(our_private_cards), list(public_state.board_cards))
+            key = self._public_key(node.public_state)
 
-        def _beliefs_for_node(nd, own_cid):
-            key = self._public_key(nd.public_state)
             r_self = None
             if hasattr(self.solver, "own_range_tracking") and key in getattr(self.solver, "own_range_tracking", {}):
-                try:
-                    track = dict(self.solver.own_range_tracking[key])
-                    s = sum(float(v) for v in track.values())
-                    if s > 0.0:
-                        for k in list(track.keys()):
-                            track[k] = float(track[k]) / s
-                    r_self = {int(k): float(v) for k, v in track.items()}
-                except Exception:
-                    r_self = None
+                    try:
+                            tr = dict(self.solver.own_range_tracking[key])
+                            s = sum(float(v) for v in tr.values())
+                            if s > 0.0:
+                                    for k in list(tr.keys()):
+                                            tr[k] = float(tr[k]) / s
+                            r_self = {int(k): float(v) for k, v in tr.items()}
+                    except Exception:
+                            r_self = None
             if r_self is None:
-                r_self = self._range_on_bucket(own_cid)
+                    r_self = self._range_on_bucket(cid)
             r_opp = self._uniform_range()
-            return r_self, r_opp
 
-        r_self, r_opp = _beliefs_for_node(node, cid)
-        node.player_ranges[public_state.current_player] = r_self
-        node.player_ranges[(public_state.current_player + 1) % 2] = r_opp
+            node.player_ranges[public_state.current_player] = r_self
+            node.player_ranges[(public_state.current_player + 1) % 2] = r_opp
 
-        self.solver.total_iterations = int(getattr(self.solver, "_round_iters", {}).get(int(public_state.current_round), getattr(self._config, "total_iterations", 1000)))
-        act = self.solver.run_cfr(node)
-        self.last_public_key = self._public_key(node.public_state)
-        return act
+            self._seed_opponent_cfv_upper(node)
 
-	def observe_opponent_action(self, prev_public_state, new_public_state, observed_action_type):
-		prev_node = GameNode(prev_public_state)
-		next_node = GameNode(new_public_state)
-		self.solver.apply_opponent_action_update(prev_node, next_node, observed_action_type)
-		self.last_public_key = self._public_key(new_public_state)
-		return True
+            self.solver.total_iterations = int(getattr(self.solver, "_round_iters", {}).get(int(public_state.current_round), getattr(self._config, "total_iterations", 1000)))
+            act = self.solver.run_cfr(node)
+            self.last_public_key = self._public_key(node.public_state)
+            return act
 
-	def observe_chance(self, new_public_state):
-		node = GameNode(new_public_state)
-		self.solver.lift_ranges_after_chance(node)
-		self.last_public_key = self._public_key(new_public_state)
-		return True
-	def load_bundle(self, path):
-		b = load_cfv_bundle(path, device=self.device)
-		applied = self.solver.apply_cfv_bundle(b, device=self.device)
-		return {"loaded_models": list(b.get("models", {}).keys()), "applied": applied}
-
-
-	def _seed_opponent_cfv_upper(self, node):
-		if not hasattr(self.solver, "opponent_cfv_upper_tracking"):
-			self.solver.opponent_cfv_upper_tracking = {}
-		get_key = getattr(self.solver, "_state_key", None)
-		if not callable(get_key):
-			return False
-		cur_key = get_key(node)
-		if cur_key in self.solver.opponent_cfv_upper_tracking:
-			return True
-		if self.last_public_key is not None:
-			try:
-				prev_node = GameNode(node.public_state)
-				setattr(prev_node, "_public_signature", lambda: (tuple(self.last_public_key[0]), int(self.last_public_key[1]), tuple(self.last_public_key[2]), int(self.last_public_key[3]), int(self.last_public_key[4]), int(self.last_public_key[5]), bool(self.last_public_key[6]), bool(self.last_public_key[7]), tuple(self.last_public_key[8]), tuple()))
-				prev_key = get_key(prev_node)
-				prev_upper = dict(getattr(self.solver, "opponent_cfv_upper_tracking", {}).get(prev_key, {}))
-				if prev_upper:
-					self.solver.opponent_cfv_upper_tracking[cur_key] = {int(k): float(v) for k, v in prev_upper.items()}
-					return True
-			except Exception:
-				pass
-		return False
-
