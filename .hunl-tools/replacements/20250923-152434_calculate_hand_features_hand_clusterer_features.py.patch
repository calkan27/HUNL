--- a/hand_clusterer_features.py
+++ b/hand_clusterer_features.py
@@ -5,48 +5,47 @@
 from poker_utils import DECK
 
 class HandClustererFeaturesMixin:
-	def calculate_hand_features(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> np.ndarray:
-		board_key = ",".join(board)
-		opp_sig = self._opponent_range_signature(opponent_range)
-		cache_key = f"specP3.1|hand={hand}|board={board_key}|pot={float(pot_size):.6f}|opp={opp_sig}"
-		if cache_key in self._cache:
-			self._cache_hits += 1
-			return self._cache[cache_key]
-		self._cache_misses += 1
-		my = hand.split() if isinstance(hand, str) else list(hand)
-		used = set(my + board)
-		deck = [c for c in DECK if c not in used]
-		opp_hands_all = []
-		i = 0
-		while i + 1 < len(deck):
-			a = deck[i]
-			j = i + 1
-			while j < len(deck):
-				b = deck[j]
-				if a != b:
-					opp_hands_all.append([a, b])
-				j += 1
-			i += 1
-		if not opp_hands_all:
-			hist = np.zeros((21,), dtype=float)
-			hist[10] = 1.0
-			self._cache[cache_key] = hist
-			return hist
-		rng = random.Random(self._stable_seed(hand, board))
-		sample_n = min(len(opp_hands_all), max(1, int(getattr(self, "_mc_samples_win", 200))))
-		opp_hands = rng.sample(opp_hands_all, sample_n) if len(opp_hands_all) > sample_n else opp_hands_all
-		hist = np.zeros((21,), dtype=float)
-		total_w = 0.0
-		for oh in opp_hands:
-			w = float(opponent_range.get(f"{oh[0]} {oh[1]}", opponent_range.get(f"{oh[1]} {oh[0]}", 1.0)))
-			p = self._evaluate_win_percentage(my, oh, board)
-			bi = int(round(max(0.0, min(1.0, p)) * 20.0))
-			hist[bi] += w
-			total_w += w
-		if total_w > 0.0:
-			hist = hist / total_w
-		self._cache[cache_key] = hist
-		return hist
+    def calculate_hand_features(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> np.ndarray:
+        board_key = ",".join(board)
+        cache_key = f"specP3.1|hand={hand}|board={board_key}"
+        if cache_key in self._cache:
+            self._cache_hits += 1
+            return self._cache[cache_key]
+        self._cache_misses += 1
+        my = hand.split() if isinstance(hand, str) else list(hand)
+        used = set(my + board)
+        deck = [c for c in DECK if c not in used]
+        opp_hands_all = []
+        i = 0
+        while i + 1 < len(deck):
+            a = deck[i]
+            j = i + 1
+            while j < len(deck):
+                b = deck[j]
+                if a != b:
+                    opp_hands_all.append([a, b])
+                j += 1
+            i += 1
+        if not opp_hands_all:
+            hist = np.zeros((21,), dtype=float)
+            hist[10] = 1.0
+            self._cache[cache_key] = hist
+            return hist
+        rng = random.Random(self._stable_seed(hand, board))
+        sample_n = min(len(opp_hands_all), max(1, int(getattr(self, "_mc_samples_win", 200))))
+        opp_hands = rng.sample(opp_hands_all, sample_n) if len(opp_hands_all) > sample_n else opp_hands_all
+        hist = np.zeros((21,), dtype=float)
+        total_w = 0.0
+        for oh in opp_hands:
+            w = float(opponent_range.get(f"{oh[0]} {oh[1]}", opponent_range.get(f"{oh[1]} {oh[0]}", 1.0)))
+            p = self._evaluate_win_percentage(my, oh, board)
+            bi = int(round(max(0.0, min(1.0, p)) * 20.0))
+            hist[bi] += w
+            total_w += w
+        if total_w > 0.0:
+            hist = hist / total_w
+        self._cache[cache_key] = hist
+        return hist
 
 	def _evaluate_win_percentage(self, player_hand: List[str], opponent_hand: List[str], board: List[str]) -> float:
 		if len(board) >= 5:
