--- a/public_state_utils.py
+++ b/public_state_utils.py
@@ -157,98 +157,94 @@
 			"parity": int(parity),
 		}
 
-	def legal_actions(
-		self
-	):
-		out: List[ActionType] = []
-
-		p = int(getattr(self, "current_player", 0))
-		o = (p + 1) % 2
-
-		cb = list(getattr(self, "current_bets", [0, 0]))
-		if len(cb) < 2:
-			cb = [0, 0]
-
-		my_bet = int(cb[p])
-		opp_bet = int(cb[o])
-
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-
-		min_raise_inc = int(self._min_raise_size())
-
-		allow_raises = (getattr(self, "last_raise_was_allin_below_min", None) is None)
-
-		if to_call > 0:
-			out.append(ActionType.FOLD)
-
-		out.append(ActionType.CALL)
-
-		if not (self.players_in_hand[0] and self.players_in_hand[1]):
-			seen = set()
-			filt = []
-
-			i = 0
-			while i < len(out):
-				a = out[i]
-				if a not in seen:
-					seen.add(a)
-					filt.append(a)
-				i += 1
-
-			return filt
-
-		if to_call == 0:
-			if int(self.stacks[p]) > 0:
-				if allow_raises:
-					hp = max(min_raise_inc, int(float(self.pot_size) * 0.5))
-					if (hp > 0) and (int(self.stacks[p]) >= hp):
-						out.append(ActionType.HALF_POT_BET)
-
-					pt = max(min_raise_inc, int(float(self.pot_size)))
-					if (pt > 0) and (int(self.stacks[p]) >= pt):
-						out.append(ActionType.POT_SIZED_BET)
-
-					tp = max(min_raise_inc, int(float(self.pot_size) * 2.0))
-					if (tp > 0) and (int(self.stacks[p]) >= tp):
-						out.append(ActionType.TWO_POT_BET)
-
-					out.append(ActionType.ALL_IN)
-		else:
-			if int(self.stacks[p]) > 0:
-				if int(self.stacks[p]) <= int(to_call):
-					out.append(ActionType.ALL_IN)
-				else:
-					if allow_raises:
-						rem = int(self.stacks[p]) - int(to_call)
-						if rem > 0:
-							pac = float(self.pot_size) + float(to_call)
-
-							hp = max(min_raise_inc, int(pac * 0.5))
-							if (hp > 0) and (rem >= hp):
-								out.append(ActionType.HALF_POT_BET)
-
-							pt = max(min_raise_inc, int(pac))
-							if (pt > 0) and (rem >= pt):
-								out.append(ActionType.POT_SIZED_BET)
-
-							tp = max(min_raise_inc, int(pac * 2.0))
-							if (tp > 0) and (rem >= tp):
-								out.append(ActionType.TWO_POT_BET)
-
-							out.append(ActionType.ALL_IN)
-
-		seen = set()
-		filt: List[ActionType] = []
-
-		i = 0
-		while i < len(out):
-			a = out[i]
-			if a not in seen:
-				seen.add(a)
-				filt.append(a)
-			i += 1
-
-		return filt
-
+    def legal_actions(self):
+        out: List[ActionType] = []
+        p = int(getattr(self, "current_player", 0))
+        o = (p + 1) % 2
+
+        cb = list(getattr(self, "current_bets", [0, 0]))
+        if len(cb) < 2:
+            cb = [0, 0]
+
+        my_bet = int(cb[p])
+        opp_bet = int(cb[o])
+
+        to_call = opp_bet - my_bet
+        if to_call < 0:
+            to_call = 0
+
+        min_raise_inc = int(self._min_raise_size())
+        allow_raises = (
+            getattr(self, "last_raise_was_allin_below_min", None) is None
+        )
+
+        if to_call > 0:
+            out.append(ActionType.FOLD)
+
+        out.append(ActionType.CALL)
+
+        if not (self.players_in_hand[0] and self.players_in_hand[1]):
+            seen_vals = set()
+            filt: List[ActionType] = []
+            i = 0
+            while i < len(out):
+                a = out[i]
+                vi = int(a.value)
+                if vi not in seen_vals:
+                    seen_vals.add(vi)
+                    filt.append(a)
+                i += 1
+            return filt
+
+        if to_call == 0:
+            if int(self.stacks[p]) > 0:
+                if allow_raises:
+                    hp = max(min_raise_inc, int(float(self.pot_size) * 0.5))
+                    if (hp > 0) and (int(self.stacks[p]) >= hp):
+                        out.append(ActionType.HALF_POT_BET)
+
+                    pt = max(min_raise_inc, int(float(self.pot_size)))
+                    if (pt > 0) and (int(self.stacks[p]) >= pt):
+                        out.append(ActionType.POT_SIZED_BET)
+
+                    tp = max(min_raise_inc, int(float(self.pot_size) * 2.0))
+                    if (tp > 0) and (int(self.stacks[p]) >= tp):
+                        out.append(ActionType.TWO_POT_BET)
+
+                    out.append(ActionType.ALL_IN)
+        else:
+            if int(self.stacks[p]) > 0:
+                if int(self.stacks[p]) <= int(to_call):
+                    out.append(ActionType.ALL_IN)
+                else:
+                    if allow_raises:
+                        rem = int(self.stacks[p]) - int(to_call)
+                        if rem > 0:
+                            pac = float(self.pot_size) + float(to_call)
+
+                            hp = max(min_raise_inc, int(pac * 0.5))
+                        if (hp > 0) and (rem >= hp):
+                            out.append(ActionType.HALF_POT_BET)
+
+                        pt = max(min_raise_inc, int(pac))
+                        if (pt > 0) and (rem >= pt):
+                            out.append(ActionType.POT_SIZED_BET)
+
+                        tp = max(min_raise_inc, int(pac * 2.0))
+                        if (tp > 0) and (rem >= tp):
+                            out.append(ActionType.TWO_POT_BET)
+
+                        out.append(ActionType.ALL_IN)
+
+    seen_vals = set()
+    filt: List[ActionType] = []
+    i = 0
+    while i < len(out):
+        a = out[i]
+        vi = int(a.value)
+        if vi not in seen_vals:
+            seen_vals.add(vi)
+            filt.append(a)
+        i += 1
+    return filt
+
