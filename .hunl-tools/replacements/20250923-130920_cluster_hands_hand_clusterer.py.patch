--- a/hand_clusterer.py
+++ b/hand_clusterer.py
@@ -97,166 +97,183 @@
 				self.opp_sample_size = int(opp_sample_size) if opp_sample_size is not None else None
 				self.use_cfv_in_features = bool(use_cfv_in_features)
 
-	def cluster_hands(
-		self,
-		hands: Any,
-		board: List[str],
-		opponent_range: Dict[Any, float],
-		pot_size: float,
-	) -> Dict[int, Set[str]]:
-
-		if self.profile == "test":
-			ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
-			assert ok
-			if self._fast_test_frozen_clusters is not None:
-				if os.getenv("DEBUG_FAST_TESTS") == "1":
-					print("[FASTTEST] Returning frozen clusters (reuse)")
-				return self._fast_test_frozen_clusters
-
-			if os.getenv("DEBUG_FAST_TESTS") == "1":
-				print("[FASTTEST] Building frozen clusters (O(n); no features/MC/K-means)")
-
-			if isinstance(hands, (set, dict)):
-				hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
-			else:
-				hands_list = list(hands)
-				hands_list.sort()
-
-			K = int(self.num_clusters)
-			N = len(hands_list)
-			clusters: Dict[int, Set[str]] = {i: set() for i in range(K)}
-
-			if N == 0:
-				self._fast_test_frozen_clusters = clusters
-				self.clusters = clusters
-				self.centroids = None
-				self._fast_test_initialized = True
-				return clusters
-
-			if N < K:
-				rng = random.Random(self._fast_test_seed)
-				perm = list(range(K))
-				rng.shuffle(perm)
-				for idx, hand in enumerate(hands_list):
-					clusters[perm[idx]] = {hand}
-			else:
-				for hand in hands_list:
-					key = hand if isinstance(hand, str) else " ".join(list(hand))
-					h = hashlib.sha256(key.encode("utf-8")).hexdigest()
-					cls = int(h, 16) % K
-					clusters[cls].add(hand)
-
-			for k in range(K):
-				if k not in clusters:
-					clusters[k] = set()
-			empties = [k for k, v in clusters.items() if len(v) == 0]
-			if empties:
-				donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-				for e in empties:
-					if not donors:
-						break
-					dk, _ = donors[0]
-					move = sorted(clusters[dk])[0]
-					clusters[dk].remove(move)
-					clusters[e].add(move)
-					donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-
-			self._fast_test_frozen_clusters = clusters
-			self.clusters = clusters
-			self.centroids = None
-			self._last_features = None
-			self._fast_test_initialized = True
-			return clusters
-
-		start_time = time.time()
-		hits_before = self._cache_hits
-		misses_before = self._cache_misses
-
-		hand_features: Dict[str, np.ndarray] = {}
-		if isinstance(hands, dict):
-			iterable = hands.keys()
-		else:
-			iterable = hands
-		for h in iterable:
-			features = self.calculate_hand_features(h, board, opponent_range, pot_size)
-			hand_features[h] = features
-
-		D_t = self._compute_drift(hand_features)
-		should_recluster = False
-		if self.clusters is None or self.centroids is None:
-			should_recluster = True
-		else:
-			if D_t is None:
-				should_recluster = True
-			else:
-				should_recluster = bool(D_t >= self.tau_re)
-
-		if not should_recluster:
-			total_time = time.time() - start_time
-			print(f"[INFO] Reusing previous clustering (D_t={D_t:.4f} < Ï„_re={self.tau_re:.4f}); time {total_time:.4f}s")
-			print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-			return self.clusters
-
-		rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
-		feature_vectors = np.array(list(hand_features.values()))
-		norms = np.linalg.norm(feature_vectors, axis=1, keepdims=True)
-		normalized_features = feature_vectors / norms
-
-		N = len(hand_features)
-		if N < self.num_clusters:
-			self.num_clusters = N
-
-		idx_all = np.arange(N)
-		rs.shuffle(idx_all)
-		initial_indices = idx_all[: self.num_clusters]
-		centroids = normalized_features[initial_indices].copy()
-
-		previous_cluster_ids = None
-		iteration = 0
-		while iteration < int(self.max_iterations):
-			distances = np.linalg.norm(normalized_features[:, np.newaxis] - centroids, axis=2)
-			cluster_ids = np.argmin(distances, axis=1)
-			if previous_cluster_ids is not None and np.array_equal(cluster_ids, previous_cluster_ids):
-				break
-			previous_cluster_ids = cluster_ids.copy()
-
-			for i in range(int(self.num_clusters)):
-				members = normalized_features[cluster_ids == i]
-				if len(members) > 0:
-					centroids[i] = np.mean(members, axis=0)
-				else:
-					centroids[i] = normalized_features[rs.randint(0, N)]
-			iteration += 1
-
-		clusters: Dict[int, Set[str]] = defaultdict(set)
-		hlist = list(hand_features.keys())
-		for idx, h in enumerate(hlist):
-			clusters[int(cluster_ids[idx])].add(h)
-
-		K = int(self.num_clusters)
-		for k in range(K):
-			if k not in clusters:
-				clusters[k] = set()
-		empties = [k for k, v in clusters.items() if len(v) == 0]
-		if empties:
-			donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-			for e in empties:
-				if not donors:
-					break
-				dk, _ = donors[0]
-				move = sorted(clusters[dk])[0]
-				clusters[dk].remove(move)
-				clusters[e].add(move)
-				donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-
-		self.clusters = clusters
-		self.centroids = centroids
-		self._last_features = hand_features
-
-		total_time2 = time.time() - start_time
-		print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
-		print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-		return clusters
+    def cluster_hands(
+        self,
+        hands: Any,
+        board: List[str],
+        opponent_range: Dict[Any, float],
+        pot_size: float,
+    ) -> Dict[int, Set[str]]:
+
+        if self.profile == "test":
+            ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
+            assert ok
+            if self._fast_test_frozen_clusters is not None:
+                return self._fast_test_frozen_clusters
+
+            if isinstance(hands, (set, dict)):
+                hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
+            else:
+                hands_list = list(hands)
+                hands_list.sort()
+
+            K = int(self.num_clusters)
+            N = len(hands_list)
+            clusters: Dict[int, Set[str]] = {i: set() for i in range(K)}
+
+            if N == 0:
+                self._fast_test_frozen_clusters = clusters
+                self.clusters = clusters
+                self.centroids = None
+                self._fast_test_initialized = True
+                return clusters
+
+            if N < K:
+                rng = random.Random(self._fast_test_seed)
+                perm = list(range(K))
+                rng.shuffle(perm)
+                for idx, hand in enumerate(hands_list):
+                    clusters[perm[idx]] = {hand}
+            else:
+                for hand in hands_list:
+                    key = hand if isinstance(hand, str) else " ".join(list(hand))
+                    h = hashlib.sha256(key.encode("utf-8")).hexdigest()
+                    cls = int(h, 16) % K
+                    clusters[cls].add(hand)
+
+            for k in range(K):
+                if k not in clusters:
+                    clusters[k] = set()
+            empties = [k for k, v in clusters.items() if len(v) == 0]
+            if empties:
+                donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+                for e in empties:
+                    if not donors:
+                        break
+                    dk, _ = donors[0]
+                    move = sorted(clusters[dk])[0]
+                    clusters[dk].remove(move)
+                    clusters[e].add(move)
+                    donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+
+            self._fast_test_frozen_clusters = clusters
+            self.clusters = clusters
+            self.centroids = None
+            self._last_features = None
+            self._fast_test_initialized = True
+            return clusters
+
+        start_time = time.time()
+        hits_before = self._cache_hits
+        misses_before = self._cache_misses
+
+        hand_features: Dict[str, np.ndarray] = {}
+        if isinstance(hands, dict):
+            iterable = hands.keys()
+        else:
+            iterable = hands
+        for h in iterable:
+            features = self.calculate_hand_features(h, board, opponent_range, pot_size)
+            hand_features[h] = features
+
+        enable_reuse = bool(getattr(self, "_config", None) and getattr(self._config, "enable_drift_reuse", False))
+        if enable_reuse and self.clusters is not None and self.centroids is not None:
+            D_t = self._compute_drift(hand_features)
+            if D_t is not None and D_t < self.tau_re:
+                return self.clusters
+
+        rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
+        feature_vectors = np.array(list(hand_features.values()))
+        norms = np.linalg.norm(feature_vectors, axis=1, keepdims=True)
+        normalized_features = feature_vectors / norms
+
+        N = len(hand_features)
+        if N < self.num_clusters:
+            self.num_clusters = N
+
+        idx_all = np.arange(N)
+        rs.shuffle(idx_all)
+        initial_indices = idx_all[: self.num_clusters]
+        centroids = normalized_features[initial_indices].copy()
+
+        previous_cluster_ids = None
+        iteration = 0
+        while iteration < int(self.max_iterations):
+            distances = np.linalg.norm(normalized_features[:, np.newaxis] - centroids, axis=2)
+            cluster_ids = np.argmin(distances, axis=1)
+            if previous_cluster_ids is not None and np.array_equal(cluster_ids, previous_cluster_ids):
+                break
+            previous_cluster_ids = cluster_ids.copy()
+            for i in range(int(self.num_clusters)):
+                members = normalized_features[cluster_ids == i]
+                if len(members) > 0:
+                    centroids[i] = np.mean(members, axis=0)
+                else:
+                    centroids[i] = normalized_features[rs.randint(0, N)]
+            iteration += 1
+
+        clusters_raw: Dict[int, Set[str]] = defaultdict(set)
+        hlist = list(hand_features.keys())
+        for idx, h in enumerate(hlist):
+            clusters_raw[int(cluster_ids[idx])].add(h)
+
+        K = int(self.num_clusters)
+        for k in range(K):
+            if k not in clusters_raw:
+                clusters_raw[k] = set()
+        empties = [k for k, v in clusters_raw.items() if len(v) == 0]
+        if empties:
+            donors = sorted([(k, len(v)) for k, v in clusters_raw.items() if len(v) > 1], key=lambda x: -x[1])
+            for e in empties:
+                if not donors:
+                    break
+                dk, _ = donors[0]
+                move = sorted(clusters_raw[dk])[0]
+                clusters_raw[dk].remove(move)
+                clusters_raw[e].add(move)
+                donors = sorted([(k, len(v)) for k, v in clusters_raw.items() if len(v) > 1], key=lambda x: -x[1])
+
+        if enable_reuse and isinstance(self.clusters, dict) and self.clusters:
+            prev = {int(k): set(v) for k, v in self.clusters.items()}
+            used_prev = set()
+            mapping = {}
+            for nc in sorted(clusters_raw.keys()):
+                best_p = None
+                best_overlap = -1
+                for pc in sorted(prev.keys()):
+                    if pc in used_prev:
+                        continue
+                    ov = len(clusters_raw[nc] & prev[pc])
+                    if ov > best_overlap:
+                        best_overlap = ov
+                        best_p = pc
+                if best_p is not None:
+                    mapping[int(nc)] = int(best_p)
+                    used_prev.add(int(best_p))
+            free_prev = [p for p in sorted(prev.keys()) if p not in used_prev]
+            free_new = [n for n in sorted(clusters_raw.keys()) if n not in mapping]
+            for n, p in zip(free_new, free_prev):
+                mapping[int(n)] = int(p)
+            clusters_aligned: Dict[int, Set[str]] = {int(k): set() for k in range(K)}
+            for n, hands_set in clusters_raw.items():
+                tgt = int(mapping.get(int(n), int(n)))
+                if 0 <= tgt < K:
+                    clusters_aligned[tgt].update(hands_set)
+            for k in range(K):
+                if k not in clusters_aligned:
+                    clusters_aligned[k] = set()
+            clusters = clusters_aligned
+        else:
+            clusters = {int(k): set(v) for k, v in clusters_raw.items()}
+
+        self.clusters = clusters
+        self.centroids = centroids
+        self._last_features = hand_features
+
+        total_time2 = time.time() - start_time
+        print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
+        print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
+        return clusters
 
 	def fit(
 		self,
