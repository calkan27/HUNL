--- a/hand_clusterer_features.py
+++ b/hand_clusterer_features.py
@@ -41,39 +41,38 @@
 			vec = vec / n
 		self._cache[cache_key] = vec
 		return vec
-	def _calculate_counterfactual_value(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> float:
-		hand_cards = hand.split() if isinstance(hand, str) else list(hand)
-		used = set(hand_cards + board)
-		avail = [c for c in DECK if c not in used]
-		opp_hands = []
-		i = 0
-		while i + 1 < len(avail):
-			a = avail[i]
-			j = i + 1
-			while j < len(avail):
-				b = avail[j]
-				if a != b:
-					opp_hands.append([a, b])
-				j += 1
-			i += 1
-		if not opp_hands:
-			return 0.0
-		rng = random.Random(self._stable_seed(hand, board))
-		sample_n = min(len(opp_hands), max(1, int(getattr(self, "_mc_samples_win", 200))))
-		if len(opp_hands) > sample_n:
-			opp_hands = rng.sample(opp_hands, sample_n)
-		total = 0.0
-		den = float(len(opp_hands))
-		for oh in opp_hands:
-			res = self.cfr_solver._player_wins(hand_cards, oh, board)
-			if res > 0:
-				total += 1.0
-		elif res < 0:
-			total += -1.0
-		else:
-			total += 0.0
-	avg = total / den if den > 0 else 0.0
-	return float(avg) * float(pot_size)
+    def _calculate_counterfactual_value(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> float:
+        hand_cards = hand.split() if isinstance(hand, str) else list(hand)
+        used = set(hand_cards + board)
+        avail = [c for c in DECK if c not in used]
+        opp_hands = []
+        i = 0
+        while i + 1 < len(avail):
+            a = avail[i]
+            j = i + 1
+            while j < len(avail):
+                b = avail[j]
+                if a != b:
+                    opp_hands.append([a, b])
+                j += 1
+            i += 1
+        if not opp_hands:
+            return 0.0
+        rng = random.Random(self._stable_seed(hand, board))
+        sample_n = min(len(opp_hands), max(1, int(getattr(self, "_mc_samples_win", 200))))
+        if len(opp_hands) > sample_n:
+            opp_hands = rng.sample(opp_hands, sample_n)
+        total = 0.0
+        den = float(len(opp_hands))
+        for oh in opp_hands:
+            res = self.cfr_solver._player_wins(hand_cards, oh, board)
+            if res > 0:
+                total += float(pot_size)
+            elif res < 0:
+                total += -float(pot_size)
+            else:
+                total += 0.0
+        return total / den if den > 0 else 0.0
 
 def _emd_distance(self, sig1: np.ndarray, sig2: np.ndarray) -> float:
 	a = np.asarray(sig1, dtype=float).ravel()
