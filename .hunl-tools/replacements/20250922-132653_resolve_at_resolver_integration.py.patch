--- a/resolver_integration.py
+++ b/resolver_integration.py
@@ -10,92 +10,100 @@
 
 
 def resolve_at(public_state, r_us: Dict[int, float], w_opp: Dict[int, float], config: Optional[Dict[str, Any]] = None, value_server: Optional[ValueServer] = None) -> Tuple[Dict[Any, float], Dict[int, float], Dict[int, float]]:
-		if config is None:
-				config = {}
-		stage_map = {0: "preflop", 1: "flop", 2: "turn", 3: "river"}
-		cr = int(getattr(public_state, "current_round", 0))
-		stage = stage_map.get(cr, "none")
-		if stage not in ("flop", "turn"):
-				stage = "flop"
-		K = int(len(r_us))
-		def _to_vec(d: Dict[int, float], k: int) -> List[float]:
-				v = [0.0] * k
-				s = 0.0
-				for i, p in d.items():
-						ii = int(i)
-						if 0 <= ii < k:
-								pi = float(p)
-								v[ii] = pi
-								s += pi
-				if s > 0.0:
-						for i in range(k):
-								v[i] = v[i] / s
-				return v
-		r_our_vec = _to_vec(r_us, K)
-		r_opp_init = config.get("r_opp_init", None)
-		if isinstance(r_opp_init, dict):
-				r_opp_vec = _to_vec(r_opp_init, K)
-		else:
-				if K > 0:
-						u = 1.0 / float(K)
-						r_opp_vec = [u] * K
-				else:
-						r_opp_vec = []
-		w_vec = _to_vec(w_opp, K)
-		if value_server is None:
-				if "value_server" in config and isinstance(config["value_server"], ValueServer):
-						value_server = config["value_server"]
-				elif "models" in config and isinstance(config["models"], dict):
-						value_server = ValueServer(models=config["models"], device=config.get("device", None))
-				elif "bundle_path" in config and isinstance(config["bundle_path"], str):
-						loaded = load_cfv_bundle(config["bundle_path"], device=config.get("device", None))
-						value_server = ValueServer(models=loaded.get("models", {}), device=config.get("device", None))
-				else:
-						value_server = ValueServer(models={})
-		depth_limit = int(config.get("depth_limit", 1))
-		if "bet_fractions" in config:
-				bet_fractions = list(config["bet_fractions"])
-		else:
-				bet_fractions = [0.5, 1.0, 2.0] if stage == "turn" else [0.5, 1.0]
-		include_all_in = True
-		builder = LookaheadTreeBuilder(depth_limit=depth_limit, bet_fractions=bet_fractions, include_all_in=include_all_in)
-		root = builder.build(public_state)
-		def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
-				total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
-				if total_initial <= 0.0:
-						total_initial = 1.0
-				pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
-				bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
-				x = [pot_norm] + list(bvec) + list(r1) + list(r2)
-				xt = torch.tensor([x], dtype=torch.float32)
-				st = "turn" if int(getattr(ps, "current_round", 2)) == 2 else "flop"
-				v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
-				out = v1 if int(pov_player) == 0 else v2
-				return out[0]
-		T = int(config.get("iterations", 1000))
-		cfr = PublicChanceCFR(
-				depth_limit=depth_limit,
-				bet_fractions=bet_fractions,
-				include_all_in=include_all_in,
-				regret_matching_plus=bool(config.get("rm_plus", True)),
-				importance_weighting=True
-		)
-		warm = config.get("warm_start", None)
-		if isinstance(warm, dict):
-				cfr.set_warm_start(warm)
-		root_policy, node_values, opp_cfv = cfr.solve_subgame(
-				root_node=root,
-				r_us=r_our_vec,
-				r_opp=r_opp_vec,
-				opp_cfv_constraints=w_vec,
-				T=T,
-				leaf_value_fn=_leaf_value_fn
-		)
-		our_cfv_vec = {}
-		if isinstance(node_values, dict):
-				for i, v in node_values.items():
-						try:
-								our_cfv_vec[int(i)] = float(v)
-						except Exception:
-								continue
-		return root_policy, {int(k): float(v) for k, v in opp_cfv.items()}, our_cfv_vec
+        if config is None:
+                config = {}
+        stage_map = {0: "preflop", 1: "flop", 2: "turn", 3: "river"}
+        cr = int(getattr(public_state, "current_round", 0))
+        stage = stage_map.get(cr, "none")
+        if stage not in ("flop", "turn"):
+                stage = "flop"
+        K = int(len(r_us))
+        def _to_vec(d: Dict[int, float], k: int) -> List[float]:
+                v = [0.0] * k
+                s = 0.0
+                for i, p in d.items():
+                        ii = int(i)
+                        if 0 <= ii < k:
+                                pi = float(p)
+                                v[ii] = pi
+                                s += pi
+                if s > 0.0:
+                        for i in range(k):
+                                v[i] = v[i] / s
+                return v
+        r_our_vec = _to_vec(r_us, K)
+        r_opp_init = config.get("r_opp_init", None)
+        if isinstance(r_opp_init, dict):
+                r_opp_vec = _to_vec(r_opp_init, K)
+        else:
+                if K > 0:
+                        u = 1.0 / float(K)
+                        r_opp_vec = [u] * K
+                else:
+                        r_opp_vec = []
+        w_vec = _to_vec(w_opp, K)
+        if value_server is None:
+                if "value_server" in config and isinstance(config["value_server"], ValueServer):
+                        value_server = config["value_server"]
+                elif "models" in config and isinstance(config["models"], dict):
+                        value_server = ValueServer(models=config["models"], device=config.get("device", None))
+                elif "bundle_path" in config and isinstance(config["bundle_path"], str):
+                        loaded = load_cfv_bundle(config["bundle_path"], device=config.get("device", None))
+                        value_server = ValueServer(models=loaded.get("models", {}), device=config.get("device", None))
+                else:
+                        value_server = ValueServer(models={})
+        user_depth = int(config.get("depth_limit", 1))
+        if stage == "turn":
+                depth_limit = 99
+        else:
+                depth_limit = user_depth
+        if "bet_fractions" in config:
+                bet_fractions = list(config["bet_fractions"])
+        else:
+                bet_fractions = [0.5, 1.0, 2.0] if stage == "turn" else [0.5, 1.0]
+        include_all_in = True
+        builder = LookaheadTreeBuilder(depth_limit=depth_limit, bet_fractions=bet_fractions, include_all_in=include_all_in)
+        root = builder.build(public_state)
+        def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
+                total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
+                if total_initial <= 0.0:
+                        total_initial = 1.0
+                pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
+                bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
+                if int(getattr(ps, "current_round", 0)) >= 2:
+                        Kloc = len(r1) if isinstance(r1, list) else 0
+                        return torch.zeros(Kloc, dtype=torch.float32)
+                x = [pot_norm] + list(bvec) + list(r1) + list(r2)
+                xt = torch.tensor([x], dtype=torch.float32)
+                st = "flop"
+                v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
+                out = v1 if int(pov_player) == 0 else v2
+                return out[0]
+        T = int(config.get("iterations", 1000))
+        cfr = PublicChanceCFR(
+                depth_limit=depth_limit,
+                bet_fractions=bet_fractions,
+                include_all_in=include_all_in,
+                regret_matching_plus=bool(config.get("rm_plus", True)),
+                importance_weighting=True
+        )
+        warm = config.get("warm_start", None)
+        if isinstance(warm, dict):
+                cfr.set_warm_start(warm)
+        root_policy, node_values, opp_cfv = cfr.solve_subgame(
+                root_node=root,
+                r_us=r_our_vec,
+                r_opp=r_opp_vec,
+                opp_cfv_constraints=w_vec,
+                T=T,
+                leaf_value_fn=_leaf_value_fn
+        )
+        our_cfv_vec = {}
+        if isinstance(node_values, dict):
+                for i, v in node_values.items():
+                        try:
+                                our_cfv_vec[int(i)] = float(v)
+                        except Exception:
+                                continue
+        return root_policy, {int(k): float(v) for k, v in opp_cfv.items()}, our_cfv_vec
+
