--- a/river_endgame.py
+++ b/river_endgame.py
@@ -205,93 +205,93 @@
 		bmap, B = self._bucketize(all_strengths)
 		return bmap, B
 
-	def _ev_bucket(self, clusters, board_list_norm, board_set_upper, my_range, opp_range, best_hand_fn, hand_rank_fn, resolved_pot):
-		bmap, B = self._bucket_mixes(
-			clusters,
-			list(my_range.keys()) + list(opp_range.keys()),
-			list(board_list_norm),
-			board_set_upper,
-			best_hand_fn,
-			hand_rank_fn,
-		)
-		if bmap is None:
-			return None, None
-
-		opp_bucket_mix = [0.0] * B
-		total_opp_weight = 0.0
-		for oid, oprob in opp_range.items():
-			if float(oprob) <= 0.0:
-				continue
-			hf = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
-			if not hf:
-				continue
-			local = [0.0] * B
-			for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
-				local[bmap[s]] += 1.0
-			tm = sum(local)
-			if tm > 0.0:
-				for i in range(B):
-					local[i] = local[i] / tm
-			for i in range(B):
-				opp_bucket_mix[i] += float(oprob) * local[i]
-			total_opp_weight += float(oprob)
-		if total_opp_weight > 0.0:
-			for i in range(B):
-				opp_bucket_mix[i] = opp_bucket_mix[i] / total_opp_weight
-
-		my_bucket_mix_global = [0.0] * B
-		total_my_weight = 0.0
-		for cid, cprob in my_range.items():
-			if float(cprob) <= 0.0:
-				continue
-			hf = self._filtered_hands_for_cluster(clusters, cid, board_set_upper)
-			if not hf:
-				continue
-			local = [0.0] * B
-			for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
-				local[bmap[s]] += 1.0
-			tm = sum(local)
-			if tm > 0.0:
-				for i in range(B):
-					local[i] = local[i] / tm
-			for i in range(B):
-				my_bucket_mix_global[i] += float(cprob) * local[i]
-			total_my_weight += float(cprob)
-		if total_my_weight > 0.0:
-			for i in range(B):
-				my_bucket_mix_global[i] = my_bucket_mix_global[i] / total_my_weight
-
-		ev_p, _ = self._expected_utility_buckets_both(
-			my_bucket_probs=my_bucket_mix_global,
-			opp_bucket_probs=opp_bucket_mix,
-			B=B,
-			resolved_pot=resolved_pot,
-		)
-
-		ev_p_by_cluster = {int(cid): float(ev_p) for cid in my_range.keys()}
-
-		ev_o_by_cluster = {}
-		for oid in opp_range.keys():
-			hf = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
-			if not hf:
-				ev_o_by_cluster[int(oid)] = 0.0
-				continue
-			local_opp = [0.0] * B
-			for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
-				local_opp[bmap[s]] += 1.0
-			tm = sum(local_opp)
-			if tm > 0.0:
-				for i in range(B):
-					local_opp[i] = local_opp[i] / tm
-			_, ev_o = self._expected_utility_buckets_both(
-				my_bucket_probs=local_opp,
-				opp_bucket_probs=opp_bucket_mix,
-				B=B,
-				resolved_pot=resolved_pot,
-			)
-			ev_o_by_cluster[int(oid)] = float(ev_o)
-
-		return ev_p_by_cluster, ev_o_by_cluster
+    def _ev_bucket(self, clusters, board_list_norm, board_set_upper, my_range, opp_range, best_hand_fn, hand_rank_fn, resolved_pot):
+        bmap, B = self._bucket_mixes(
+            clusters,
+            list(my_range.keys()) + list(opp_range.keys()),
+            list(board_list_norm),
+            board_set_upper,
+            best_hand_fn,
+            hand_rank_fn,
+        )
+        if bmap is None:
+            return None, None
+
+        opp_bucket_mix = [0.0] * B
+        total_opp_weight = 0.0
+        for oid, oprob in opp_range.items():
+            if float(oprob) <= 0.0:
+                continue
+            hf = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
+            if not hf:
+                continue
+            local = [0.0] * B
+            for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
+                local[bmap[s]] += 1.0
+            tm = sum(local)
+            if tm > 0.0:
+                for i in range(B):
+                    local[i] = local[i] / tm
+            for i in range(B):
+                opp_bucket_mix[i] += float(oprob) * local[i]
+            total_opp_weight += float(oprob)
+        if total_opp_weight > 0.0:
+            for i in range(B):
+                opp_bucket_mix[i] = opp_bucket_mix[i] / total_opp_weight
+
+        my_bucket_mix_global = [0.0] * B
+        total_my_weight = 0.0
+        for cid, cprob in my_range.items():
+            if float(cprob) <= 0.0:
+                continue
+            hf = self._filtered_hands_for_cluster(clusters, cid, board_set_upper)
+            if not hf:
+                continue
+            local = [0.0] * B
+            for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
+                local[bmap[s]] += 1.0
+            tm = sum(local)
+            if tm > 0.0:
+                for i in range(B):
+                    local[i] = local[i] / tm
+            for i in range(B):
+                my_bucket_mix_global[i] += float(cprob) * local[i]
+            total_my_weight += float(cprob)
+        if total_my_weight > 0.0:
+            for i in range(B):
+                my_bucket_mix_global[i] = my_bucket_mix_global[i] / total_my_weight
+
+        ev_p, ev_o_global = self._expected_utility_buckets_both(
+            my_bucket_probs=my_bucket_mix_global,
+            opp_bucket_probs=opp_bucket_mix,
+            B=B,
+            resolved_pot=resolved_pot,
+        )
+
+        ev_p_by_cluster = {int(cid): float(ev_p) for cid in my_range.keys()}
+
+        ev_o_by_cluster = {}
+        for oid in opp_range.keys():
+            hf = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
+            if not hf:
+                ev_o_by_cluster[int(oid)] = 0.0
+                continue
+            local_opp = [0.0] * B
+            for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
+                local_opp[bmap[s]] += 1.0
+            tm = sum(local_opp)
+            if tm > 0.0:
+                for i in range(B):
+                    local_opp[i] = local_opp[i] / tm
+            _, ev_o_local = self._expected_utility_buckets_both(
+                my_bucket_probs=local_opp,
+                opp_bucket_probs=opp_bucket_mix,
+                B=B,
+                resolved_pot=resolved_pot,
+            )
+            ev_o_by_cluster[int(oid)] = float(ev_o_local)
+
+        return ev_p_by_cluster, ev_o_by_cluster
 
 	def compute_cluster_cfvs(self, clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn):
 		board = list(node.public_state.board_cards)
