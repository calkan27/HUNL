--- a/hand_clusterer_features.py
+++ b/hand_clusterer_features.py
@@ -53,40 +53,30 @@
 			count += 1
 		return total / float(count) if count > 0 else 0.5
 
-	def _calculate_potential_equity_improvement(self, hand: str, board: List[str], opponent_range: Dict[Any, float]) -> float:
-
-		if len(board) >= 5:
-			return 0.0
-
-		items = list(opponent_range.items())
-		items = self._maybe_sample_items(items, seed=self._stable_seed(hand, board))
-		sampled_opponent_range = dict(items)
-
-		current_equity = self._calculate_equity(hand, board, sampled_opponent_range)
-
-		total_improvement = 0.0
-		trials = 0
-
-		used_cards_base = set((hand.split() if isinstance(hand, str) else list(hand)) + board)
-		available_cards_base = [c for c in DECK if c not in used_cards_base]
-		num_cards_to_come = 5 - len(board)
-
-		for _ in range(self._mc_samples_potential):
-			if num_cards_to_come <= 0:
-				new_board = board[:]
-			else:
-				if len(available_cards_base) >= num_cards_to_come:
-					picks = random.sample(available_cards_base, num_cards_to_come)
-				else:
-					picks = []
-				new_board = board + list(picks)
-
-			future_equity = self._calculate_equity(hand, new_board, sampled_opponent_range)
-			improvement = future_equity - current_equity
-			total_improvement += improvement
-			trials += 1
-
-		return total_improvement / float(trials) if trials > 0 else 0.0
+    def _calculate_potential_equity_improvement(self, hand: str, board: List[str], opponent_range: Dict[Any, float]) -> float:
+        if len(board) >= 5:
+            return 0.0
+        hand_cards = hand.split() if isinstance(hand, str) else list(hand)
+        used_base = set(hand_cards + board)
+        avail_base = [c for c in DECK if c not in used_base]
+        num_to_come = 5 - len(board)
+        rng = random.Random(self._stable_seed(hand, board))
+        trials = max(1, int(getattr(self, "_mc_samples_potential", 200)))
+        cur_equity = self._calculate_equity(hand, board, opponent_range)
+        acc = 0.0
+        n = 0
+        t = 0
+        while t < trials:
+            t += 1
+            if num_to_come <= 0 or len(avail_base) < num_to_come:
+                new_board = list(board)
+            else:
+                picks = rng.sample(avail_base, num_to_come)
+                new_board = list(board) + list(picks)
+            fut_equity = self._calculate_equity(hand, new_board, opponent_range)
+            acc += (fut_equity - cur_equity)
+            n += 1
+        return acc / float(n) if n > 0 else 0.0
 
 	def _calculate_counterfactual_value(self, hand: str, board: List[str], opponent_range: Dict[Any, float], pot_size: float) -> float:
 		hand_cards = hand.split() if isinstance(hand, str) else list(hand)
