--- a/cfr_core.py
+++ b/cfr_core.py
@@ -130,103 +130,104 @@
 			else:
 				return 0.0
 
-	def solve_subgame(
-		self,
-		root_node,
-		r_us,
-		r_opp,
-		opp_cfv_constraints,
-		T,
-		leaf_value_fn,
-	):
-		self.regret.clear()
-		self.strat_sum.clear()
-
-		root_idx = 0
-		pov_player = int(getattr(root_node["nodes"][root_idx].public_state, "current_player", 0))
-
-		if int(T) > 0:
-			iters = int(T)
-		else:
-			iters = 1
-
-		for _ in range(iters):
-			self._external_sample_traverse(
-				tree=root_node,
-				idx=root_idx,
-				pov_player=pov_player,
-				r_us=list(r_us),
-				r_opp=list(r_opp),
-				opp_cfv_upper_vec=list(opp_cfv_constraints or []),
-				leaf_value_fn=leaf_value_fn,
-				iw_c=1.0,
-				root_idx=root_idx,
-				apply_root_gadget=True,
-			)
-
-		menu0 = root_node["menus"][root_idx]
-		_max_val = 0
-		has_any = False
-
-		for a in menu0:
-			val = int(getattr(a, "value", 0))
-			has_any = True
-			if val > _max_val:
-				_max_val = val
-
-		if has_any:
-			Aall = _max_val + 1
-		else:
-			Aall = 1
-
-		if Aall < 1:
-			Aall = 1
-
-		key0 = self._infoset_key(root_node, root_idx, pov_player)
-
-		if key0 not in self.strat_sum:
-			k = 0
-			for a in menu0:
-				k += 1
-			if k < 1:
-				k = 1
-			root_policy = {}
-			for a in menu0:
-				root_policy[a] = 1.0 / float(k)
-		else:
-			ss = self.strat_sum[key0]
-			s = 0.0
-			for a in menu0:
-				s += ss[int(getattr(a, "value", 0))]
-
-			if s <= 0.0:
-				k = 0
-				for a in menu0:
-					k += 1
-				if k < 1:
-					k = 1
-				root_policy = {}
-				for a in menu0:
-					root_policy[a] = 1.0 / float(k)
-			else:
-				root_policy = {}
-				for a in menu0:
-					root_policy[a] = ss[int(getattr(a, "value", 0))] / s
-
-		node_values = {}
-
-		opp_cfv = {}
-		if opp_cfv_constraints is not None:
-			_n = len(opp_cfv_constraints)
-		else:
-			_n = 0
-
-		i = 0
-		while i < _n:
-			opp_cfv[i] = float(opp_cfv_constraints[i])
-			i += 1
-
-		return root_policy, node_values, opp_cfv
+    def solve_subgame(
+        self,
+        root_node,
+        r_us,
+        r_opp,
+        opp_cfv_constraints,
+        T,
+        leaf_value_fn,
+    ):
+        self.regret.clear()
+        self.strat_sum.clear()
+
+        root_idx = 0
+        pov_player = int(getattr(root_node["nodes"][root_idx].public_state, "current_player", 0))
+
+        if int(T) > 0:
+            iters = int(T)
+        else:
+            iters = 1
+
+        k = 0
+        while k < iters:
+            self._external_sample_traverse(
+                tree=root_node,
+                idx=root_idx,
+                pov_player=pov_player,
+                r_us=list(r_us),
+                r_opp=list(r_opp),
+                opp_cfv_upper_vec=list(opp_cfv_constraints or []),
+                leaf_value_fn=leaf_value_fn,
+                iw_c=1.0,
+                root_idx=root_idx,
+                apply_root_gadget=True,
+            )
+            k += 1
+
+        menu0 = root_node["menus"][root_idx]
+        if not menu0:
+            menu0 = [ActionType.CALL]
+
+        _max_val = 0
+        has_any = False
+        for a in menu0:
+            val = int(getattr(a, "value", 0))
+            has_any = True
+            if val > _max_val:
+                _max_val = val
+
+        if has_any:
+            Aall = _max_val + 1
+        else:
+            Aall = 1
+        if Aall < 1:
+            Aall = 1
+
+        key0 = self._infoset_key(root_node, root_idx, pov_player)
+
+        if key0 not in self.strat_sum:
+            n = 0
+            for _ in menu0:
+                n += 1
+            if n < 1:
+                n = 1
+            root_policy = {}
+            for a in menu0:
+                root_policy[a] = 1.0 / float(n)
+        else:
+            ss = self.strat_sum[key0]
+            s = 0.0
+            for a in menu0:
+                s += ss[int(getattr(a, "value", 0))]
+            if s <= 0.0:
+                n = 0
+                for _ in menu0:
+                    n += 1
+                if n < 1:
+                    n = 1
+                root_policy = {}
+                for a in menu0:
+                    root_policy[a] = 1.0 / float(n)
+            else:
+                root_policy = {}
+                for a in menu0:
+                    root_policy[a] = ss[int(getattr(a, "value", 0))] / s
+
+        node_values = {}
+
+        opp_cfv = {}
+        if opp_cfv_constraints is not None:
+            nc = len(opp_cfv_constraints)
+        else:
+            nc = 0
+        i = 0
+        while i < nc:
+            opp_cfv[i] = float(opp_cfv_constraints[i])
+            i += 1
+
+        return root_policy, node_values, opp_cfv
 
 	def set_warm_start(self, warm_start: Optional[Dict[Any, List[float]]] = None) -> None:
 		self._warm_start = {}
