--- a/river_endgame.py
+++ b/river_endgame.py
@@ -70,29 +70,33 @@
         else:
             return 0.5 * p
 
-	def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot):
-		ev_p = 0.0
-		ev_o = 0.0
-		i = 0
-		while i < B:
-			j = 0
-			while j < B:
-				p = my_bucket_probs[i] * opp_bucket_probs[j]
-				if i > j:
-					ev_p += p * float(resolved_pot)
-					ev_o += p * (-float(resolved_pot))
-				elif i < j:
-					ev_p += p * (-float(resolved_pot))
-					ev_o += p * float(resolved_pot)
-				else:
-					t = 0.5 * float(resolved_pot)
-					ev_p += p * t
-					ev_o += p * (-t)
-				j += 1
-			i += 1
-		return ev_p, ev_o
-
-
+    def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
+        if resolved_pot is not None:
+            p = float(resolved_pot)
+        elif my_bet is not None or opp_bet is not None:
+            p = float(my_bet or 0.0) + float(opp_bet or 0.0)
+        else:
+            p = 1.0
+        ev_p = 0.0
+        ev_o = 0.0
+        i = 0
+        while i < B:
+            j = 0
+            while j < B:
+                w = float(my_bucket_probs[i]) * float(opp_bucket_probs[j])
+                if i > j:
+                    ev_p += w * p
+                    ev_o -= w * p
+                elif i < j:
+                    ev_p -= w * p
+                    ev_o += w * p
+                else:
+                    t = 0.5 * p
+                    ev_p += w * t
+                    ev_o -= w * t
+                j += 1
+            i += 1
+        return ev_p, ev_o
 
 	def _normalize_range(self, r):
 		out = {int(k): float(v) for k, v in dict(r).items()}
