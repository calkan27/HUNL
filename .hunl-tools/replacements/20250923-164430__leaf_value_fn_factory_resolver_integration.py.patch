--- a/resolver_integration.py
+++ b/resolver_integration.py
@@ -56,27 +56,27 @@
 	return builder.build(public_state)
 
 def _leaf_value_fn_factory(value_server: ValueServer):
-	def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
-		total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
-		if total_initial <= 0.0:
-			total_initial = 1.0
-		if bool(getattr(ps, "is_terminal", False)):
-			u = ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0]
-			val = float(u[int(pov_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
-			p = float(getattr(ps, "pot_size", 0.0))
-			out = (val / p) if p > 0.0 else 0.0
-			return torch.tensor([out], dtype=torch.float32)
-		cr_loc = int(getattr(ps, "current_round", 0))
-		if cr_loc >= 2:
-			return torch.tensor([0.0], dtype=torch.float32)
-		pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
-		bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
-		x = [pot_norm] + list(bvec) + list(r1) + list(r2)
-		xt = torch.tensor([x], dtype=torch.float32)
-		v1, v2 = value_server.query("flop", xt, scale_to_pot=False, as_numpy=False)
-		out = v1 if int(pov_player) == 0 else v2
-		return out[0]
-	return _leaf_value_fn
+        def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
+                total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
+                if total_initial <= 0.0:
+                        total_initial = 1.0
+                if bool(getattr(ps, "is_terminal", False)):
+                        u = ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0]
+                        val = float(u[int(pov_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
+                        p = float(getattr(ps, "pot_size", 0.0))
+                        out = (val / p) if p > 0.0 else 0.0
+                        return torch.tensor([out], dtype=torch.float32)
+                cr_loc = int(getattr(ps, "current_round", 0))
+                if cr_loc >= 2:
+                        return torch.tensor([0.0], dtype=torch.float32)
+                pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
+                bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
+                x = [pot_norm] + list(bvec) + list(r1) + list(r2)
+                xt = torch.tensor([x], dtype=torch.float32)
+                v1, v2 = value_server.query("flop", xt, scale_to_pot=False, as_numpy=False)
+                out = v1 if int(pov_player) == 0 else v2
+                return out[0]
+        return _leaf_value_fn
 
 def _solve_subgame(root, r_us_vec, r_opp_vec, w_vec, depth_limit, bet_fractions, include_all_in, T, leaf_value_fn, config):
 	cfr = PublicChanceCFR(
