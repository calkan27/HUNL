--- a/resolver_integration.py
+++ b/resolver_integration.py
@@ -64,33 +64,28 @@
 
 
 def _leaf_value_fn_factory(value_server: ValueServer):
-		def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
-				total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
-				if total_initial <= 0.0:
-						total_initial = 1.0
-				if bool(getattr(ps, "is_terminal", False)):
-						u = ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0]
-						val = float(u[int(pov_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
-						p = float(getattr(ps, "pot_size", 0.0))
-						out = (val / p) if p > 0.0 else 0.0
-						return torch.tensor([out], dtype=torch.float32)
-				cr_loc = int(getattr(ps, "current_round", 0))
-				if cr_loc >= 3:
-						return torch.tensor([0.0], dtype=torch.float32)
-				pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
-				bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
-				x = [pot_norm] + list(bvec) + list(r1) + list(r2)
-				xt = torch.tensor([x], dtype=torch.float32)
-				if cr_loc == 1:
-						st = "flop"
-				elif cr_loc == 2:
-						st = "turn"
-				else:
-						st = "flop"
-				v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
-				out = v1 if int(pov_player) == 0 else v2
-				return out[0]
-		return _leaf_value_fn
+        def _leaf_value_fn(ps, pov_player: int, r1: List[float], r2: List[float]) -> torch.Tensor:
+                total_initial = float(sum(getattr(ps, "initial_stacks", [200, 200]))) if getattr(ps, "initial_stacks", None) else 1.0
+                if total_initial <= 0.0:
+                        total_initial = 1.0
+                if bool(getattr(ps, "is_terminal", False)):
+                        u = ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0]
+                        val = float(u[int(pov_player)]) if isinstance(u, (list, tuple)) and len(u) >= 2 else 0.0
+                        p = float(getattr(ps, "pot_size", 0.0))
+                        out = (val / p) if p > 0.0 else 0.0
+                        return torch.tensor([out], dtype=torch.float32)
+                cr_loc = int(getattr(ps, "current_round", 0))
+                if cr_loc >= 2:
+                        return torch.tensor([0.0], dtype=torch.float32)
+                pot_norm = float(getattr(ps, "pot_size", 0.0)) / total_initial
+                bvec = board_one_hot(list(getattr(ps, "board_cards", [])))
+                x = [pot_norm] + list(bvec) + list(r1) + list(r2)
+                xt = torch.tensor([x], dtype=torch.float32)
+                st = "flop" if cr_loc == 1 else "flop"
+                v1, v2 = value_server.query(st, xt, scale_to_pot=False, as_numpy=False)
+                out = v1 if int(pov_player) == 0 else v2
+                return out[0]
+        return _leaf_value_fn
 
 def _solve_subgame(root, r_us_vec, r_opp_vec, w_vec, depth_limit, bet_fractions, include_all_in, T, leaf_value_fn, config):
 	cfr = PublicChanceCFR(
