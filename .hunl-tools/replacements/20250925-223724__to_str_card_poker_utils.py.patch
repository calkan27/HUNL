--- a/poker_utils.py
+++ b/poker_utils.py
@@ -30,97 +30,92 @@
 
 
 def _to_str_card(c):
-		# Robustly normalize to canonical "RS" (e.g., "TH", "9D") without risking
-		# recursive __str__/upper() paths. Accepts "JH", ("J","H"), ["10","c"], or
-		# arbitrary objects with informative __str__.
-		RSET = set(RANKS)  # "23456789TJQKA"
-		SSET = set(SUITS)  # "CDHS"
-
-		def _upper_ascii(s):
-				out = []
-				i = 0
-				while i < len(s):
-						ch = s[i]
-						o = ch
-						oc = ord(ch)
-						if 97 <= oc <= 122:
-								o = chr(oc - 32)
-						out.append(o)
-						i += 1
-				return "".join(out)
-
-		def _strip_spaces(s):
-				buf = []
-				i = 0
-				while i < len(s):
-						ch = s[i]
-						if not ch.isspace():
-								buf.append(ch)
-						i += 1
-				return "".join(buf)
-
-		def _normalize_token(s):
-				return _upper_ascii(_strip_spaces(s))
-
-		def _pick_rank_suit(s):
-				# s is uppercase, no spaces
-				if len(s) >= 3 and s[0] == "1" and s[1] == "0" and (s[2] in SSET):
-						return "T", s[2]
-				if len(s) >= 2 and (s[0] in RSET) and (s[1] in SSET):
-						return s[0], s[1]
-				if len(s) >= 2 and (s[0] in SSET) and (s[1] in RSET):
-						return s[1], s[0]
-				r_pick = None
-				t_pick = None
-				i = 0
-				while i < len(s):
-						ch = s[i]
-						if r_pick is None:
-								if (ch == "1") and (i + 1 < len(s)) and (s[i + 1] == "0"):
-										r_pick = "T"
-										i += 1
-								elif ch in RSET:
-										r_pick = ch
-						if (t_pick is None) and (ch in SSET):
-								t_pick = ch
-						if (r_pick is not None) and (t_pick is not None):
-								break
-						i += 1
-				return r_pick, t_pick
-
-		# Case 1: direct string
-		if isinstance(c, str):
-				s = _normalize_token(c)
-				r, t = _pick_rank_suit(s)
-				return (r + t) if (r and t) else s[:2]
-
-		# Case 2: pair-like container
-		if isinstance(c, (list, tuple)):
-				a = c[0] if len(c) >= 1 else ""
-				b = c[1] if len(c) >= 2 else ""
-				as_ = _normalize_token(a if isinstance(a, str) else f"{a}")
-				bs_ = _normalize_token(b if isinstance(b, str) else f"{b}")
-
-				# try rank-from-first, suit-from-second
-				r1 = "T" if (as_.startswith("10")) else (as_[0] if as_ else None)
-				t1 = bs_[0] if bs_ else None
-				if (r1 in RSET) and (t1 in SSET):
-						return r1 + t1
-
-				# try swapped
-				r2 = "T" if (bs_.startswith("10")) else (bs_[0] if bs_ else None)
-				t2 = as_[0] if as_ else None
-				if (r2 in RSET) and (t2 in SSET):
-						return r2 + t2
-
-				flat = _normalize_token(as_ + bs_)
-				r, t = _pick_rank_suit(flat)
-				return (r + t) if (r and t) else flat[:2]
-
-		# Case 3: other types — stringify cautiously, then parse
-		s_flat = _normalize_token(f"{c}")
-		r, t = _pick_rank_suit(s_flat)
-		return (r + t) if (r and t) else s_flat[:2]
+        # Normalize any card-like input to canonical "RS" (rank+suit), e.g. "TH", "9D".
+        # No nested helpers. Avoids calling .upper()/.isspace() on user-overridden types.
+        # Only ASCII transforms are used to prevent recursion on monkey-patched methods.
+
+        # 1) Build a flat ASCII string s (no whitespace), then ASCII-uppercase.
+        if isinstance(c, str):
+                raw = c
+        elif isinstance(c, (list, tuple)):
+                parts = []
+                i = 0
+                while i < len(c):
+                        x = c[i]
+                        if isinstance(x, str):
+                                parts.append(x)
+                        else:
+                                parts.append(f"{x}")
+                        i += 1
+                raw = "".join(parts)
+        else:
+                raw = f"{c}"
+
+        # remove whitespace manually (ASCII only)
+        ws_ords = {9, 10, 11, 12, 13, 32}  # \t\n\v\f\r and space
+        buf = []
+        i = 0
+        while i < len(raw):
+                ch = raw[i]
+                oc = ord(ch) if isinstance(ch, str) and len(ch) == 1 else None
+                if (oc is not None) and (oc in ws_ords):
+                        pass
+                else:
+                        buf.append(ch)
+                i += 1
+        s_no_space = "".join(buf)
+
+        # ASCII uppercase without .upper()
+        out = []
+        i = 0
+        while i < len(s_no_space):
+                ch = s_no_space[i]
+                oc = ord(ch) if (isinstance(ch, str) and (len(ch) == 1)) else None
+                if (oc is not None) and (97 <= oc <= 122):  # a..z
+                        out.append(chr(oc - 32))
+                else:
+                        out.append(ch)
+                i += 1
+        s = "".join(out)
+
+        # 2) Fast paths: exact "RS" and "SR"
+        if len(s) >= 2:
+                r0 = s[0]
+                t0 = s[1]
+                if (r0 in RANKS) and (t0 in SUITS):
+                        return r0 + t0
+                if (r0 in SUITS) and (t0 in RANKS):
+                        return t0 + r0
+
+        # 3) Handle "10X" -> "TX"
+        if len(s) >= 3:
+                if (s[0] == "1") and (s[1] == "0") and (s[2] in SUITS):
+                        return "T" + s[2]
+
+        # 4) Scan anywhere: first rank ("10"→"T" or any single RANK) + first suit
+        r_pick = None
+        t_pick = None
+        i = 0
+        n = len(s)
+        while i < n:
+                ch = s[i]
+                if r_pick is None:
+                        if (ch == "1") and (i + 1 < n) and (s[i + 1] == "0"):
+                                r_pick = "T"
+                                i += 1  # skip the '0' in "10"
+                        elif ch in RANKS:
+                                r_pick = ch
+                if (t_pick is None) and (ch in SUITS):
+                        t_pick = ch
+                if (r_pick is not None) and (t_pick is not None):
+                        break
+                i += 1
+
+        if (r_pick is not None) and (t_pick is not None):
+                return r_pick + t_pick
+
+        # 5) Fallback: best-effort two-char token (already uppercased)
+        return s[:2]
 
 def _normalize_cards(card_iterable):
 		out = []
