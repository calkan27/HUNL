--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -405,72 +405,71 @@
 			}
 
 
-	def _calculate_counterfactual_values(self, node, player, depth=0, cache=None):
-		if cache is None:
-			cache = {}
-		node_key = (id(node), player, depth)
-		if node_key in cache:
-			return cache[node_key]
-		if self._is_terminal(node):
-			cf_values = {}
-			utility = self._calculate_terminal_utility(node, player)
-			for cluster_id in node.player_ranges[player]:
-				cf_values[cluster_id] = [utility] * len(ActionType)
-			cache[node_key] = cf_values
-			return cf_values
-		stage = self.get_stage(node)
-		if depth >= self.depth_limit and stage in ('preflop', 'flop', 'turn'):
-			preds = self.predict_counterfactual_values(node, player)
-			cache[node_key] = preds
-			return preds
-		counterfactual_values = defaultdict(lambda: [0.0] * len(ActionType))
-		current_player = node.current_player
-		opponent = (player + 1) % 2
-		allowed_actions = self._build_allowed_actions(node.public_state)
-		if current_player == player:
-			for cluster_id, cluster_prob in node.player_ranges[player].items():
-				if cluster_prob == 0.0:
+def _calculate_counterfactual_values(self, node, player, depth=0, cache=None):
+	if cache is None:
+		cache = {}
+	node_key = (id(node), player, depth)
+	if node_key in cache:
+		return cache[node_key]
+	if self._is_terminal(node):
+		cf_values = {}
+		utility = self._calculate_terminal_utility(node, player)
+		for cluster_id in node.player_ranges[player]:
+			cf_values[cluster_id] = [utility] * len(ActionType)
+		cache[node_key] = cf_values
+		return cf_values
+	stage = self.get_stage(node)
+	if depth >= self.depth_limit and stage in ('preflop', 'flop', 'turn'):
+		preds = self.predict_counterfactual_values(node, player)
+		cache[node_key] = preds
+		return preds
+	from collections import defaultdict
+	counterfactual_values = defaultdict(lambda: [0.0] * len(ActionType))
+	current_player = node.current_player
+	opponent = (player + 1) % 2
+	allowed_actions = self._build_allowed_actions(node.public_state)
+	if current_player == player:
+		for cluster_id, cluster_prob in node.player_ranges[player].items():
+			if cluster_prob == 0.0:
+				continue
+			values = self.cfr_values[node]
+			base_strategy = values.compute_strategy(cluster_id)
+			strategy = self._mask_strategy(base_strategy, allowed_actions)
+			for a_type in allowed_actions:
+				a_idx = a_type.value
+				if a_idx in values.pruned_actions[cluster_id]:
 					continue
-				values = self.cfr_values[node]
-				strategy = values.compute_strategy(cluster_id)
-				action_utilities = [0.0] * len(ActionType)
-				for a_type in allowed_actions:
-					a_idx = a_type.value
-					if a_idx in values.pruned_actions[cluster_id]:
-						continue
-					action = Action(a_type)
-					new_public_state = node.public_state.update_state(node, action)
-					child_node = GameNode(new_public_state)
-					child_node.player_ranges = copy.deepcopy(node.player_ranges)
-					self.update_player_range(child_node, player, cluster_id, a_idx)
-					utility = self._calculate_counterfactual_utility(child_node, player, depth + 1)
-					action_utilities[a_idx] = utility
-					counterfactual_values[cluster_id][a_idx] += strategy[a_idx] * utility
-		else:
-			for cluster_id, cluster_prob in node.player_ranges[opponent].items():
-				if cluster_prob == 0.0:
+				action = Action(a_type)
+				new_public_state = node.public_state.update_state(node, action)
+				child_node = GameNode(new_public_state)
+				child_node.player_ranges = copy.deepcopy(node.player_ranges)
+				self.update_player_range(child_node, player, cluster_id, a_idx)
+				utility = self._calculate_counterfactual_utility(child_node, player, depth + 1)
+				counterfactual_values[cluster_id][a_idx] += strategy[a_idx] * utility
+	else:
+		for cluster_id, cluster_prob in node.player_ranges[opponent].items():
+			if cluster_prob == 0.0:
+				continue
+			values = self.cfr_values[node]
+			base_strategy = values.compute_strategy(cluster_id)
+			strategy = self._mask_strategy(base_strategy, allowed_actions)
+			expected_action_value = 0.0
+			for a_type in allowed_actions:
+				a_idx = a_type.value
+				if a_idx in values.pruned_actions[cluster_id]:
 					continue
-				values = self.cfr_values[node]
-				strategy = values.compute_strategy(cluster_id)
-				expected_action_value = 0.0
-				for a_type in allowed_actions:
-					a_idx = a_type.value
-					if a_idx in values.pruned_actions[cluster_id]:
-						continue
-					action = Action(a_type)
-					new_public_state = node.public_state.update_state(node, action)
-					child_node = GameNode(new_public_state)
-					child_node.player_ranges = copy.deepcopy(node.player_ranges)
-					self.update_player_range(child_node, opponent, cluster_id, a_idx)
-					utility = self._calculate_counterfactual_utility(child_node, player, depth + 1)
-					expected_action_value += strategy[a_idx] * utility
-				for a_type in allowed_actions:
-					a_idx = a_type.value
-					counterfactual_values[cluster_id][a_idx] += expected_action_value
-		cache[node_key] = counterfactual_values
-		return counterfactual_values
-
-
+				action = Action(a_type)
+				new_public_state = node.public_state.update_state(node, action)
+				child_node = GameNode(new_public_state)
+				child_node.player_ranges = copy.deepcopy(node.player_ranges)
+				self.update_player_range(child_node, opponent, cluster_id, a_idx)
+				utility = self._calculate_counterfactual_utility(child_node, player, depth + 1)
+				expected_action_value += strategy[a_idx] * utility
+			for a_type in allowed_actions:
+				a_idx = a_type.value
+				counterfactual_values[cluster_id][a_idx] += expected_action_value
+	cache[node_key] = counterfactual_values
+	return counterfactual_values
 
 	def _calculate_counterfactual_utility(self, node, player, depth):
 		if self._is_terminal(node):
