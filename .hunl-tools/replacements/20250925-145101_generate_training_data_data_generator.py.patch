--- a/data_generator.py
+++ b/data_generator.py
@@ -89,141 +89,143 @@
 		self.torch_frozen_clusters_base = None
 		self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
 
-	def generate_training_data(self, stage='flop', progress=None) -> List[Dict[str, Any]]:
-		data = []
-		boards = self.generate_unique_boards(stage, self.num_boards)
-		leaf_snap = self._push_leaf_override(stage)
-
-		for board_index, public_cards in enumerate(boards):
-			deck_without_board = [c for c in DECK if c not in public_cards]
-			possible_hands = [' '.join(h) for h in itertools.combinations(deck_without_board, 2)]
-			hands_set = set(possible_hands)
-			opponent_range_over_hands = {h: 1.0 / len(hands_set) for h in hands_set} if hands_set else {}
-			nominal_pot = 1.0
-
-			if self.speed_profile == "test":
-				if self.torch_frozen_clusters_base is None:
-					self.torch_frozen_clusters_base = self.hand_clusterer.cluster_hands(
-						hands_set,
-						board=public_cards,
-						opponent_range=opponent_range_over_hands,
-						pot_size=nominal_pot
-					)
-				clusters = self._filter_clusters_for_board(self.torch_frozen_clusters_base, public_cards)
-				self.cfr_solver.clusters = clusters
-				self.clusters = clusters
-				max_opponent_iterations = 1
-				cfr_iterations_per_update = 1
-				force_fcp_only = False
-			else:
-				clusters = self.hand_clusterer.cluster_hands(
-					hands_set,
-					board=public_cards,
-					opponent_range=opponent_range_over_hands,
-					pot_size=nominal_pot
-				)
-				self.cfr_solver.clusters = clusters
-				self.clusters = clusters
-				max_opponent_iterations = 1
-				cfr_iterations_per_update = 1000
-				force_fcp_only = True
-
-			if callable(progress):
-				progress(1)
-
-			for sample_index in range(self.num_samples_per_board):
-				pot_size = self.sample_pot_size()
-
-				hand_probs_self = self._recursive_R(sorted(list(hands_set)), 1.0, public_cards)
-				hand_probs_opp = self._recursive_R(sorted(list(hands_set)), 1.0, public_cards)
-				r_self = self.map_hands_to_clusters(hand_probs_self, self.clusters)
-				r_opp = self.map_hands_to_clusters(hand_probs_opp, self.clusters)
-				self.normalize_cluster_probabilities([r_self, r_opp])
-
-				opponent_range = dict(r_opp)
-				previous_opponent_range = dict(opponent_range)
-
-				for _ in range(max_opponent_iterations):
-					public_state = PublicState(initial_stacks=[self.player_stack, self.player_stack], board_cards=public_cards)
-					public_state.pot_size = pot_size
-					target_round = self.get_round_from_stage(stage)
-					public_state.current_round = target_round
-
-					if target_round >= 1:
-						public_state.current_bets = [0, 0]
-						public_state.last_raiser = None
-						public_state.stacks = [self.player_stack, self.player_stack]
-						public_state.current_player = (public_state.dealer + 1) % 2
-
-						while len(public_state.board_cards) > (2 + target_round):
-							public_state.board_cards.pop()
-						while len(public_state.board_cards) < (2 + target_round):
-							for c in DECK:
-								if (c not in public_state.board_cards and c not in public_state.hole_cards[0] and c not in public_state.hole_cards[1]):
-									public_state.board_cards.append(c)
-									break
-
-					used = set(public_state.board_cards)
-					deck_remaining = [c for c in DECK if c not in used]
-					random.shuffle(deck_remaining)
-					public_state.hole_cards[0] = deck_remaining[:2]
-					public_state.hole_cards[1] = deck_remaining[2:4]
-					used2 = set(public_state.board_cards + public_state.hole_cards[0] + public_state.hole_cards[1])
-					public_state.deck = [c for c in DECK if c not in used2]
-					random.shuffle(public_state.deck)
-
-					game_node = GameNode(public_state)
-					game_node.player_ranges[0] = dict(r_self)
-					game_node.player_ranges[1] = dict(opponent_range)
-					game_node.players_in_hand = [True, True]
-
-					if force_fcp_only:
-						round_flags_backup = {int(k): {"half_pot": bool(v.get("half_pot", True)), "two_pot": bool(v.get("two_pot", False))} for k, v in getattr(self.cfr_solver, "_round_actions", {}).items()}
-						self.cfr_solver._ensure_sparse_schedule()
-						for r in (0, 1, 2, 3):
-							self.cfr_solver._round_actions[int(r)] = {"half_pot": False, "two_pot": False}
-
-					self.cfr_solver.total_iterations = int(cfr_iterations_per_update)
-					self.cfr_solver.run_cfr(game_node)
-
-					if force_fcp_only:
-						self.cfr_solver._round_actions = round_flags_backup
-
-					if callable(progress):
-						progress(1)
-
-				game_node.player_ranges[1] = dict(opponent_range)
-
-				player_ranges_bucketed = self.bucket_player_ranges([dict(r_self), dict(opponent_range)])
-
-				self._assert_sampler_invariants(
-					public_cards,
-					[{i: player_ranges_bucketed[0][i] for i in range(self.num_clusters)},
-					 {i: player_ranges_bucketed[1][i] for i in range(self.num_clusters)}],
-					pot_size
-				)
-
-				input_vector = self.prepare_input_vector(
-					player_ranges_bucketed,
-					public_cards,
-					pot_size,
-					game_node.public_state.actions
-				)
-
-				counterfactual_values = self.compute_counterfactual_values(game_node)
-				target_v1, target_v2 = self.prepare_target_values(counterfactual_values, pot_size)
-
-				data.append({
-					'input_vector': input_vector,
-					'target_v1': target_v1,
-					'target_v2': target_v2
-				})
-
-				if callable(progress):
-					progress(1)
-
-		self._pop_leaf_override(leaf_snap)
-		return data
+    def generate_training_data(self, stage='flop', progress=None) -> List[Dict[str, Any]]:
+        data = []
+        boards = self.generate_unique_boards(stage, self.num_boards)
+        leaf_snap = self._push_leaf_override(stage)
+
+        for board_index, public_cards in enumerate(boards):
+            deck_without_board = [c for c in DECK if c not in public_cards]
+            possible_hands = [' '.join(h) for h in itertools.combinations(deck_without_board, 2)]
+            hands_set = set(possible_hands)
+            opponent_range_over_hands = {h: 1.0 / len(hands_set) for h in hands_set} if hands_set else {}
+            nominal_pot = 1.0
+
+            if self.speed_profile == "test":
+                if self.torch_frozen_clusters_base is None:
+                    self.torch_frozen_clusters_base = self.hand_clusterer.cluster_hands(
+                        hands_set,
+                        board=public_cards,
+                        opponent_range=opponent_range_over_hands,
+                        pot_size=nominal_pot
+                    )
+                clusters = self._filter_clusters_for_board(self.torch_frozen_clusters_base, public_cards)
+                self.cfr_solver.clusters = clusters
+                self.clusters = clusters
+                max_opponent_iterations = 1
+                cfr_iterations_per_update = 1
+                force_fcp_only = False
+            else:
+                clusters = self.hand_clusterer.cluster_hands(
+                    hands_set,
+                    board=public_cards,
+                    opponent_range=opponent_range_over_hands,
+                    pot_size=nominal_pot
+                )
+                self.cfr_solver.clusters = clusters
+                self.clusters = clusters
+                max_opponent_iterations = 1
+                cfr_iterations_per_update = 1000
+                force_fcp_only = True
+
+            if callable(progress):
+                progress(1)
+
+            for sample_index in range(self.num_samples_per_board):
+                pot_size = self.sample_pot_size()
+
+                hand_probs_self = self._recursive_R(sorted(list(hands_set)), 1.0, public_cards)
+                hand_probs_opp = self._recursive_R(sorted(list(hands_set)), 1.0, public_cards)
+                r_self = self.map_hands_to_clusters(hand_probs_self, self.clusters)
+                r_opp = self.map_hands_to_clusters(hand_probs_opp, self.clusters)
+                self.normalize_cluster_probabilities([r_self, r_opp])
+
+                opponent_range = dict(r_opp)
+                previous_opponent_range = dict(opponent_range)
+
+                for _ in range(max_opponent_iterations):
+                    public_state = PublicState(initial_stacks=[self.player_stack, self.player_stack], board_cards=public_cards)
+                    public_state.pot_size = pot_size
+                    target_round = self.get_round_from_stage(stage)
+                    public_state.current_round = target_round
+
+                    if target_round >= 1:
+                        public_state.current_bets = [0, 0]
+                        public_state.last_raiser = None
+                        public_state.stacks = [self.player_stack, self.player_stack]
+                        public_state.current_player = (public_state.dealer + 1) % 2
+
+                        while len(public_state.board_cards) > (2 + target_round):
+                            public_state.board_cards.pop()
+                        while len(public_state.board_cards) < (2 + target_round):
+                            for c in DECK:
+                                if (c not in public_state.board_cards and c not in public_state.hole_cards[0] and c not in public_state.hole_cards[1]):
+                                    public_state.board_cards.append(c)
+                                    break
+
+                    used = set(public_state.board_cards)
+                    deck_remaining = [c for c in DECK if c not in used]
+                    random.shuffle(deck_remaining)
+                    public_state.hole_cards[0] = deck_remaining[:2]
+                    public_state.hole_cards[1] = deck_remaining[2:4]
+                    used2 = set(public_state.board_cards + public_state.hole_cards[0] + public_state.hole_cards[1])
+                    public_state.deck = [c for c in DECK if c not in used2]
+                    random.shuffle(public_state.deck)
+
+                    game_node = GameNode(public_state)
+                    game_node.player_ranges[0] = dict(r_self)
+                    game_node.player_ranges[1] = dict(opponent_range)
+                    game_node.players_in_hand = [True, True]
+
+                    if force_fcp_only:
+                        round_flags_backup = {int(k): {"half_pot": bool(v.get("half_pot", True)), "two_pot": bool(v.get("two_pot", False))} for k, v in getattr(self.cfr_solver, "_round_actions", {}).items()}
+                        self.cfr_solver._ensure_sparse_schedule()
+                        for r in (0, 1, 2, 3):
+                            self.cfr_solver._round_actions[int(r)] = {"half_pot": False, "two_pot": False}
+
+                    self.cfr_solver.total_iterations = int(cfr_iterations_per_update)
+                    self.cfr_solver.run_cfr(game_node)
+
+                    if force_fcp_only:
+                        self.cfr_solver._round_actions = round_flags_backup
+
+                    if callable(progress):
+                        progress(1)
+
+                game_node.player_ranges[1] = dict(opponent_range)
+
+                player_ranges_bucketed = self.bucket_player_ranges([dict(r_self), dict(opponent_range)])
+
+                self._assert_sampler_invariants(
+                    public_cards,
+                    [{i: player_ranges_bucketed[0][i] for i in range(self.num_clusters)},
+                     {i: player_ranges_bucketed[1][i] for i in range(self.num_clusters)}],
+                    pot_size
+                )
+
+                input_vector = self.prepare_input_vector(
+                    player_ranges_bucketed,
+                    public_cards,
+                    pot_size,
+                    game_node.public_state.actions
+                )
+
+                counterfactual_values = self.compute_counterfactual_values(game_node)
+                target_v1, target_v2 = self.prepare_target_values(counterfactual_values, pot_size)
+
+                data.append({
+                    'input_vector': input_vector,
+                    'target_v1': target_v1,
+                    'target_v2': target_v2
+                })
+
+                if callable(progress):
+                    progress(1)
+
+        data.sort(key=lambda rec: tuple(round(x, 12) for x in rec['input_vector']))
+
+        self._pop_leaf_override(leaf_snap)
+        return data
 
 	def compute_counterfactual_values(self, node: GameNode) -> Dict[int, Dict[int, List[float]]]:
 		cf0 = self.cfr_solver.predict_counterfactual_values(node, player=0)
