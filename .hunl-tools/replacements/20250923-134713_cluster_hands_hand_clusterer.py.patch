--- a/hand_clusterer.py
+++ b/hand_clusterer.py
@@ -97,181 +97,151 @@
 				self.opp_sample_size = int(opp_sample_size) if opp_sample_size is not None else None
 				self.use_cfv_in_features = bool(use_cfv_in_features)
 
-	def cluster_hands(
-		self,
-		hands: Any,
-		board: List[str],
-		opponent_range: Dict[Any, float],
-		pot_size: float,
-	) -> Dict[int, Set[str]]:
-
-		if self.profile == "test":
-			ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
-			assert ok
-			if self._fast_test_frozen_clusters is not None:
-				return self._fast_test_frozen_clusters
-			if isinstance(hands, (set, dict)):
-				hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
-			else:
-				hands_list = list(hands)
-				hands_list.sort()
-			K = int(self.num_clusters)
-			N = len(hands_list)
-			clusters = {i: set() for i in range(K)}
-			if N == 0:
-				self._fast_test_frozen_clusters = clusters
-				self.clusters = clusters
-				self.centroids = None
-				self._fast_test_initialized = True
-				return clusters
-			rng = random.Random(self._fast_test_seed)
-			if N < K:
-				perm = list(range(K))
-				rng.shuffle(perm)
-				for idx, hand in enumerate(hands_list):
-					clusters[perm[idx]] = {hand}
-			else:
-				for hand in hands_list:
-					key = hand if isinstance(hand, str) else " ".join(list(hand))
-					h = hashlib.sha256(key.encode("utf-8")).hexdigest()
-					cls = int(h, 16) % K
-					clusters[cls].add(hand)
-			for k in range(K):
-				if k not in clusters:
-					clusters[k] = set()
-			empties = [k for k, v in clusters.items() if len(v) == 0]
-			if empties:
-				donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-				for e in empties:
-					if not donors:
-						break
-					dk, _ = donors[0]
-					move = sorted(clusters[dk])[0]
-					clusters[dk].remove(move)
-					clusters[e].add(move)
-					donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-			self._fast_test_frozen_clusters = clusters
-			self.clusters = clusters
-			self.centroids = None
-			self._last_features = None
-			self._fast_test_initialized = True
-			return clusters
-
-		start_time = time.time()
-		hits_before = self._cache_hits
-		misses_before = self._cache_misses
-
-		hand_features: Dict[str, np.ndarray] = {}
-		if isinstance(hands, dict):
-			iterable = hands.keys()
-		else:
-			iterable = hands
-		for h in iterable:
-			features = self.calculate_hand_features(h, board, opponent_range, pot_size)
-			hand_features[h] = np.asarray(features, dtype=float)
-
-		N = len(hand_features)
-		if N == 0:
-			self.clusters = {}
-			self.centroids = None
-			self._last_features = {}
-			return {}
-
-		if N < self.num_clusters:
-			self.num_clusters = N
-
-		rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, {}, 0.0))
-		all_keys = list(hand_features.keys())
-		idx_all = np.arange(N)
-		rs.shuffle(idx_all)
-		K = int(self.num_clusters)
-		medoid_idx = list(idx_all[:K])
-		key_list = all_keys
-		assign = [-1] * N
-
-		def _dist(i, j):
-			return float(self._emd_distance(hand_features[key_list[i]], hand_features[key_list[j]]))
-
-		def _assign_all(medoids):
-			changed = False
-			i = 0
-			while i < N:
-				best = None
-				best_d = None
-				for m in medoids:
-					d = _dist(i, m)
-					if best_d is None or d < best_d:
-						best_d = d
-						best = m
-				if assign[i] != best:
-					assign[i] = best
-					changed = True
-				i += 1
-			return changed
-
-		def _update_medoids(medoids):
-			updated = False
-			for k in range(len(medoids)):
-				cluster_members = [i for i in range(N) if assign[i] == medoids[k]]
-				if not cluster_members:
-					continue
-				best_i = medoids[k]
-				best_sum = None
-				for cand in cluster_members:
-					s = 0.0
-					for j in cluster_members:
-						if j == cand:
-							continue
-						s += _dist(cand, j)
-					if best_sum is None or s < best_sum:
-						best_sum = s
-						best_i = cand
-				if best_i != medoids[k]:
-					medoids[k] = best_i
-					updated = True
-			return updated
-
-		_assign_all(medoid_idx)
-		it = 0
-		while it < int(self.max_iterations):
-			it += 1
-			if not _update_medoids(medoid_idx):
-				break
-			if not _assign_all(medoid_idx):
-				break
-
-		clusters_raw: Dict[int, Set[str]] = defaultdict(set)
-		for i in range(N):
-			m = assign[i]
-			if m < 0:
-				continue
-			key = key_list[i]
-			clusters_raw[int(m)].add(key)
-
-		if len(clusters_raw) < K:
-			left = [i for i in range(N) if assign[i] < 0]
-			i2 = 0
-			for mid in medoid_idx:
-				if mid not in clusters_raw:
-					clusters_raw[int(mid)] = set()
-				while i2 < len(left) and len(clusters_raw[int(mid)]) == 0:
-					clusters_raw[int(mid)].add(key_list[left[i2]])
-					i2 += 1
-
-		id_map = {old: new for new, old in enumerate(sorted(clusters_raw.keys()))}
-		clusters = {int(id_map[k]): set(v) for k, v in clusters_raw.items()}
-		for i in range(K):
-			if i not in clusters:
-				clusters[i] = set()
-
-		self.clusters = clusters
-		self.centroids = None
-		self._last_features = hand_features
-
-		total_time2 = time.time() - start_time
-		print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
-		print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-		return clusters
+    def cluster_hands(
+        self,
+        hands: Any,
+        board: List[str],
+        opponent_range: Dict[Any, float],
+        pot_size: float,
+    ) -> Dict[int, Set[str]]:
+
+        if self.profile == "test":
+            ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
+            assert ok
+            if self._fast_test_frozen_clusters is not None:
+                return self._fast_test_frozen_clusters
+            if isinstance(hands, (set, dict)):
+                hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
+            else:
+                hands_list = list(hands)
+                hands_list.sort()
+            K = int(self.num_clusters)
+            N = len(hands_list)
+            clusters = {i: set() for i in range(K)}
+            if N == 0:
+                self._fast_test_frozen_clusters = clusters
+                self.clusters = clusters
+                self.centroids = None
+                self._fast_test_initialized = True
+                return clusters
+            rng = random.Random(self._fast_test_seed)
+            if N < K:
+                perm = list(range(K))
+                rng.shuffle(perm)
+                for idx, hand in enumerate(hands_list):
+                    clusters[perm[idx]] = {hand}
+            else:
+                for hand in hands_list:
+                    key = hand if isinstance(hand, str) else " ".join(list(hand))
+                    h = hashlib.sha256(key.encode("utf-8")).hexdigest()
+                    cls = int(h, 16) % K
+                    clusters[cls].add(hand)
+            for k in range(K):
+                if k not in clusters:
+                    clusters[k] = set()
+            empties = [k for k, v in clusters.items() if len(v) == 0]
+            if empties:
+                donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+                for e in empties:
+                    if not donors:
+                        break
+                    dk, _ = donors[0]
+                    move = sorted(clusters[dk])[0]
+                    clusters[dk].remove(move)
+                    clusters[e].add(move)
+                    donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
+            self._fast_test_frozen_clusters = clusters
+            self.clusters = clusters
+            self.centroids = None
+            self._last_features = None
+            self._fast_test_initialized = True
+            return clusters
+
+        start_time = time.time()
+        hits_before = self._cache_hits
+        misses_before = self._cache_misses
+
+        feats: Dict[str, np.ndarray] = {}
+        if isinstance(hands, dict):
+            iterable = hands.keys()
+        else:
+            iterable = hands
+        for h in iterable:
+            f = self.calculate_hand_features(h, board, opponent_range, pot_size)
+            feats[h] = np.asarray(f, dtype=float)
+
+        N = len(feats)
+        if N == 0:
+            self.clusters = {}
+            self.centroids = None
+            self._last_features = {}
+            return {}
+
+        K = int(self.num_clusters)
+        if N < K:
+            K = N
+            self.num_clusters = K
+
+        keys = list(feats.keys())
+        X = np.stack([feats[k] for k in keys], axis=0)
+
+        rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
+        cent_idx = []
+        i0 = rs.randint(0, N)
+        cent_idx.append(int(i0))
+        D = np.full((N,), np.inf, dtype=float)
+        while len(cent_idx) < K:
+            c = X[cent_idx[-1]]
+            diff = X - c
+            d2 = np.sum(diff * diff, axis=1)
+            D = np.minimum(D, d2)
+            probs = D / (np.sum(D) if np.sum(D) > 0.0 else 1.0)
+            r = rs.rand()
+            acc = 0.0
+            pick = 0
+            for i in range(N):
+                acc += probs[i]
+                if r <= acc:
+                    pick = i
+                    break
+            if pick in cent_idx:
+                pick = int(rs.randint(0, N))
+            cent_idx.append(int(pick))
+        C = X[cent_idx, :].copy()
+
+        assign = np.full((N,), -1, dtype=int)
+        it = 0
+        max_it = int(self.max_iterations)
+        while it < max_it:
+            it += 1
+            diff = X[:, None, :] - C[None, :, :]
+            dist2 = np.sum(diff * diff, axis=2)
+            new_assign = np.argmin(dist2, axis=1).astype(int)
+            if np.array_equal(assign, new_assign):
+                break
+            assign = new_assign
+            for k in range(K):
+                idx = np.where(assign == k)[0]
+                if idx.size > 0:
+                    C[k, :] = np.mean(X[idx, :], axis=0)
+
+        clusters_raw: Dict[int, Set[str]] = {i: set() for i in range(K)}
+        for i in range(N):
+            k = int(assign[i]) if assign[i] >= 0 else int(np.argmin(np.sum((X[i:i+1] - C) ** 2, axis=1)))
+            clusters_raw[k].add(keys[i])
+
+        for k in range(K):
+            if k not in clusters_raw:
+                clusters_raw[k] = set()
+
+        self.clusters = {int(k): set(v) for k, v in clusters_raw.items()}
+        self.centroids = C.copy()
+        self._last_features = feats
+
+        total_time2 = time.time() - start_time
+        print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
+        print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
+        return self.clusters
 
 	def fit(
 		self,
