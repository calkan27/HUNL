--- a/river_endgame.py
+++ b/river_endgame.py
@@ -125,43 +125,43 @@
 			out.append(h if isinstance(h, str) else f"{a} {b}")
 		return out
 
-	def _ev_no_bucket(self, clusters, board_set, my_range, opp_range, wins_fn, resolved_pot):
-		ev_p_by_cluster = {}
-		ev_o_by_cluster = {}
-		for cid in my_range.keys():
-			my_hands_full = self._filtered_hands_for_cluster(clusters, cid, board_set)
-			my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
-			if not my_hands:
-				ev_p_by_cluster[int(cid)] = 0.0
-				continue
-			ev_total_p = 0.0
-			my_w = 1.0 / float(len(my_hands))
-			for my_h in my_hands:
-				c1, c2 = my_h.split()
-				my_cards = [c1, c2]
-				for oid, oprob in opp_range.items():
-					if float(oprob) <= 0.0:
-						continue
-					opp_hands_full = self._filtered_hands_for_cluster(clusters, oid, board_set)
-					opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
-					if not opp_hands:
-						continue
-					opp_w = (oprob / float(len(opp_hands))) if len(opp_hands) > 0 else 0.0
-					for o_h in opp_hands:
-						d1, d2 = o_h.split()
-						opp_cards = [d1, d2]
-						res = wins_fn(my_cards, opp_cards, list(board_set))
-						up = self._pairwise_util_p(res, resolved_pot)
-						uo = -up
-						ev_total_p += my_w * opp_w * up
-						if int(oid) not in ev_o_by_cluster:
-							ev_o_by_cluster[int(oid)] = 0.0
-						ev_o_by_cluster[int(oid)] += my_w * opp_w * uo
-			ev_p_by_cluster[int(cid)] = ev_total_p
-		for k in list(opp_range.keys()):
-			if int(k) not in ev_o_by_cluster:
-				ev_o_by_cluster[int(k)] = 0.0
-		return ev_p_by_cluster, ev_o_by_cluster
+    def _ev_no_bucket(self, clusters, board_list_lower, board_set_upper, my_range, opp_range, wins_fn, resolved_pot):
+        ev_p_by_cluster = {}
+        ev_o_by_cluster = {}
+        for cid in my_range.keys():
+            my_hands_full = self._filtered_hands_for_cluster(clusters, cid, board_set_upper)
+            my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
+            if not my_hands:
+                ev_p_by_cluster[int(cid)] = 0.0
+                continue
+            ev_total_p = 0.0
+            my_w = 1.0 / float(len(my_hands))
+            for my_h in my_hands:
+                c1, c2 = my_h.split()
+                my_cards = [str(c1).lower(), str(c2).lower()]
+                for oid, oprob in opp_range.items():
+                    if float(oprob) <= 0.0:
+                        continue
+                    opp_hands_full = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
+                    opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
+                    if not opp_hands:
+                        continue
+                    opp_w = (float(oprob) / float(len(opp_hands))) if len(opp_hands) > 0 else 0.0
+                    for o_h in opp_hands:
+                        d1, d2 = o_h.split()
+                        opp_cards = [str(d1).lower(), str(d2).lower()]
+                        res = wins_fn(my_cards, opp_cards, list(board_list_lower))
+                        up = self._pairwise_util_p(res, resolved_pot=resolved_pot)
+                        uo = -up
+                        ev_total_p += my_w * opp_w * up
+                        if int(oid) not in ev_o_by_cluster:
+                            ev_o_by_cluster[int(oid)] = 0.0
+                        ev_o_by_cluster[int(oid)] += my_w * opp_w * uo
+            ev_p_by_cluster[int(cid)] = ev_total_p
+        for k in list(opp_range.keys()):
+            if int(k) not in ev_o_by_cluster:
+                ev_o_by_cluster[int(k)] = 0.0
+        return ev_p_by_cluster, ev_o_by_cluster
 
 	def _bucket_mixes(self, clusters, ids, board, board_set, best_hand_fn, hand_rank_fn):
 		all_strengths = []
