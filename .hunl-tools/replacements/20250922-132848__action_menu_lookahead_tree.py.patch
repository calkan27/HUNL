--- a/lookahead_tree.py
+++ b/lookahead_tree.py
@@ -17,27 +17,33 @@
 	def set_leaf_callback(self, fn: Callable[[PublicState, int, List[float], List[float]], np.ndarray]) -> None:
 		self.leaf_callback = fn
 
-	def _action_menu(self, ps: PublicState, for_player: bool, pot_fracs: Tuple[float, ...]) -> List[ActionType]:
-		legal = ps.legal_actions() if hasattr(ps, "legal_actions") else []
-		out: List[ActionType] = []
-		if ActionType.FOLD in legal:
-			out.append(ActionType.FOLD)
-		if ActionType.CALL in legal:
-			out.append(ActionType.CALL)
-		want_half = any(abs(f - 0.5) < 1e-9 for f in pot_fracs)
-		want_pot = any(abs(f - 1.0) < 1e-9 for f in pot_fracs)
-		want_2pot = any(abs(f - 2.0) < 1e-9 for f in pot_fracs)
-		if want_half and ActionType.HALF_POT_BET in legal:
-			out.append(ActionType.HALF_POT_BET)
-		if want_pot and ActionType.POT_SIZED_BET in legal:
-			out.append(ActionType.POT_SIZED_BET)
-		if want_2pot and ActionType.TWO_POT_BET in legal:
-			out.append(ActionType.TWO_POT_BET)
-		if self.include_all_in and ActionType.ALL_IN in legal:
-			out.append(ActionType.ALL_IN)
-		if self.max_actions_per_branch is not None and len(out) > self.max_actions_per_branch:
-			out = out[: self.max_actions_per_branch]
-		return out
+    def _action_menu(self, ps: PublicState, for_player: bool, pot_fracs: Tuple[float, ...], is_root: bool) -> List[ActionType]:
+        legal = ps.legal_actions() if hasattr(ps, "legal_actions") else []
+        out: List[ActionType] = []
+        if ActionType.FOLD in legal:
+            out.append(ActionType.FOLD)
+        if ActionType.CALL in legal:
+            out.append(ActionType.CALL)
+        if is_root:
+            want_half = any(abs(f - 0.5) < 1e-9 for f in pot_fracs)
+            want_pot = any(abs(f - 1.0) < 1e-9 for f in pot_fracs)
+            want_2pot = any(abs(f - 2.0) < 1e-9 for f in pot_fracs)
+            if want_half and ActionType.HALF_POT_BET in legal:
+                out.append(ActionType.HALF_POT_BET)
+            if want_pot and ActionType.POT_SIZED_BET in legal:
+                out.append(ActionType.POT_SIZED_BET)
+            if want_2pot and ActionType.TWO_POT_BET in legal:
+                out.append(ActionType.TWO_POT_BET)
+            if self.include_all_in and ActionType.ALL_IN in legal:
+                out.append(ActionType.ALL_IN)
+        else:
+            if ActionType.POT_SIZED_BET in legal:
+                out.append(ActionType.POT_SIZED_BET)
+            if self.include_all_in and ActionType.ALL_IN in legal:
+                out.append(ActionType.ALL_IN)
+        if self.max_actions_per_branch is not None and len(out) > self.max_actions_per_branch:
+            out = out[: self.max_actions_per_branch]
+        return out
 
 	def _deal_next_card(self, ps: PublicState) -> List[str]:
 		board = list(ps.board_cards or [])
