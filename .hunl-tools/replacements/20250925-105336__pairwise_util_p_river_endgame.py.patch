--- a/river_endgame.py
+++ b/river_endgame.py
@@ -53,272 +53,63 @@
 		return strengths
 
     def _pairwise_util_p(self, res, pot_size=None, my_bet=None, opp_bet=None, resolved_pot=None):
-        if my_bet is not None or opp_bet is not None:
-            mb = float(my_bet or 0.0)
-            ob = float(opp_bet or 0.0)
+            if my_bet is not None or opp_bet is not None:
+                    mb = float(my_bet or 0.0)
+                    ob = float(opp_bet or 0.0)
+                    if res > 0:
+                            return ob
+                    elif res < 0:
+                            return -mb
+                    else:
+                            return 0.5 * (ob - mb)
+            P = float(resolved_pot) if resolved_pot is not None else (float(pot_size) if pot_size is not None else 1.0)
             if res > 0:
-                return ob
+                    return P
             elif res < 0:
-                return -mb
+                    return -P
             else:
-                return 0.5 * (ob - mb)
-        P = float(resolved_pot) if resolved_pot is not None else (float(pot_size) if pot_size is not None else 1.0)
-        if res > 0:
-            return P
-        elif res < 0:
-            return -P
-        else:
-            return 0.0
+                    return 0.0
 
-	def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
-		p = list(my_bucket_probs)
-		q = list(opp_bucket_probs)
+    def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
+            p = list(my_bucket_probs)
+            q = list(opp_bucket_probs)
+            def _norm(v):
+                    s = sum(v) or 0.0
+                    if s > 0.0:
+                            return [float(x) / s for x in v]
+                    return [0.0] * len(v)
+            p = _norm(p)
+            q = _norm(q)
+            B = int(B)
+            if my_bet is not None or opp_bet is not None:
+                    mb = float(my_bet or 0.0)
+                    ob = float(opp_bet or 0.0)
+                    def pay(i, j):
+                            if i > j:
+                                    return ob
+                            elif i < j:
+                                    return -mb
+                            else:
+                                    return 0.5 * (ob - mb)
+            else:
+                    P = float(resolved_pot if resolved_pot is not None else 1.0)
+                    def pay(i, j):
+                            if i > j:
+                                    return P
+                            elif i < j:
+                                    return -P
+                            else:
+                                    return 0.0
+            ev_p = 0.0
+            for i in range(B):
+                    if p[i] == 0.0:
+                            continue
+                    row = 0.0
+                    for j in range(B):
+                            if q[j] == 0.0:
+                                    continue
+                            row += q[j] * pay(i, j)
+                    ev_p += p[i] * row
+            ev_o = -ev_p
+            return ev_p, ev_o
 
-		def _norm(v):
-			s = sum(v) or 0.0
-			if s > 0.0:
-				return [float(x) / s for x in v]
-			return [0.0] * len(v)
-
-		p = _norm(p)
-		q = _norm(q)
-		B = int(B)
-
-		if my_bet is not None or opp_bet is not None:
-			mb = float(my_bet or 0.0)
-			ob = float(opp_bet or 0.0)
-			def pay(i, j):
-				if i > j:
-					return ob
-				elif i < j:
-					return -mb
-				else:
-					return 0.5 * (ob - mb)
-		else:
-			P = float(resolved_pot if resolved_pot is not None else 1.0)
-			def pay(i, j):
-				if i > j:
-					return P
-				elif i < j:
-					return -P
-				else:
-					return 0.5 * P
-
-		ev_p = 0.0
-		for i in range(B):
-			if p[i] == 0.0:
-				continue
-			row = 0.0
-			for j in range(B):
-				if q[j] == 0.0:
-					continue
-				row += q[j] * pay(i, j)
-			ev_p += p[i] * row
-
-		ev_o = -ev_p
-		return ev_p, ev_o
-
-	def _normalize_range(self, r):
-		out = {int(k): float(v) for k, v in dict(r).items()}
-		s = sum(out.values())
-		if s > 0.0:
-			for k in list(out.keys()):
-				out[k] = out[k] / s
-		else:
-			for k in list(out.keys()):
-				out[k] = 0.0
-		return out
-
-	def _expected_utility_pairwise(self, my_hand, opp_hand, board, wins_fn, pot_size=None, my_bet=None, opp_bet=None, resolved_pot=None):
-		res = wins_fn(my_hand, opp_hand, board)
-		up = self._pairwise_util_p(res, pot_size=pot_size, my_bet=my_bet, opp_bet=opp_bet, resolved_pot=resolved_pot)
-		uo = -up
-		return up, uo
-
-	def _filtered_hands_for_cluster(self, clusters, cid, board_set_upper):
-		hset = clusters.get(int(cid), [])
-		out = []
-		for h in hset:
-			if isinstance(h, str):
-				a, b = h.split()
-			else:
-				a, b = list(h)
-			if a == b:
-				continue
-			if (str(a).upper() in board_set_upper) or (str(b).upper() in board_set_upper):
-				continue
-			out.append(h if isinstance(h, str) else f"{a} {b}")
-		return out
-
-	def _ev_no_bucket(self, clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot):
-		ev_p_by_cluster = {}
-		ev_o_by_cluster = {}
-		for cid in my_range.keys():
-			my_hands = self._filtered_hands_for_cluster(clusters, cid, board_set_upper)
-			if not my_hands:
-				ev_p_by_cluster[int(cid)] = 0.0
-				continue
-			ev_total_p = 0.0
-			my_w = 1.0 / float(len(my_hands))
-			for my_h in my_hands:
-				c1, c2 = my_h.split()
-				my_cards = [str(c1)[0].upper() + str(c1)[1].lower(), str(c2)[0].upper() + str(c2)[1].lower()]
-				for oid, oprob in opp_range.items():
-					if float(oprob) <= 0.0:
-						continue
-					opp_hands = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
-					if not opp_hands:
-						continue
-					opp_w = (float(oprob) / float(len(opp_hands))) if len(opp_hands) > 0 else 0.0
-					for o_h in opp_hands:
-						d1, d2 = o_h.split()
-						opp_cards = [str(d1)[0].upper() + str(d1)[1].lower(), str(d2)[0].upper() + str(d2)[1].lower()]
-						res = wins_fn(my_cards, opp_cards, list(board_list_norm))
-						up = self._pairwise_util_p(res, resolved_pot=resolved_pot)
-						uo = -up
-						ev_total_p += my_w * opp_w * up
-						if int(oid) not in ev_o_by_cluster:
-							ev_o_by_cluster[int(oid)] = 0.0
-						ev_o_by_cluster[int(oid)] += my_w * opp_w * uo
-			ev_p_by_cluster[int(cid)] = ev_total_p
-		for k in list(opp_range.keys()):
-			if int(k) not in ev_o_by_cluster:
-				ev_o_by_cluster[int(k)] = 0.0
-		return ev_p_by_cluster, ev_o_by_cluster
-
-	def _bucket_mixes(self, clusters, ids, board_list_norm, board_set_upper, best_hand_fn, hand_rank_fn):
-		all_strengths = []
-		for cid in ids:
-			hf = self._filtered_hands_for_cluster(clusters, cid, board_set_upper)
-			if hf:
-				all_strengths.extend(self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn))
-		bmap, B = self._bucketize(all_strengths)
-		return bmap, B
-
-	def _ev_bucket(self, clusters, board_list_norm, board_set_upper, my_range, opp_range, best_hand_fn, hand_rank_fn, resolved_pot):
-		bmap, B = self._bucket_mixes(
-			clusters,
-			list(my_range.keys()) + list(opp_range.keys()),
-			list(board_list_norm),
-			board_set_upper,
-			best_hand_fn,
-			hand_rank_fn,
-		)
-		if bmap is None:
-			return None, None
-
-		opp_bucket_mix = [0.0] * B
-		total_opp_weight = 0.0
-		for oid, oprob in opp_range.items():
-			if float(oprob) <= 0.0:
-				continue
-			hf = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
-			if not hf:
-				continue
-			local = [0.0] * B
-			for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
-				local[bmap[s]] += 1.0
-			tm = sum(local)
-			if tm > 0.0:
-				for i in range(B):
-					local[i] = local[i] / tm
-			for i in range(B):
-				opp_bucket_mix[i] += float(oprob) * local[i]
-			total_opp_weight += float(oprob)
-		if total_opp_weight > 0.0:
-			for i in range(B):
-				opp_bucket_mix[i] = opp_bucket_mix[i] / total_opp_weight
-
-		my_bucket_mix_global = [0.0] * B
-		total_my_weight = 0.0
-		for cid, cprob in my_range.items():
-			if float(cprob) <= 0.0:
-				continue
-			hf = self._filtered_hands_for_cluster(clusters, cid, board_set_upper)
-			if not hf:
-				continue
-			local = [0.0] * B
-			for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
-				local[bmap[s]] += 1.0
-			tm = sum(local)
-			if tm > 0.0:
-				for i in range(B):
-					local[i] = local[i] / tm
-			for i in range(B):
-				my_bucket_mix_global[i] += float(cprob) * local[i]
-			total_my_weight += float(cprob)
-		if total_my_weight > 0.0:
-			for i in range(B):
-				my_bucket_mix_global[i] = my_bucket_mix_global[i] / total_my_weight
-
-		ev_p, ev_o_global = self._expected_utility_buckets_both(
-			my_bucket_probs=my_bucket_mix_global,
-			opp_bucket_probs=opp_bucket_mix,
-			B=B,
-			resolved_pot=resolved_pot,
-		)
-
-		ev_p_by_cluster = {int(cid): float(ev_p) for cid in my_range.keys()}
-
-		ev_o_by_cluster = {}
-		for oid in opp_range.keys():
-			hf = self._filtered_hands_for_cluster(clusters, oid, board_set_upper)
-			if not hf:
-				ev_o_by_cluster[int(oid)] = 0.0
-				continue
-			local_opp = [0.0] * B
-			for s in self._cluster_distribution(hf, list(board_list_norm), best_hand_fn, hand_rank_fn):
-				local_opp[bmap[s]] += 1.0
-			tm = sum(local_opp)
-			if tm > 0.0:
-				for i in range(B):
-					local_opp[i] = local_opp[i] / tm
-			_, ev_o_local = self._expected_utility_buckets_both(
-				my_bucket_probs=local_opp,
-				opp_bucket_probs=opp_bucket_mix,
-				B=B,
-				resolved_pot=resolved_pot,
-			)
-			ev_o_by_cluster[int(oid)] = float(ev_o_local)
-
-		return ev_p_by_cluster, ev_o_by_cluster
-
-	def compute_cluster_cfvs(self, clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn):
-		board = list(node.public_state.board_cards)
-		board_list_norm = [str(c)[0].upper() + str(c)[1].lower() for c in board]
-		board_set_upper = set(str(c).upper() for c in board)
-		resolved_pot = self._resolved_pot(node)
-		my = int(player)
-		opp = (my + 1) % 2
-		my_range = self._normalize_range(node.player_ranges[my])
-		opp_range = self._normalize_range(node.player_ranges[opp])
-		if not hasattr(self, "_river_cache"):
-			self._river_cache = {}
-		sig = self._node_signature(node, my_range, opp_range)
-		if sig in self._river_cache and isinstance(self._river_cache[sig], dict) and my in self._river_cache[sig]:
-			return dict(self._river_cache[sig][my])
-		if self.num_buckets is None or self.num_buckets <= 0:
-			ev_p_by_cluster, ev_o_by_cluster = self._ev_no_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot)
-		else:
-			ev_p_by_cluster, ev_o_by_cluster = self._ev_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, best_hand_fn, hand_rank_fn, resolved_pot)
-			if ev_p_by_cluster is None:
-				ev_p_by_cluster, ev_o_by_cluster = self._ev_no_bucket(clusters, board_list_norm, board_set_upper, my_range, opp_range, wins_fn, resolved_pot)
-		scale = (1.0 / float(resolved_pot)) if resolved_pot > 0.0 else 1.0
-		my_vals_scalar = {int(cid): float(ev_p_by_cluster.get(int(cid), 0.0) * scale) for cid in my_range.keys()}
-		opp_vals_scalar = {int(oid): float(ev_o_by_cluster.get(int(oid), 0.0) * scale) for oid in opp_range.keys()}
-		my_vals = {int(k): [float(v)] * 4 for k, v in my_vals_scalar.items()}
-		opp_vals = {int(k): [float(v)] * 4 for k, v in opp_vals_scalar.items()}
-		self._river_cache[sig] = {my: dict(my_vals), opp: dict(opp_vals)}
-		return dict(self._river_cache[sig][my])
-
-	def _resolved_pot(self, node):
-		ps = node.public_state
-		return float(ps.pot_size)
-
-	def _node_signature(self, node, my_range, opp_range):
-		board_t = tuple(node.public_state.board_cards)
-		pot = float(node.public_state.pot_size)
-		cb = (float(node.public_state.current_bets[0]), float(node.public_state.current_bets[1]))
-		r1 = tuple(sorted((int(k), float(v)) for k, v in dict(my_range).items()))
-		r2 = tuple(sorted((int(k), float(v)) for k, v in dict(opp_range).items()))
-		return (board_t, pot, cb, r1, r2)
