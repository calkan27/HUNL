--- a/cfr_solver_strategies.py
+++ b/cfr_solver_strategies.py
@@ -117,181 +117,58 @@
 
 
     def _allowed_actions_agent(self, ps):
-        self._ensure_sparse_schedule()
-        legal = ps.legal_actions() if hasattr(ps, "legal_actions") else None
-        if isinstance(legal, list) and len(legal) > 0:
+            self._ensure_sparse_schedule()
+            out = []
+            p = ps.current_player
+            o = (p + 1) % 2
+            my_bet = ps.current_bets[p]
+            opp_bet = ps.current_bets[o]
+            to_call = opp_bet - my_bet
+            if to_call < 0:
+                    to_call = 0
+            flags = self._round_actions.get(int(ps.current_round), {"half_pot": True, "two_pot": False})
+            min_raise_inc = ps._min_raise_size()
+            if to_call > 0:
+                    out.append(ActionType.FOLD)
+            out.append(ActionType.CALL)
+            if to_call == 0:
+                    if ps.stacks[p] > 0:
+                            if flags.get("half_pot", False):
+                                    hp = max(min_raise_inc, int(ps.pot_size * 0.5))
+                                    if ps.stacks[p] >= hp and hp > 0:
+                                            out.append(ActionType.HALF_POT_BET)
+                            pt = max(min_raise_inc, int(ps.pot_size))
+                            if ps.stacks[p] >= pt and pt > 0:
+                                    out.append(ActionType.POT_SIZED_BET)
+                            if flags.get("two_pot", False):
+                                    tp = max(min_raise_inc, int(ps.pot_size * 2.0))
+                                    if ps.stacks[p] >= tp and tp > 0:
+                                            out.append(ActionType.TWO_POT_BET)
+                            out.append(ActionType.ALL_IN)
+            else:
+                    remaining_after_call = ps.stacks[p] - to_call
+                    if remaining_after_call > 0:
+                            pot_after_call = ps.pot_size + to_call
+                            if flags.get("half_pot", False):
+                                    hp = max(min_raise_inc, int(pot_after_call * 0.5))
+                                    if remaining_after_call >= hp and hp > 0:
+                                            out.append(ActionType.HALF_POT_BET)
+                            pt = max(min_raise_inc, int(pot_after_call))
+                            if remaining_after_call >= pt and pt > 0:
+                                    out.append(ActionType.POT_SIZED_BET)
+                            if flags.get("two_pot", False):
+                                    tp = max(min_raise_inc, int(pot_after_call * 2.0))
+                                    if remaining_after_call >= tp and tp > 0:
+                                            out.append(ActionType.TWO_POT_BET)
+                    out.append(ActionType.ALL_IN)
+            legal = set(ps.legal_actions()) if hasattr(ps, "legal_actions") else None
+            if isinstance(legal, set):
+                    out = [a for a in out if a in legal]
             seen = set()
-            out = []
-            for a in legal:
-                if a not in seen:
-                    seen.add(a)
-                    out.append(a)
-            return out
+            filt = []
+            for a in out:
+                    if a not in seen:
+                            seen.add(a)
+                            filt.append(a)
+            return filt
 
-        out: List[ActionType] = []
-
-        p = ps.current_player
-        o = (p + 1) % 2
-        my_bet = ps.current_bets[p]
-        opp_bet = ps.current_bets[o]
-        to_call = opp_bet - my_bet
-        if to_call < 0:
-            to_call = 0
-
-        flags = self._round_actions.get(int(ps.current_round), {"half_pot": True, "two_pot": False})
-        min_raise_inc = ps._min_raise_size()
-
-        if to_call > 0:
-            out.append(ActionType.FOLD)
-        out.append(ActionType.CALL)
-
-        if to_call == 0:
-            if ps.stacks[p] > 0:
-                if flags.get("half_pot", False):
-                    hp = max(min_raise_inc, int(ps.pot_size * 0.5))
-                    if ps.stacks[p] >= hp and hp > 0:
-                        out.append(ActionType.HALF_POT_BET)
-                pt = max(min_raise_inc, int(ps.pot_size))
-                if ps.stacks[p] >= pt and pt > 0:
-                    out.append(ActionType.POT_SIZED_BET)
-                if flags.get("two_pot", False):
-                    tp = max(min_raise_inc, int(ps.pot_size * 2.0))
-                    if ps.stacks[p] >= tp and tp > 0:
-                        out.append(ActionType.TWO_POT_BET)
-                out.append(ActionType.ALL_IN)
-        else:
-            remaining_after_call = ps.stacks[p] - to_call
-            if remaining_after_call > 0:
-                pot_after_call = ps.pot_size + to_call
-                if flags.get("half_pot", False):
-                    hp = max(min_raise_inc, int(pot_after_call * 0.5))
-                    if remaining_after_call >= hp and hp > 0:
-                        out.append(ActionType.HALF_POT_BET)
-                pt = max(min_raise_inc, int(pot_after_call))
-                if remaining_after_call >= pt and pt > 0:
-                    out.append(ActionType.POT_SIZED_BET)
-                if flags.get("two_pot", False):
-                    tp = max(min_raise_inc, int(pot_after_call * 2.0))
-                    if remaining_after_call >= tp and tp > 0:
-                        out.append(ActionType.TWO_POT_BET)
-            out.append(ActionType.ALL_IN)
-
-        return out
-
-	def _allowed_actions_opponent(self, ps):
-		self._ensure_sparse_schedule()
-
-		p = ps.current_player
-		o = (p + 1) % 2
-		my_bet = ps.current_bets[p]
-		opp_bet = ps.current_bets[o]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-
-		lvl = 2
-		try:
-			envlvl = int(os.getenv("HUNL_MENU_LEVEL", "-1"))
-			if envlvl >= 0:
-				lvl = envlvl
-			else:
-				iters = int(getattr(self, "total_iterations", 0))
-				if iters >= 8:
-					lvl = 2
-				elif iters >= 4:
-					lvl = 1
-				else:
-					lvl = 0
-		except Exception:
-			lvl = 2
-
-		legal = ps.legal_actions() if hasattr(ps, "legal_actions") else []
-		out: List[ActionType] = []
-
-		if to_call > 0 and ActionType.FOLD in legal:
-			out.append(ActionType.FOLD)
-		if ActionType.CALL in legal:
-			out.append(ActionType.CALL)
-		if ActionType.POT_SIZED_BET in legal:
-			out.append(ActionType.POT_SIZED_BET)
-		if ActionType.ALL_IN in legal:
-			out.append(ActionType.ALL_IN)
-
-		if lvl == 0:
-			out = [a for a in out if a in (ActionType.FOLD, ActionType.CALL, ActionType.ALL_IN)]
-
-		seen = set()
-		filt: List[ActionType] = []
-		for a in out:
-			if a not in seen:
-				seen.add(a)
-				filt.append(a)
-		return filt
-
-
-	def _mask_strategy(self, strategy: List[float], allowed_actions: List[ActionType]) -> List[float]:
-		m = [0.0] * len(strategy)
-		allowed_idx = [a.value for a in allowed_actions]
-		s = 0.0
-		i = 0
-		while i < len(strategy):
-			if i in allowed_idx:
-				v = strategy[i]
-				if v < 0.0:
-					v = 0.0
-				m[i] = v
-				s += v
-			i += 1
-		if s > 0.0:
-			i = 0
-			while i < len(m):
-				m[i] = m[i] / s
-				i += 1
-		else:
-			u = 1.0 / float(len(allowed_idx)) if allowed_idx else 0.0
-			i = 0
-			while i < len(m):
-				m[i] = u if i in allowed_idx else 0.0
-				i += 1
-		return m
-
-	def _mixed_action_distribution(self, node: GameNode, player: int, allowed_actions: List[ActionType]) -> List[float]:
-		num_actions = len(allowed_actions)
-		if num_actions == 0:
-			return []
-		values = self.cfr_values[node]
-		priors = node.player_ranges[player]
-		w_sum = 0.0
-		acc = [0.0] * len(ActionType)
-		for cid, p in priors.items():
-			strat = values.get_average_strategy(cid)
-			m = self._mask_strategy(strat, allowed_actions)
-			i = 0
-			while i < len(m):
-				acc[i] += float(p) * float(m[i])
-				i += 1
-			w_sum += float(p)
-		if w_sum <= 0.0:
-			u = 1.0 / float(num_actions)
-			return [u] * num_actions
-		total = 0.0
-		probs = []
-		for a_type in allowed_actions:
-			pi = acc[a_type.value] / w_sum
-			if pi < 0.0:
-				pi = 0.0
-			probs.append(pi)
-			total += pi
-		if total <= 0.0:
-			u = 1.0 / float(num_actions)
-			return [u] * num_actions
-		i = 0
-		while i < len(probs):
-			probs[i] = probs[i] / total
-			i += 1
-		return probs
-
-
-	def set_cfr_hybrid_config(self, preflop_omit=0, flop_omit=0, turn_omit=0):
-		self._omit_prefix_iters = {"preflop": int(preflop_omit), "flop": int(flop_omit), "turn": int(turn_omit)}
-		return dict(self._omit_prefix_iters)
