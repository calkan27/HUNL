--- a/play_cli.py
+++ b/play_cli.py
@@ -58,84 +58,110 @@
 			f.write(line + "\n")
 
 def run_continual_cli(argv: Optional[list] = None):
-	parser = argparse.ArgumentParser(prog="hunl-play", add_help=True)
-	parser.add_argument("--mode", choices=["self", "baseline", "acpc-client"], default="baseline")
-	parser.add_argument("--hands", type=int, default=1)
-	parser.add_argument("--stack", type=int, default=200)
-	parser.add_argument("--sb", type=int, default=1)
-	parser.add_argument("--bb", type=int, default=2)
-	parser.add_argument("--dealer", type=int, default=0)
-	parser.add_argument("--depth", type=int, default=1)
-	parser.add_argument("--iters", type=int, default=400)
-	parser.add_argument("--bet-frac", type=float, nargs="+", default=[1.0])
-	parser.add_argument("--seed", type=int, default=1729)
-	parser.add_argument("--log", type=str, default="")
-	args = parser.parse_args(argv)
-	random.seed(args.seed)
-	if args.mode == "acpc-client":
-		for line in iter(input, ""):
-			try:
-				msg = json.loads(line.strip())
-			except Exception:
-				continue
-			if msg.get("type") == "query":
-				psd = msg.get("public_state", {})
-				ps = PublicState(initial_stacks=[int(psd.get("s0", args.stack)), int(psd.get("s1", args.stack))], small_blind=args.sb, big_blind=args.bb, board_cards=psd.get("board", []), dealer=int(psd.get("dealer", 0)))
-				ps.current_round = int(psd.get("round", 0))
-				ps.current_bets = [int(psd.get("b0", 0)), int(psd.get("b1", 0))]
-				ps.pot_size = float(psd.get("pot", 0.0))
-				ps.current_player = int(psd.get("player", 0))
-				K = int(psd.get("K", 6))
-				r = _r_uniform(K)
-				w = {i: 0.0 for i in range(K)}
-				t0 = time.time()
-				policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
-				t1 = time.time()
-				action = _choose_action(policy) if policy else ActionType.CALL
-				_log({"mode": "acpc-client", "t_ms": int((t1 - t0) * 1000), "policy": {str(k): float(v) for k, v in policy.items()}, "action": int(action.value)}, args.log)
-				resp = {"type": "action", "action": int(action.value)}
-				print(json.dumps(resp), flush=True)
-			if msg.get("type") == "close":
-				break
-		return
-	for h in range(int(args.hands)):
-		ps = PublicState(initial_stacks=[args.stack, args.stack], small_blind=args.sb, big_blind=args.bb, board_cards=None, dealer=int(args.dealer if h % 2 == 0 else (1 - args.dealer)))
-		node = GameNode(ps)
-		r = _r_uniform(6)
-		w = {i: 0.0 for i in range(6)}
-		hand_log = {"hand": h + 1, "decisions": []}
-		step_guard = 0
-		while not ps.is_terminal and step_guard < 200:
-			step_guard += 1
-			t0 = time.time()
-			if args.mode == "self":
-				policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
-				act_type = _choose_action(policy) if policy else ActionType.CALL
-			elif args.mode == "baseline":
-				if ps.current_player == ps.dealer:
-					policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
-					act_type = _choose_action(policy) if policy else ActionType.CALL
-				else:
-					w_next = w
-					our_cfv = {}
-					act_type = _heuristic_action(ps)
-			else:
-				policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
-				act_type = _choose_action(policy) if policy else ActionType.CALL
-			new_ps = ps.update_state(node, Action(act_type))
-			t1 = time.time()
-			hand_log["decisions"].append({
-				"round": int(ps.current_round),
-				"player": int(ps.current_player),
-				"pot": float(ps.pot_size),
-				"bets": [int(ps.current_bets[0]), int(ps.current_bets[1])],
-				"action": int(act_type.value),
-				"t_ms": int((t1 - t0) * 1000),
-				"policy": {str(k): float(v) for k, v in (policy if args.mode != "baseline" or ps.current_player == ps.dealer else {}).items()}
-			})
-			ps = new_ps
-			node = GameNode(ps)
-			r = r
-			w = w_next
-		_log({"mode": args.mode, "result": ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0], "hand": h + 1, "steps": step_guard, "dealer": int(ps.dealer), "final_pot": float(ps.pot_size), "log": hand_log}, args.log)
+        parser = argparse.ArgumentParser(prog="hunl-play", add_help=True)
+        parser.add_argument("--mode", choices=["self", "baseline", "acpc-client"], default="baseline")
+        parser.add_argument("--hands", type=int, default=1)
+        parser.add_argument("--stack", type=int, default=200)
+        parser.add_argument("--sb", type=int, default=1)
+        parser.add_argument("--bb", type=int, default=2)
+        parser.add_argument("--dealer", type=int, default=0)
+        parser.add_argument("--depth", type=int, default=1)
+        parser.add_argument("--iters", type=int, default=400)
+        parser.add_argument("--bet-frac", type=float, nargs="+", default=[1.0])
+        parser.add_argument("--seed", type=int, default=1729)
+        parser.add_argument("--log", type=str, default="")
+        parser.add_argument("--k1", type=float, default=0.0)
+        parser.add_argument("--k2", type=float, default=0.0)
+        args = parser.parse_args(argv)
+        random.seed(args.seed)
+        diag_template = {
+                "depth_limit": int(args.depth),
+                "iteration_budget": int(args.iters),
+                "k1": float(args.k1),
+                "k2": float(args.k2),
+                "zero_sum_residual": None,
+                "regret_l2": None,
+                "avg_strategy_entropy": None,
+        }
+        if args.mode == "acpc-client":
+                for line in iter(input, ""):
+                        try:
+                                msg = json.loads(line.strip())
+                        except Exception:
+                                continue
+                        if msg.get("type") == "query":
+                                psd = msg.get("public_state", {})
+                                ps = PublicState(initial_stacks=[int(psd.get("s0", args.stack)), int(psd.get("s1", args.stack))], small_blind=args.sb, big_blind=args.bb, board_cards=psd.get("board", []), dealer=int(psd.get("dealer", 0)))
+                                ps.current_round = int(psd.get("round", 0))
+                                ps.current_bets = [int(psd.get("b0", 0)), int(psd.get("b1", 0))]
+                                ps.pot_size = float(psd.get("pot", 0.0))
+                                ps.current_player = int(psd.get("player", 0))
+                                K = int(psd.get("K", 6))
+                                r = _r_uniform(K)
+                                w = {i: 0.0 for i in range(K)}
+                                t0 = time.time()
+                                policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
+                                t1 = time.time()
+                                action = _choose_action(policy) if policy else ActionType.CALL
+                                diag = dict(diag_template)
+                                diag.update({
+                                        "round": int(ps.current_round),
+                                        "player": int(ps.current_player),
+                                        "pot": float(ps.pot_size),
+                                })
+                                _log({"mode": "acpc-client", "t_ms": int((t1 - t0) * 1000), "policy": {str(k): float(v) for k, v in policy.items()}, "action": int(action.value)}, args.log)
+                                _log({"type": "decision_diag", **diag}, args.log)
+                                resp = {"type": "action", "action": int(action.value)}
+                                print(json.dumps(resp), flush=True)
+                        if msg.get("type") == "close":
+                                break
+                return
+        for h in range(int(args.hands)):
+                ps = PublicState(initial_stacks=[args.stack, args.stack], small_blind=args.sb, big_blind=args.bb, board_cards=None, dealer=int(args.dealer if h % 2 == 0 else (1 - args.dealer)))
+                node = GameNode(ps)
+                r = _r_uniform(6)
+                w = {i: 0.0 for i in range(6)}
+                hand_log = {"hand": h + 1, "decisions": []}
+                step_guard = 0
+                while not ps.is_terminal and step_guard < 200:
+                        step_guard += 1
+                        t0 = time.time()
+                        if args.mode == "self":
+                                policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
+                                act_type = _choose_action(policy) if policy else ActionType.CALL
+                        elif args.mode == "baseline":
+                                if ps.current_player == ps.dealer:
+                                        policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
+                                        act_type = _choose_action(policy) if policy else ActionType.CALL
+                                else:
+                                        w_next = w
+                                        our_cfv = {}
+                                        act_type = _heuristic_action(ps)
+                        else:
+                                policy, w_next, our_cfv = _resolve(ps, r, w, args.depth, args.iters, args.bet_frac)
+                                act_type = _choose_action(policy) if policy else ActionType.CALL
+                        new_ps = ps.update_state(node, Action(act_type))
+                        t1 = time.time()
+                        rec = {
+                                "round": int(ps.current_round),
+                                "player": int(ps.current_player),
+                                "pot": float(ps.pot_size),
+                                "bets": [int(ps.current_bets[0]), int(ps.current_bets[1])],
+                                "action": int(act_type.value),
+                                "t_ms": int((t1 - t0) * 1000),
+                                "policy": {str(k): float(v) for k, v in (policy if args.mode != "baseline" or ps.current_player == ps.dealer else {}).items()}
+                        }
+                        hand_log["decisions"].append(rec)
+                        diag = dict(diag_template)
+                        diag.update({
+                                "round": int(ps.current_round),
+                                "player": int(ps.current_player),
+                                "pot": float(ps.pot_size),
+                        })
+                        _log({"type": "decision_diag", **diag}, args.log)
+                        ps = new_ps
+                        node = GameNode(ps)
+                        r = r
+                        w = w_next
+                _log({"mode": args.mode, "result": ps.terminal_utility() if hasattr(ps, "terminal_utility") else [0.0, 0.0], "hand": h + 1, "steps": step_guard, "dealer": int(ps.dealer), "final_pot": float(ps.pot_size), "log": hand_log}, args.log)
 
