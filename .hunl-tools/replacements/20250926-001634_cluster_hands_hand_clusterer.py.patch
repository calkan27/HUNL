--- a/hand_clusterer.py
+++ b/hand_clusterer.py
@@ -86,187 +86,98 @@
 				self.opp_sample_size = int(opp_sample_size) if opp_sample_size is not None else None
 				self.use_cfv_in_features = bool(use_cfv_in_features)
 
-	def cluster_hands(
-		self,
-		hands: Any,
-		board: List[str],
-		opponent_range: Dict[Any, float],
-		pot_size: float,
-	) -> Dict[int, Set[str]]:
-
-		if self.profile == "test":
-			ok = (os.getenv("FAST_TESTS") == "1") or bool(getattr(self._config, "debug_fast_tests", False) if getattr(self, "_config", None) is not None else False)
-			assert ok
-			if self._fast_test_frozen_clusters is not None:
-				return self._fast_test_frozen_clusters
-			if isinstance(hands, (set, dict)):
-				hands_list = sorted(list(hands if not isinstance(hands, dict) else hands.keys()))
-			else:
-				hands_list = list(hands)
-				hands_list.sort()
-			K = int(self.num_clusters)
-			N = len(hands_list)
-			clusters = {i: set() for i in range(K)}
-			if N == 0:
-				self._fast_test_frozen_clusters = clusters
-				self.clusters = clusters
-				self.centroids = None
-				self._fast_test_initialized = True
-				return clusters
-			rng = random.Random(self._fast_test_seed)
-			if N < K:
-				perm = list(range(K))
-				rng.shuffle(perm)
-				for idx, hand in enumerate(hands_list):
-					clusters[perm[idx]] = {hand}
-			else:
-				for hand in hands_list:
-					key = hand if isinstance(hand, str) else " ".join(list(hand))
-					h = hashlib.sha256(key.encode("utf-8")).hexdigest()
-					cls = int(h, 16) % K
-					clusters[cls].add(hand)
-			for k in range(K):
-				if k not in clusters:
-					clusters[k] = set()
-			empties = [k for k, v in clusters.items() if len(v) == 0]
-			if empties:
-				donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-				for e in empties:
-					if not donors:
-						break
-					dk, _ = donors[0]
-					move = sorted(clusters[dk])[0]
-					clusters[dk].remove(move)
-					clusters[e].add(move)
-					donors = sorted([(k, len(v)) for k, v in clusters.items() if len(v) > 1], key=lambda x: -x[1])
-			self._fast_test_frozen_clusters = clusters
-			self.clusters = clusters
-			self.centroids = None
-			self._last_features = None
-			self._fast_test_initialized = True
-			return clusters
-
-		start_time = time.time()
-		hits_before = self._cache_hits
-		misses_before = self._cache_misses
-
-		feats: Dict[str, np.ndarray] = {}
-		if isinstance(hands, dict):
-			iterable = hands.keys()
-		else:
-			iterable = hands
-		for h in iterable:
-			f = self.calculate_hand_features(h, board, opponent_range, pot_size)
-			feats[h] = np.asarray(f, dtype=float)
-
-		N = len(feats)
-		if N == 0:
-			self.clusters = {}
-			self.centroids = None
-			self._last_features = {}
-			return {}
-
-		Kcfg = int(self.num_clusters)
-		if N < Kcfg:
-			Kcfg = N
-			self.num_clusters = Kcfg
-
-		drift = self._compute_drift(feats)
-		if drift is not None and drift < float(getattr(self, "tau_re", 0.12)) and isinstance(self.clusters, dict) and self.clusters:
-			current_set = set(iterable) if not isinstance(hands, dict) else set(hands.keys())
-			reused: Dict[int, Set[str]] = {int(k): set() for k in range(self.num_clusters)}
-			assigned = set()
-			for cid, hset in self.clusters.items():
-				keep = set()
-				for h in hset:
-					if h in current_set:
-						keep.add(h)
-						assigned.add(h)
-				reused[int(cid)] = keep
-			unassigned = current_set - assigned
-			if unassigned:
-				keys = list(feats.keys())
-				X = np.stack([feats[k] for k in keys], axis=0)
-				C = np.asarray(self.centroids, dtype=float) if isinstance(self.centroids, np.ndarray) else None
-				for h in sorted(unassigned):
-					if C is not None and C.size > 0:
-						x = feats[h].reshape(1, -1)
-						diff = C - x
-						d2 = np.sum(diff * diff, axis=1)
-						cid = int(np.argmin(d2))
-					else:
-						s = h if isinstance(h, str) else " ".join(list(h))
-						hh = hashlib.sha256(s.encode("utf-8")).hexdigest()
-						cid = int(int(hh, 16) % int(self.num_clusters))
-					reused[cid].add(h)
-			for k in range(self.num_clusters):
-				if k not in reused:
-					reused[k] = set()
-			self._last_features = feats
-			self.clusters = reused
-			return self.clusters
-
-		keys = list(feats.keys())
-		X = np.stack([feats[k] for k in keys], axis=0)
-
-		rs = np.random.RandomState(self._deterministic_seed_for_clustering(board, opponent_range, pot_size))
-		cent_idx = []
-		i0 = rs.randint(0, N)
-		cent_idx.append(int(i0))
-		D = np.full((N,), np.inf, dtype=float)
-		while len(cent_idx) < Kcfg:
-			c = X[cent_idx[-1]]
-			diff = X - c
-			d2 = np.sum(diff * diff, axis=1)
-			D = np.minimum(D, d2)
-			denom = np.sum(D) if np.sum(D) > 0.0 else 1.0
-			probs = D / denom
-			r = rs.rand()
-			acc = 0.0
-			pick = 0
-			for i in range(N):
-				acc += probs[i]
-				if r <= acc:
-					pick = i
-					break
-			if pick in cent_idx:
-				pick = int(rs.randint(0, N))
-			cent_idx.append(int(pick))
-		C = X[cent_idx, :].copy()
-
-		assign = np.full((N,), -1, dtype=int)
-		it = 0
-		max_it = int(self.max_iterations)
-		while it < max_it:
-			it += 1
-			diff = X[:, None, :] - C[None, :, :]
-			dist2 = np.sum(diff * diff, axis=2)
-			new_assign = np.argmin(dist2, axis=1).astype(int)
-			if np.array_equal(assign, new_assign):
-				break
-			assign = new_assign
-			for k in range(Kcfg):
-				idx = np.where(assign == k)[0]
-				if idx.size > 0:
-					C[k, :] = np.mean(X[idx, :], axis=0)
-
-		clusters_raw: Dict[int, Set[str]] = {i: set() for i in range(Kcfg)}
-		for i in range(N):
-			k = int(assign[i]) if assign[i] >= 0 else int(np.argmin(np.sum((X[i:i+1] - C) ** 2, axis=1)))
-			clusters_raw[k].add(keys[i])
-
-		for k in range(Kcfg):
-			if k not in clusters_raw:
-				clusters_raw[k] = set()
-
-		self.clusters = {int(k): set(v) for k, v in clusters_raw.items()}
-		self.centroids = C.copy()
-		self._last_features = feats
-
-		total_time2 = time.time() - start_time
-		print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
-		print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{self._cache_hits - hits_before}/+{self._cache_misses - misses_before})")
-		return self.clusters
+    def cluster_hands(
+        self,
+        hands: Any,
+        board: List[str],
+        opponent_range: Dict[Any, float],
+        pot_size: float
+    ) -> Dict[int, Set[str]]:
+        if self.profile == "test":
+            ft = self._cluster_hands_fast_test(hands)
+            if ft is not None:
+                return ft
+            else:
+                print("[FAST-TEST] Proceeding with full clustering path.")
+
+        start_time = time.time()
+        hits_before = self._cache_hits
+        misses_before = self._cache_misses
+
+        feats = self._features_for_hands(
+            hands=hands,
+            board=board,
+            opponent_range=opponent_range,
+            pot_size=pot_size
+        )
+
+        N = len(feats)
+
+        if N == 0:
+            self.clusters = {}
+            self.centroids = None
+            self._last_features = {}
+            return {}
+
+        Kcfg = int(self.num_clusters)
+        if N < Kcfg:
+            Kcfg = N
+            self.num_clusters = Kcfg
+        else:
+            pass
+
+        reused = self._reuse_previous_clusters_if_drift_small(
+            feats=feats,
+            hands=hands
+        )
+        if reused is not None:
+            return reused
+        else:
+            pass
+
+        keys = list(feats.keys())
+        X = np.stack([feats[k] for k in keys], axis=0)
+
+        C = self._kmeanspp_init(
+            X=X,
+            Kcfg=Kcfg,
+            board=board,
+            opponent_range=opponent_range,
+            pot_size=pot_size
+        )
+
+        assign, C = self._lloyd_assign_and_update(
+            X=X,
+            C=C,
+            max_iterations=int(self.max_iterations)
+        )
+
+        clusters_raw: Dict[int, Set[str]] = {i: set() for i in range(Kcfg)}
+
+        for i in range(N):
+            if assign[i] >= 0:
+                k = int(assign[i])
+            else:
+                d2 = np.sum((X[i:i + 1] - C) ** 2, axis=1)
+                k = int(np.argmin(d2))
+            clusters_raw[k].add(keys[i])
+
+        for k in range(Kcfg):
+            if k not in clusters_raw:
+                clusters_raw[k] = set()
+
+        self.clusters = {int(k): set(v) for k, v in clusters_raw.items()}
+        self.centroids = C.copy()
+        self._last_features = feats
+
+        total_time2 = time.time() - start_time
+        dh = self._cache_hits - hits_before
+        dm = self._cache_misses - misses_before
+
+        print(f"[INFO] Clustering completed in {total_time2:.4f} seconds")
+        print(f"[CACHE] hits={self._cache_hits} misses={self._cache_misses} (+{dh}/+{dm})")
+
+        return self.clusters
 
 	def fit(
 		self,
