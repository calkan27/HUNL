--- a/eval_cli_lbr.py
+++ b/eval_cli_lbr.py
@@ -133,92 +133,89 @@
 
 
 def run_lbr_eval(
-	episodes: int = 10000,
-	seed: int = 1729,
-	cfg: Optional[ResolveConfig] = None,
-	policy_iters_agent: int = 2,
-	policy_iters_after_lbr: int = 2,
+        episodes: int = 10000,
+        seed: int = 1729,
+        cfg: Optional[ResolveConfig] = None,
+        policy_iters_agent: int = 2,
+        policy_iters_after_lbr: int = 2,
 ) -> Dict[str, object]:
 
-	random.seed(seed)
-	if cfg is None:
-		cfg = ResolveConfig.from_env({})
-
-	agent_solver = CFRSolver(config=cfg)
-	agent_solver.load_models()
-
-	K = agent_solver.num_clusters
-	u = 1.0 / float(K) if K > 0 else 0.0
-
-	freq = {"flop": {"FOLD": 0, "CALL": 0, "POT": 0, "ALL_IN": 0}}
-	results: List[float] = []
-	residual_max = 0.0
-
-	for i in range(1, int(episodes) + 1):
-		ps = PublicState(initial_stacks=[200, 200], board_cards=None, dealer=(i % 2))
-		ps.current_round = 0
-		ps.current_player = ps.dealer
-
-		node = GameNode(ps)
-		node.player_ranges[0] = {j: u for j in range(K)}
-		node.player_ranges[1] = {j: u for j in range(K)}
-
-		guard = 0
-		while not node.public_state.is_terminal and guard < 400:
-			guard += 1
-			cur_ps = node.public_state
-
-			if not _mass_conservation_ok_ranges(node.player_ranges[0], node.player_ranges[1], tol=1e-12):
-				raise ValueError("LBRInvariantRangeMass")
-
-			if int(cur_ps.current_round) == 1 and int(cur_ps.current_player) == 1:
-				act = lbr_greedy_action(cur_ps, agent_solver, lbr_player=1, iters_after=policy_iters_after_lbr, freq_log=freq)
-			else:
-				act = _engine_policy_action(agent_solver, node, iters=policy_iters_agent)
-				dg = agent_solver.get_last_diagnostics()
-				if isinstance(dg, dict):
-					residual_max = max(residual_max, float(dg.get("zero_sum_residual", 0.0)))
-
-			new_ps = cur_ps.update_state(node, Action(act))
-
-			if int(new_ps.current_round) - int(cur_ps.current_round) > 1 or int(new_ps.current_round) < int(cur_ps.current_round):
-				raise ValueError("LBRIllegalStreetJump")
-			if not _no_negative_pot_delta(cur_ps, new_ps):
-				raise ValueError("LBRNegativePotDelta")
-
-			node = GameNode(new_ps)
-			node.player_ranges[0] = {j: u for j in range(K)}
-			node.player_ranges[1] = {j: u for j in range(K)}
-
-		res = node.public_state.terminal_utility() if hasattr(node.public_state, "terminal_utility") else [0.0, 0.0]
-		results.append(float(res[0]))
-
-	mean = sum(results) / float(len(results) if results else 1)
-	bb = 2.0
-	mbbg = (mean / bb) * 1000.0
-
-	var = 0.0
-	for r in results:
-		d = r - mean
-		var += d * d
-	var = var / float(len(results) - 1 if len(results) > 1 else 1)
-	se = math.sqrt(var / float(len(results) if results else 1))
-	l95 = mbbg - 1.96 * ((se / bb) * 1000.0)
-	u95 = mbbg + 1.96 * ((se / bb) * 1000.0)
-
-	out = {
-		"episodes": int(episodes),
-		"mbb_per_game": float(mbbg),
-		"ci95": [float(l95), float(u95)],
-		"accept": bool(u95 <= -300.0),
-		"freq": {"flop": {k: int(v) for k, v in freq.get("flop", {}).items()}},
-		"sanity": {
-			"zero_sum_residual_max": float(residual_max),
-			"zero_sum_residual_max_ok": bool(residual_max <= 1e-6),
-		},
-	}
-	return out
-
+        random.seed(seed)
+        if cfg is None:
+                cfg = ResolveConfig.from_env({})
+
+        agent_solver = CFRSolver(config=cfg)
+        agent_solver.load_models()
+
+        K = agent_solver.num_clusters
+        u = 1.0 / float(K) if K > 0 else 0.0
+
+        freq = {"flop": {"FOLD": 0, "CALL": 0, "POT": 0, "ALL_IN": 0}}
+        results: List[float] = []
+        residual_max = 0.0
+
+        for i in range(1, int(episodes) + 1):
+                ps = PublicState(initial_stacks=[200, 200], board_cards=None, dealer=(i % 2))
+                ps.current_round = 0
+                ps.current_player = ps.dealer
+
+                node = GameNode(ps)
+                node.player_ranges[0] = {j: u for j in range(K)}
+                node.player_ranges[1] = {j: u for j in range(K)}
+
+                guard = 0
+                while not node.public_state.is_terminal and guard < 400:
+                        guard += 1
+                        cur_ps = node.public_state
+
+                        if not _mass_conservation_ok_ranges(node.player_ranges[0], node.player_ranges[1], tol=1e-12):
+                                raise ValueError("LBRInvariantRangeMass")
+
+                        if int(cur_ps.current_round) == 1 and int(cur_ps.current_player) == 1:
+                                act = lbr_greedy_action(cur_ps, agent_solver, lbr_player=1, iters_after=policy_iters_after_lbr, freq_log=freq)
+                        else:
+                                act = _engine_policy_action(agent_solver, node, iters=policy_iters_agent)
+                                dg = agent_solver.get_last_diagnostics()
+                                if isinstance(dg, dict):
+                                        residual_max = max(residual_max, float(dg.get("zero_sum_residual", 0.0)))
+
+                        new_ps = cur_ps.update_state(node, Action(act))
+
+                        if (not getattr(new_ps, "is_terminal", False)) and (int(getattr(new_ps, "current_round", 0)) - int(getattr(cur_ps, "current_round", 0)) > 1 or int(getattr(new_ps, "current_round", 0)) < int(getattr(cur_ps, "current_round", 0))):
+                                raise ValueError("LBRIllegalStreetJump")
+
+                        node = GameNode(new_ps)
+                        node.player_ranges[0] = {j: u for j in range(K)}
+                        node.player_ranges[1] = {j: u for j in range(K)}
+
+                res = node.public_state.terminal_utility() if hasattr(node.public_state, "terminal_utility") else [0.0, 0.0]
+                results.append(float(res[0]))
+
+        mean = sum(results) / float(len(results) if results else 1)
+        bb = 2.0
+        mbbg = (mean / bb) * 1000.0
+
+        var = 0.0
+        for r in results:
+                d = r - mean
+                var += d * d
+        var = var / float(len(results) - 1 if len(results) > 1 else 1)
+        se = math.sqrt(var / float(len(results) if results else 1))
+        l95 = mbbg - 1.96 * ((se / bb) * 1000.0)
+        u95 = mbbg + 1.96 * ((se / bb) * 1000.0)
+
+        out = {
+                "episodes": int(episodes),
+                "mbb_per_game": float(mbbg),
+                "ci95": [float(l95), float(u95)],
+                "accept": bool(u95 <= -300.0),
+                "freq": {"flop": {k: int(v) for k, v in freq.get("flop", {}).items()}},
+                "sanity": {
+                        "zero_sum_residual_max": float(residual_max),
+                        "zero_sum_residual_max_ok": bool(residual_max <= 1e-6),
+                },
+        }
+        return out
 
 def run_lbr_acceptance(
 	seeds: List[int],
