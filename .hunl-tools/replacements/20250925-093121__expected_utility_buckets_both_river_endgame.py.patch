--- a/river_endgame.py
+++ b/river_endgame.py
@@ -70,33 +70,39 @@
 		else:
 			return 0.5 * p
 
-	def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
-		if resolved_pot is not None:
-			p = float(resolved_pot)
-		elif my_bet is not None or opp_bet is not None:
-			p = float(my_bet or 0.0) + float(opp_bet or 0.0)
-		else:
-			p = 1.0
-		ev_p = 0.0
-		ev_o = 0.0
-		i = 0
-		while i < B:
-			j = 0
-			while j < B:
-				w = float(my_bucket_probs[i]) * float(opp_bucket_probs[j])
-				if i > j:
-					ev_p += w * p
-					ev_o -= w * p
-				elif i < j:
-					ev_p -= w * p
-					ev_o += w * p
-				else:
-					t = 0.5 * p
-					ev_p += w * t
-					ev_o -= w * t
-				j += 1
-			i += 1
-		return ev_p, ev_o
+    def _expected_utility_buckets_both(self, my_bucket_probs, opp_bucket_probs, B, resolved_pot=None, my_bet=None, opp_bet=None):
+        if my_bet is not None or opp_bet is not None:
+            mb = float(my_bet or 0.0)
+            ob = float(opp_bet or 0.0)
+            def _payoff(i, j):
+                if i > j:
+                    return ob
+                elif i < j:
+                    return -mb
+                else:
+                    return 0.5 * (ob - mb)
+        else:
+            p = float(resolved_pot if resolved_pot is not None else 1.0)
+            def _payoff(i, j):
+                if i > j:
+                    return p
+                elif i < j:
+                    return -p
+                else:
+                    return 0.5 * p
+        ev_p = 0.0
+        ev_o = 0.0
+        i = 0
+        while i < B:
+            j = 0
+            while j < B:
+                w = float(my_bucket_probs[i]) * float(opp_bucket_probs[j])
+                v = _payoff(i, j)
+                ev_p += w * v
+                ev_o -= w * v
+                j += 1
+            i += 1
+        return ev_p, ev_o
 
 	def _normalize_range(self, r):
 		out = {int(k): float(v) for k, v in dict(r).items()}
