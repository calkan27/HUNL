--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -672,66 +672,65 @@
 			self._preflop_cache_stats["evictions"] += 1
 
 
-	def predict_counterfactual_values(self, node, player):
-		if not hasattr(self, "_diag_cfv_calls"):
-			self._diag_cfv_calls = {"preflop": 0, "flop": 0, "turn": 0, "river": 0}
-		stage = self.get_stage(node)
-		if stage in self._diag_cfv_calls:
-			self._diag_cfv_calls[stage] += 1
-		if stage == 'river':
-			def wins_fn(ph, oh, board):
-				return self._player_wins(ph, oh, board)
-			cf = self.river_endgame.compute_cluster_cfvs(self.clusters, node, player, wins_fn, best_hand, hand_rank)
-			out = {}
-			for cid, val in cf.items():
-				out[int(cid)] = val
-			return out
-		if stage not in self.models:
-			counterfactual_values = {}
-			for cluster_id in node.player_ranges[player]:
-				counterfactual_values[cluster_id] = [0.0] * len(ActionType)
-			return counterfactual_values
-		if stage == 'preflop':
-			input_vector = self.prepare_input_vector_preflop(node)
-		else:
-			input_vector = self.prepare_input_vector(node)
-		input_tensor = torch.tensor([input_vector], dtype=torch.float32).to(self.device)
-		stage_model = self.models[stage]
-		with torch.no_grad():
-			v1, v2 = stage_model(input_tensor)
-			K = self.num_clusters
-			if stage == 'preflop':
-				start_r1 = 1
-				end_r1 = start_r1 + K
-				start_r2 = end_r1
-				end_r2 = start_r2 + K
-			else:
-				start_r1 = 1 + len(DECK)
-				end_r1 = start_r1 + K
-				start_r2 = end_r1
-				end_r2 = start_r2 + K
-			r1 = input_tensor[:, start_r1:end_r1]
-			r2 = input_tensor[:, start_r2:end_r2]
-			v1_adj, v2_adj = stage_model.enforce_zero_sum(r1, r2, v1, v2)
-			try:
-				s1 = torch.sum(r1 * v1_adj, dim=1, keepdim=True)
-				s2 = torch.sum(r2 * v2_adj, dim=1, keepdim=True)
-				res = torch.abs(s1 + s2).view(-1).detach().cpu().tolist()
-				if hasattr(self, "_zs_residual_samples"):
-					self._zs_residual_samples.extend([float(x) for x in res])
-			except Exception:
-				pass
-		pred = v1_adj if player == 0 else v2_adj
-		counterfactual_values = {}
-		for cluster_id in node.player_ranges[player]:
-			idx = int(cluster_id)
-			if 0 <= idx < self.num_clusters:
-				scalar = float(pred[0][idx].item())
-			else:
-				s = 0.0
-				scalar = s
-			counterfactual_values[cluster_id] = [scalar] * len(ActionType)
-		return counterfactual_values
+    def predict_counterfactual_values(self, node, player):
+        if not hasattr(self, "_diag_cfv_calls"):
+            self._diag_cfv_calls = {"preflop": 0, "flop": 0, "turn": 0, "river": 0}
+        stage = self.get_stage(node)
+        if stage in self._diag_cfv_calls:
+            self._diag_cfv_calls[stage] += 1
+        if stage == 'river':
+            def wins_fn(ph, oh, board):
+                return self._player_wins(ph, oh, board)
+            cf = self.river_endgame.compute_cluster_cfvs(self.clusters, node, player, wins_fn, best_hand, hand_rank)
+            out = {}
+            for cid, val in cf.items():
+                out[int(cid)] = val
+            return out
+        if stage not in self.models:
+            counterfactual_values = {}
+            for cluster_id in node.player_ranges[player]:
+                counterfactual_values[cluster_id] = [0.0] * len(ActionType)
+            return counterfactual_values
+        if stage == 'preflop':
+            input_vector = self.prepare_input_vector(node)
+            stage_model = self.models['flop']
+            K = self.num_clusters
+            start_r1 = 1 + len(DECK)
+            end_r1 = start_r1 + K
+            start_r2 = end_r1
+            end_r2 = start_r2 + K
+        else:
+            input_vector = self.prepare_input_vector(node)
+            stage_model = self.models[stage]
+            K = self.num_clusters
+            start_r1 = 1 + len(DECK)
+            end_r1 = start_r1 + K
+            start_r2 = end_r1
+            end_r2 = start_r2 + K
+        input_tensor = torch.tensor([input_vector], dtype=torch.float32).to(self.device)
+        with torch.no_grad():
+            v1, v2 = stage_model(input_tensor)
+            r1 = input_tensor[:, start_r1:end_r1]
+            r2 = input_tensor[:, start_r2:end_r2]
+            v1_adj, v2_adj = stage_model.enforce_zero_sum(r1, r2, v1, v2)
+            try:
+                s1 = torch.sum(r1 * v1_adj, dim=1, keepdim=True)
+                s2 = torch.sum(r2 * v2_adj, dim=1, keepdim=True)
+                res = torch.abs(s1 + s2).view(-1).detach().cpu().tolist()
+                if hasattr(self, "_zs_residual_samples"):
+                    self._zs_residual_samples.extend([float(x) for x in res])
+            except Exception:
+                pass
+        pred = v1_adj if player == 0 else v2_adj
+        counterfactual_values = {}
+        for cluster_id in node.player_ranges[player]:
+            idx = int(cluster_id)
+            if 0 <= idx < self.num_clusters:
+                scalar = float(pred[0][idx].item())
+            else:
+                scalar = 0.0
+            counterfactual_values[cluster_id] = [scalar] * len(ActionType)
+        return counterfactual_values
 
 	def prepare_input_vector(self, node):
 		total_initial = sum(node.public_state.initial_stacks) if getattr(node.public_state, "initial_stacks", None) else 1.0
