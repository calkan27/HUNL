--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -328,117 +328,125 @@
 		return result
 
 
-	def run_cfr(self, node):
-		self._ensure_sparse_schedule()
-		ps = node.public_state
-		agent_player = ps.current_player
-		if agent_player not in (0, 1):
-			return None
-		if ps.current_round == 0:
-			key0 = self._preflop_signature(node)
-			hit = self._preflop_cache_get(key0)
-			if hit is not None:
-				node.player_ranges[agent_player] = dict(hit["own_range"])
-				opp = (agent_player + 1) % 2
-				if node not in self.opponent_counterfactual_values:
-					self.opponent_counterfactual_values[node] = {}
-				packed = {}
-				for cid, ub in hit["opp_cfv"].items():
-					packed[int(cid)] = [float(ub)] * len(ActionType)
-				self.opponent_counterfactual_values[node][opp] = packed
-		key = self._state_key(node) if hasattr(self, "_state_key") else None
-		if hasattr(self, "own_range_tracking") and key in getattr(self, "own_range_tracking", {}):
-			node.player_ranges[agent_player] = dict(self.own_range_tracking[key])
-		if hasattr(self, "opponent_cfv_upper_tracking") and key in getattr(self, "opponent_cfv_upper_tracking", {}):
-			opp = (agent_player + 1) % 2
-			if node not in self.opponent_counterfactual_values:
-				self.opponent_counterfactual_values[node] = {}
-			upper = self.opponent_cfv_upper_tracking[key]
-			packed = {}
-			for cid, ub in upper.items():
-				packed[int(cid)] = [float(ub)] * len(ActionType)
-			self.opponent_counterfactual_values[node][opp] = packed
-		test_mode = (getattr(self, "hand_clusterer", None) is not None and getattr(self.hand_clusterer, "profile", "bot") == "test")
-		if test_mode:
-			if not self.clusters or len(self.clusters) == 0:
-				print("[ERROR] CFRSolver.run_cfr: test profile requires pre-set clusters; none found. Caller must set self.clusters before run_cfr.")
-				return None
-		if not test_mode and not self.clusters:
-			all_hands = self.generate_all_possible_hands()
-			self.clusters = self.hand_clusterer.cluster_hands(all_hands, ps.board_cards, node.player_ranges[(agent_player + 1) % 2], ps.pot_size)
-		fast_env = os.getenv("FAST_TESTS") == "1"
-		if fast_env:
-			for player in [0, 1]:
-				total = sum(node.player_ranges[player].values())
-				if total > 0.0:
-					for cid in list(node.player_ranges[player].keys()):
-						node.player_ranges[player][cid] = node.player_ranges[player][cid] / total
-				else:
-					keys = list(node.player_ranges[player].keys())
-					k = len(keys)
-					if k > 0:
-						u = 1.0 / k
-						for cid in keys:
-							node.player_ranges[player][cid] = u
-		else:
-			for player in [0, 1]:
-				total_prob = sum(node.player_ranges[player].values())
-				node.player_ranges[player] = self.recursive_range_sampling(set(node.player_ranges[player].keys()), total_prob, ps.board_cards)
-		self.cfr_values = defaultdict(CFRValues)
-		self.iteration = 0
-		self.apply_round_iteration_schedule(ps.current_round)
-		stage_name = self.get_stage(node)
-		if isinstance(self._omit_prefix_iters, dict) and stage_name in self._omit_prefix_iters:
-			pass
-		else:
-			self._omit_prefix_iters = {"preflop": 980, "flop": 500, "turn": 500, "river": 1000}
-		total_iters = int(self.total_iterations)
-		for _ in range(total_iters):
-			self.iteration += 1
-			cfvs = {}
-			for pl in [0, 1]:
-				cfvs[pl] = self._calculate_counterfactual_values(node, pl)
-			for pl in [0, 1]:
-				self._update_regret(node, pl, cfvs[pl])
-			if node not in self.opponent_counterfactual_values:
-				self.opponent_counterfactual_values[node] = {}
-			self.opponent_counterfactual_values[node][0] = cfvs[1]
-			self.opponent_counterfactual_values[node][1] = cfvs[0]
-		if ps.current_round == 0:
-			key1 = self._preflop_signature(node)
-			own = dict(node.player_ranges[agent_player])
-			s = sum(own.values())
-			if s > 0.0:
-				for k2 in list(own.keys()):
-					own[k2] = own[k2] / s
-			opp = (agent_player + 1) % 2
-			opp_cfvs = self.opponent_counterfactual_values.get(node, {}).get(opp, {})
-			upper = {}
-			for cid, vals in opp_cfvs.items():
-				if isinstance(vals, (list, tuple)) and len(vals) > 0:
-					m = float(max(vals))
-				else:
-					m = float(vals) if isinstance(vals, (int, float)) else 0.0
-				upper[int(cid)] = m
-			self._preflop_cache_put(key1, own, upper)
-		allowed_actions = self._allowed_actions_agent(ps)
-		action_probs = self._mixed_action_distribution(node, agent_player, allowed_actions)
-		r = random.random()
-		cum = 0.0
-		chosen = allowed_actions[-1]
-		for a_type, p in zip(allowed_actions, action_probs):
-			cum += p
-			if r <= cum:
-				chosen = a_type
-				break
-		act = Action(chosen)
-		new_ps = ps.update_state(node, act)
-		node.public_state = new_ps
-		if hasattr(self, "update_tracking_on_own_action"):
-			self.update_tracking_on_own_action(node, agent_player=agent_player, counterfactual_values=self.opponent_counterfactual_values.get(node, {}))
-		self.cfr_values = defaultdict(CFRValues)
-		self.iteration = 0
-		return act
+    def run_cfr(self, node):
+        self._ensure_sparse_schedule()
+        ps = node.public_state
+        agent_player = ps.current_player
+        if agent_player not in (0, 1):
+        return None
+        if ps.current_round == 0:
+            key0 = self._preflop_signature(node)
+            hit = self._preflop_cache_get(key0)
+            if hit is not None:
+                node.player_ranges[agent_player] = dict(hit["own_range"])
+                opp = (agent_player + 1) % 2
+                if node not in self.opponent_counterfactual_values:
+                    self.opponent_counterfactual_values[node] = {}
+                packed = {}
+                for cid, ub in hit["opp_cfv"].items():
+                    packed[int(cid)] = [float(ub)] * len(ActionType)
+                self.opponent_counterfactual_values[node][opp] = packed
+        key = self._state_key(node) if hasattr(self, "_state_key") else None
+        if hasattr(self, "own_range_tracking") and key in getattr(self, "own_range_tracking", {}):
+            node.player_ranges[agent_player] = dict(self.own_range_tracking[key])
+        if hasattr(self, "opponent_cfv_upper_tracking") and key in getattr(self, "opponent_cfv_upper_tracking", {}):
+            opp = (agent_player + 1) % 2
+            if node not in self.opponent_counterfactual_values:
+                self.opponent_counterfactual_values[node] = {}
+            upper = self.opponent_cfv_upper_tracking[key]
+            packed = {}
+            for cid, ub in upper.items():
+                packed[int(cid)] = [float(ub)] * len(ActionType)
+            self.opponent_counterfactual_values[node][opp] = packed
+        test_mode = (getattr(self, "hand_clusterer", None) is not None and getattr(self.hand_clusterer, "profile", "bot") == "test")
+        if test_mode:
+            if not self.clusters or len(self.clusters) == 0:
+                return None
+        if not test_mode and not self.clusters:
+            all_hands = self.generate_all_possible_hands()
+            self.clusters = self.hand_clusterer.cluster_hands(all_hands, ps.board_cards, node.player_ranges[(agent_player + 1) % 2], ps.pot_size)
+        fast_env = os.getenv("FAST_TESTS") == "1"
+        if fast_env:
+            for player in [0, 1]:
+                total = sum(node.player_ranges[player].values())
+                if total > 0.0:
+                    for cid in list(node.player_ranges[player].keys()):
+                        node.player_ranges[player][cid] = node.player_ranges[player][cid] / total
+                else:
+                    keys = list(node.player_ranges[player].keys())
+                    k = len(keys)
+                    if k > 0:
+                        u = 1.0 / k
+                        for cid in keys:
+                            node.player_ranges[player][cid] = u
+        else:
+            for player in [0, 1]:
+                total_prob = sum(node.player_ranges[player].values())
+                node.player_ranges[player] = self.recursive_range_sampling(set(node.player_ranges[player].keys()), total_prob, ps.board_cards)
+        from collections import defaultdict as _dd
+        self.cfr_values = _dd(CFRValues)
+        self.iteration = 0
+        self.apply_round_iteration_schedule(ps.current_round)
+        stage_name = self.get_stage(node)
+        if not (isinstance(self._omit_prefix_iters, dict) and stage_name in self._omit_prefix_iters):
+            self._omit_prefix_iters = {"preflop": 980, "flop": 500, "turn": 500, "river": 1000}
+        _ = self._range_gadget_begin(node)
+        total_iters = int(self.total_iterations)
+        for _ in range(total_iters):
+            self.iteration += 1
+            cfvs = {}
+            for pl in [0, 1]:
+                cfvs[pl] = self._calculate_counterfactual_values(node, pl)
+            for pl in [0, 1]:
+                self._update_regret(node, pl, cfvs[pl])
+            if node not in self.opponent_counterfactual_values:
+                self.opponent_counterfactual_values[node] = {}
+            self.opponent_counterfactual_values[node][0] = cfvs[1]
+            self.opponent_counterfactual_values[node][1] = cfvs[0]
+            opp_player = (agent_player + 1) % 2
+            upper = {}
+            for cid, vals in cfvs.get(opp_player, {}).items():
+                if isinstance(vals, (list, tuple)) and len(vals) > 0:
+                    m = float(max(vals))
+                else:
+                    m = float(vals) if isinstance(vals, (int, float)) else 0.0
+                upper[int(cid)] = m
+            self._range_gadget_commit(node, upper)
+        if ps.current_round == 0:
+            key1 = self._preflop_signature(node)
+            own = dict(node.player_ranges[agent_player])
+            s = sum(own.values())
+            if s > 0.0:
+                for k2 in list(own.keys()):
+                    own[k2] = own[k2] / s
+            opp = (agent_player + 1) % 2
+            opp_cfvs = self.opponent_counterfactual_values.get(node, {}).get(opp, {})
+            upper = {}
+            for cid, vals in opp_cfvs.items():
+                if isinstance(vals, (list, tuple)) and len(vals) > 0:
+                    m = float(max(vals))
+                else:
+                    m = float(vals) if isinstance(vals, (int, float)) else 0.0
+                upper[int(cid)] = m
+            self._preflop_cache_put(key1, own, upper)
+        allowed_actions = self._allowed_actions_agent(ps)
+        action_probs = self._mixed_action_distribution(node, agent_player, allowed_actions)
+        r = random.random()
+        cum = 0.0
+        chosen = allowed_actions[-1]
+        for a_type, p in zip(allowed_actions, action_probs):
+            cum += p
+            if r <= cum:
+                chosen = a_type
+                break
+        act = Action(chosen)
+        new_ps = ps.update_state(node, act)
+        node.public_state = new_ps
+        if hasattr(self, "update_tracking_on_own_action"):
+            self.update_tracking_on_own_action(node, agent_player=agent_player, counterfactual_values=self.opponent_counterfactual_values.get(node, {}))
+        self.cfr_values = _dd(CFRValues)
+        self.iteration = 0
+        return act
 
 	def _calculate_counterfactual_values(self, node, player, depth=0, cache=None):
 			if cache is None:
