--- a/public_state_actions.py
+++ b/public_state_actions.py
@@ -201,257 +201,65 @@
                     st._fast_forward_to_showdown_if_allin_locked()
 
     def _apply_two_pot_bet(self, st, player, to_call):
-        opponent = (player + 1) % 2
-        if to_call == 0:
-            target = st.pot_size * 2.0
-            if target < st.big_blind:
-                target = st.big_blind
-            if target > st.stacks[player]:
-                target = st.stacks[player]
-            bet_amt = int(target) if isinstance(target, float) else target
-            if bet_amt > 0:
-                st.stacks[player] = st.stacks[player] - bet_amt
-                st.current_bets[player] = st.current_bets[player] + bet_amt
-                st.pot_size = st.pot_size + bet_amt
-                st.total_contrib[player] += bet_amt
-                st.last_raiser = player
-                st.last_raise_increment = bet_amt
-                min_raise_inc = st._min_raise_size()
-                if st.stacks[player] == 0 and bet_amt < min_raise_inc:
-                    st.last_raise_was_allin_below_min = player
-                else:
-                    st.last_raise_was_allin_below_min = None
-                st.consecutive_checks = 0
-        else:
-            caller_stack_before = st.stacks[player]
-            matched = caller_stack_before if caller_stack_before < to_call else to_call
-            st.stacks[player] = st.stacks[player] - matched
-            st.current_bets[player] = st.current_bets[player] + matched
-            st.pot_size = st.pot_size + matched
-            st.total_contrib[player] += matched
-            if matched < to_call:
-                excess = to_call - matched
-                st.last_refund_amount = float(excess)
-                st.current_bets[opponent] = st.current_bets[opponent] - excess
-                st.stacks[opponent] = st.stacks[opponent] + excess
-                st.pot_size = st.pot_size - excess
-                st.total_contrib[opponent] -= excess
-                st._advance_street_if_closed(actor=player)
-                st._fast_forward_to_showdown_if_allin_locked()
+            opponent = (player + 1) % 2
+            if to_call == 0:
+                    target = st.pot_size * 2.0
+                    if target < st.big_blind:
+                            target = st.big_blind
+                    if target > st.stacks[player]:
+                            target = st.stacks[player]
+                    bet_amt = int(target) if isinstance(target, float) else target
+                    if bet_amt > 0:
+                            st.stacks[player] = st.stacks[player] - bet_amt
+                            st.current_bets[player] = st.current_bets[player] + bet_amt
+                            st.pot_size = st.pot_size + bet_amt
+                            st.total_contrib[player] += bet_amt
+                            st.last_raiser = player
+                            st.last_raise_increment = bet_amt
+                            min_raise_inc = st._min_raise_size()
+                            if st.stacks[player] == 0 and bet_amt < min_raise_inc:
+                                    st.last_raise_was_allin_below_min = player
+                            else:
+                                    st.last_raise_was_allin_below_min = None
+                            st.consecutive_checks = 0
             else:
-                pot_after_call = st.pot_size
-                min_raise_inc = st._min_raise_size()
-                two_pot_inc = pot_after_call * 2.0
-                raise_inc = two_pot_inc if two_pot_inc > min_raise_inc else min_raise_inc
-                if raise_inc > st.stacks[player]:
-                    raise_inc = st.stacks[player]
-                raise_inc = int(raise_inc) if isinstance(raise_inc, float) else raise_inc
-                if raise_inc > 0:
-                    st.stacks[player] = st.stacks[player] - raise_inc
-                    st.current_bets[player] = st.current_bets[player] + raise_inc
-                    st.pot_size = st.pot_size + raise_inc
-                    st.total_contrib[player] += raise_inc
-                    if raise_inc >= min_raise_inc:
-                        st.last_raiser = player
-                        st.last_raise_increment = raise_inc
-                        st.last_raise_was_allin_below_min = None
+                    caller_stack_before = st.stacks[player]
+                    matched = caller_stack_before if caller_stack_before < to_call else to_call
+                    st.stacks[player] = st.stacks[player] - matched
+                    st.current_bets[player] = st.current_bets[player] + matched
+                    st.pot_size = st.pot_size + matched
+                    st.total_contrib[player] += matched
+                    if matched < to_call:
+                            excess = to_call - matched
+                            st.last_refund_amount = float(excess)
+                            st.current_bets[opponent] = st.current_bets[opponent] - excess
+                            st.stacks[opponent] = st.stacks[opponent] + excess
+                            st.pot_size = st.pot_size - excess
+                            st.total_contrib[opponent] -= excess
+                            st._advance_street_if_closed(actor=player)
+                            st._fast_forward_to_showdown_if_allin_locked()
                     else:
-                        if st.stacks[player] == 0:
-                            st.last_raise_was_allin_below_min = player
-                    st.consecutive_checks = 0
-        if st.current_bets[player] == st.current_bets[opponent]:
-            st._advance_street_if_closed(actor=player)
-            st._fast_forward_to_showdown_if_allin_locked()
-
-	def _apply_all_in(self, st, player, to_call):
-		opponent = (player + 1) % 2
-		my_bet = st.current_bets[player]
-		opp_bet = st.current_bets[opponent]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-		caller_stack_before = st.stacks[player]
-		matched = caller_stack_before if caller_stack_before < to_call else to_call
-		st.stacks[player] = st.stacks[player] - matched
-		st.current_bets[player] = st.current_bets[player] + matched
-		st.pot_size = st.pot_size + matched
-		st.total_contrib[player] += matched
-		if matched < to_call:
-			excess = to_call - matched
-			st.last_refund_amount = float(excess)
-			st.current_bets[opponent] = st.current_bets[opponent] - excess
-			st.stacks[opponent] = st.stacks[opponent] + excess
-			st.pot_size = st.pot_size - excess
-			st.total_contrib[opponent] -= excess
-			st._advance_street_if_closed(actor=player)
-			st._fast_forward_to_showdown_if_allin_locked()
-		else:
-			all_in_amount_remaining = st.stacks[player]
-			if all_in_amount_remaining < 0:
-				all_in_amount_remaining = 0
-			if all_in_amount_remaining > 0:
-				st.current_bets[player] = st.current_bets[player] + all_in_amount_remaining
-				st.stacks[player] = 0
-				st.pot_size = st.pot_size + all_in_amount_remaining
-				st.total_contrib[player] += all_in_amount_remaining
-				increment_above_call = all_in_amount_remaining
-				min_raise_inc = st._min_raise_size()
-				if to_call == 0:
-					st.last_raiser = player
-					st.last_raise_increment = all_in_amount_remaining
-					st.last_raise_was_allin_below_min = None if all_in_amount_remaining >= min_raise_inc else player
-				else:
-					if increment_above_call >= min_raise_inc:
-						st.last_raiser = player
-						st.last_raise_increment = increment_above_call
-						st.last_raise_was_allin_below_min = None
-					else:
-						st.last_raise_was_allin_below_min = player
-				st.consecutive_checks = 0
-		if st.current_bets[player] == st.current_bets[opponent]:
-			st._advance_street_if_closed(actor=player)
-			st._fast_forward_to_showdown_if_allin_locked()
-
-
-	def apply_exogenous_opponent_all_in(self, bettor):
-		if self.is_terminal:
-			return self
-		if bettor not in (0, 1):
-			return self
-		prev_pot = float(self.pot_size)
-		self.last_refund_amount = 0.0
-		other = (bettor + 1) % 2
-		my_bet = self.current_bets[bettor]
-		opp_bet = self.current_bets[other]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-		caller_stack_before = self.stacks[bettor]
-		matched = caller_stack_before if caller_stack_before < to_call else to_call
-		self.stacks[bettor] = caller_stack_before - matched
-		self.current_bets[bettor] = self.current_bets[bettor] + matched
-		self.pot_size = self.pot_size + matched
-		if matched > 0:
-			self.total_contrib[bettor] += matched
-		if matched < to_call:
-			excess = to_call - matched
-			self.last_refund_amount = float(excess)
-			self.current_bets[other] = self.current_bets[other] - excess
-			self.stacks[other] = self.stacks[other] + excess
-			self.pot_size = self.pot_size - excess
-			self.total_contrib[other] -= excess
-			self._advance_street_if_closed(actor=bettor)
-			self._fast_forward_to_showdown_if_allin_locked()
-		else:
-			all_in_amount_remaining = self.stacks[bettor]
-			if all_in_amount_remaining < 0:
-				all_in_amount_remaining = 0
-			if all_in_amount_remaining > 0:
-				self.current_bets[bettor] = self.current_bets[bettor] + all_in_amount_remaining
-				self.stacks[bettor] = 0
-				self.pot_size = self.pot_size + all_in_amount_remaining
-				self.total_contrib[bettor] += all_in_amount_remaining
-				increment_above_call = all_in_amount_remaining
-				min_raise_inc = self._min_raise_size()
-				if to_call == 0:
-					self.last_raiser = bettor
-					self.last_raise_increment = all_in_amount_remaining
-					self.last_raise_was_allin_below_min = None if all_in_amount_remaining >= min_raise_inc else bettor
-				else:
-					if increment_above_call >= min_raise_inc:
-						self.last_raiser = bettor
-						self.last_raise_increment = increment_above_call
-						self.last_raise_was_allin_below_min = None
-					else:
-						self.last_raise_was_allin_below_min = bettor
-		if self.current_bets[bettor] == self.current_bets[other]:
-			self._advance_street_if_closed(actor=bettor)
-			self._fast_forward_to_showdown_if_allin_locked()
-		if not self.is_terminal:
-			if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
-				self.current_player = other
-		if self.players_in_hand.count(True) == 1:
-			self.is_terminal = True
-		if self.pot_size < 0:
-			self.pot_size = 0
-		i = 0
-		while i < 2:
-			if self.stacks[i] > self.initial_stacks[i]:
-				self.stacks[i] = self.initial_stacks[i]
-			if self.current_bets[i] < 0:
-				self.current_bets[i] = 0
-			i = i + 1
-		self.last_action = ("EXOGENOUS_ALL_IN", int(bettor))
-		self._assert_invariants(prev_pot=prev_pot)
-		return self
-
-
-
-	def apply_exogenous_opponent_check(self, actor):
-		if self.is_terminal:
-			return self
-		if actor not in (0, 1):
-			return self
-		if self.current_player is None or int(self.current_player) != int(actor):
-			return self
-		legal = set(self.legal_actions())
-		if ActionType.CALL not in legal:
-			return self
-		p = actor
-		o = (p + 1) % 2
-		my_bet = self.current_bets[p]
-		opp_bet = self.current_bets[o]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-		if to_call != 0:
-			return self
-		prev_pot = float(self.pot_size)
-		self.last_refund_amount = 0.0
-		self.consecutive_checks = self.consecutive_checks + 1
-		self._last_action_was_call_on_bet = False
-		if self.current_bets[p] == self.current_bets[o]:
-			self._advance_street_if_closed(actor=p)
-			self._fast_forward_to_showdown_if_allin_locked()
-		if not self.is_terminal:
-			if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
-				self.current_player = o
-		self.last_action = ("EXOGENOUS_CHECK", int(actor))
-		self._assert_invariants(prev_pot=prev_pot)
-		return self
-
-	def apply_exogenous_opponent_bet(self, bettor, kind):
-		if self.is_terminal:
-			return self
-		if bettor not in (0, 1):
-			return self
-		if kind == ActionType.ALL_IN:
-			return self.apply_exogenous_opponent_all_in(bettor)
-		if kind not in (ActionType.HALF_POT_BET, ActionType.POT_SIZED_BET, ActionType.TWO_POT_BET):
-			return self
-		if self.current_player is None or int(self.current_player) != int(bettor):
-			return self
-		legal = set(self.legal_actions())
-		if kind not in legal:
-			return self
-		prev_pot = float(self.pot_size)
-		self.last_refund_amount = 0.0
-		p = bettor
-		o = (p + 1) % 2
-		my_bet = self.current_bets[p]
-		opp_bet = self.current_bets[o]
-		to_call = opp_bet - my_bet
-		if to_call < 0:
-			to_call = 0
-		if kind == ActionType.HALF_POT_BET:
-			self._apply_half_pot_bet(self, p, to_call)
-		elif kind == ActionType.POT_SIZED_BET:
-			self._apply_pot_sized_bet(self, p, to_call)
-		elif kind == ActionType.TWO_POT_BET:
-			self._apply_two_pot_bet(self, p, to_call)
-		if not self.is_terminal:
-			if not (self.current_bets[0] == 0 and self.current_bets[1] == 0 and self.current_round >= 1 and self.last_raiser is None):
-				self.current_player = o
-		self.last_action = ("EXOGENOUS_BET", int(kind.value))
-		self._assert_invariants(prev_pot=prev_pot)
-		return self
+                            pot_after_call = st.pot_size
+                            min_raise_inc = st._min_raise_size()
+                            two_pot_inc = pot_after_call * 2.0
+                            raise_inc = two_pot_inc if two_pot_inc > min_raise_inc else min_raise_inc
+                            if raise_inc > st.stacks[player]:
+                                    raise_inc = st.stacks[player]
+                            raise_inc = int(raise_inc) if isinstance(raise_inc, float) else raise_inc
+                            if raise_inc > 0:
+                                    st.stacks[player] = st.stacks[player] - raise_inc
+                                    st.current_bets[player] = st.current_bets[player] + raise_inc
+                                    st.pot_size = st.pot_size + raise_inc
+                                    st.total_contrib[player] += raise_inc
+                                    if raise_inc >= min_raise_inc:
+                                            st.last_raiser = player
+                                            st.last_raise_increment = raise_inc
+                                            st.last_raise_was_allin_below_min = None
+                                    else:
+                                            if st.stacks[player] == 0:
+                                                    st.last_raise_was_allin_below_min = player
+                                    st.consecutive_checks = 0
+            if st.current_bets[player] == st.current_bets[opponent]:
+                    st._advance_street_if_closed(actor=player)
+                    st._fast_forward_to_showdown_if_allin_locked()
+
