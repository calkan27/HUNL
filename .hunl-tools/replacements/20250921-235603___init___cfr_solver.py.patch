--- a/cfr_solver.py
+++ b/cfr_solver.py
@@ -21,51 +21,53 @@
 
 
 class CFRSolver:
-	def __init__(self, depth_limit=4, num_clusters=10, all_possible_hands=None, speed_profile: str = "bot", hand_clusterer=None, config=None):
-		self._config = config
-		if self._config is not None:
-			self.depth_limit = int(self._config.depth_limit)
-			self.num_clusters = int(self._config.num_clusters)
-			self.speed_profile = self._config.profile
-			self.total_iterations = int(self._config.total_iterations)
-		else:
-			self.depth_limit = depth_limit
-			self.num_clusters = num_clusters
-			self.speed_profile = speed_profile
-			self.total_iterations = 20
-		self.cfr_values = defaultdict(CFRValues)
-		self.all_possible_hands = all_possible_hands or self.generate_all_possible_hands()
-		self.opponent_counterfactual_values = {}
-		self.iteration = 0
-		if hand_clusterer is not None:
-			self.hand_clusterer = hand_clusterer
-		elif not hasattr(self, "hand_clusterer") or self.hand_clusterer is None:
-			if self._config is not None:
-				self.hand_clusterer = HandClusterer(self, num_clusters=self.num_clusters, profile=self.speed_profile, opp_sample_size=self._config.opp_sample_size, use_cfv_in_features=self._config.use_cfv_in_features, config=self._config)
-			else:
-				self.hand_clusterer = HandClusterer(self, num_clusters=self.num_clusters, profile=self.speed_profile)
-		self.clusters = {}
-		self._evaluate_hand_strength_cache = {}
-		self._recursive_range_sampling_cache = {}
-		self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
-		self.models = {
-			'preflop': CounterfactualValueNetwork(self.calculate_input_size_preflop(), num_clusters=self.num_clusters).to(self.device),
-			'flop': CounterfactualValueNetwork(self.calculate_input_size(), num_clusters=self.num_clusters).to(self.device),
-			'turn': CounterfactualValueNetwork(self.calculate_input_size(), num_clusters=self.num_clusters).to(self.device),
-		}
-		if self._config is not None and self._config.profile == "test":
-			self.models['preflop'].eval()
-			self.models['flop'].eval()
-			self.models['turn'].eval()
-		from collections import OrderedDict as _OD
-		self._preflop_cache = _OD()
-		self._preflop_cache_cap = int(getattr(self._config, "preflop_cache_max_entries", 10000)) if getattr(self, "_config", None) is not None else 10000
-		self._preflop_cache_stats = {"hits": 0, "misses": 0, "puts": 0, "evictions": 0}
-		from river_endgame import RiverEndgame
-		if self._config is not None:
-			self.river_endgame = RiverEndgame(num_buckets=getattr(self._config, "river_num_buckets", None), max_sample_per_cluster=getattr(self._config, "river_max_sample_per_cluster", None), seed=getattr(self._config, "fast_test_seed", 2027))
-		else:
-			self.river_endgame = RiverEndgame()
+    def __init__(self, depth_limit=4, num_clusters=10, all_possible_hands=None, speed_profile: str = "bot", hand_clusterer=None, config=None):
+        self._config = config
+        if self._config is not None:
+            self.depth_limit = int(self._config.depth_limit)
+            self.num_clusters = int(self._config.num_clusters)
+            self.speed_profile = self._config.profile
+            self.total_iterations = int(self._config.total_iterations)
+            self.constraint_mode = str(getattr(self._config, "constraint_mode", "sp"))
+        else:
+            self.depth_limit = depth_limit
+            self.num_clusters = num_clusters
+            self.speed_profile = speed_profile
+            self.total_iterations = 20
+            self.constraint_mode = "sp"
+        self.cfr_values = defaultdict(CFRValues)
+        self.all_possible_hands = all_possible_hands or self.generate_all_possible_hands()
+        self.opponent_counterfactual_values = {}
+        self.iteration = 0
+        if hand_clusterer is not None:
+            self.hand_clusterer = hand_clusterer
+        elif not hasattr(self, "hand_clusterer") or self.hand_clusterer is None:
+            if self._config is not None:
+                self.hand_clusterer = HandClusterer(self, num_clusters=self.num_clusters, profile=self.speed_profile, opp_sample_size=self._config.opp_sample_size, use_cfv_in_features=self._config.use_cfv_in_features, config=self._config)
+            else:
+                self.hand_clusterer = HandClusterer(self, num_clusters=self.num_clusters, profile=self.speed_profile)
+        self.clusters = {}
+        self._evaluate_hand_strength_cache = {}
+        self._recursive_range_sampling_cache = {}
+        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
+        self.models = {
+            'preflop': CounterfactualValueNetwork(self.calculate_input_size_preflop(), num_clusters=self.num_clusters).to(self.device),
+            'flop': CounterfactualValueNetwork(self.calculate_input_size(), num_clusters=self.num_clusters).to(self.device),
+            'turn': CounterfactualValueNetwork(self.calculate_input_size(), num_clusters=self.num_clusters).to(self.device),
+        }
+        if self._config is not None and self._config.profile == "test":
+            self.models['preflop'].eval()
+            self.models['flop'].eval()
+            self.models['turn'].eval()
+        from collections import OrderedDict as _OD
+        self._preflop_cache = _OD()
+        self._preflop_cache_cap = int(getattr(self._config, "preflop_cache_max_entries", 10000)) if getattr(self, "_config", None) is not None else 10000
+        self._preflop_cache_stats = {"hits": 0, "misses": 0, "puts": 0, "evictions": 0}
+        from river_endgame import RiverEndgame
+        if self._config is not None:
+            self.river_endgame = RiverEndgame(num_buckets=getattr(self._config, "river_num_buckets", None), max_sample_per_cluster=getattr(self._config, "river_max_sample_per_cluster", None), seed=getattr(self._config, "fast_test_seed", 2027))
+        else:
+            self.river_endgame = RiverEndgame()
 
 	def reset(self):
 		self.cfr_values = defaultdict(CFRValues)
