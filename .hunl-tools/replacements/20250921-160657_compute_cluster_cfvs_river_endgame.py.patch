--- a/river_endgame.py
+++ b/river_endgame.py
@@ -88,226 +88,158 @@
 		return ev_p, ev_o
 
     def compute_cluster_cfvs(self, clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn):
-        board = list(node.public_state.board_cards)
-        board_set = set(board)
-        pot_size = float(node.public_state.pot_size)
-        p0_bet = float(node.public_state.current_bets[0])
-        p1_bet = float(node.public_state.current_bets[1])
-        total_initial = sum(node.public_state.initial_stacks) if getattr(node.public_state, "initial_stacks", None) else 1.0
-        if total_initial <= 0:
-            total_initial = 1.0
-        my = player
-        opp = (player + 1) % 2
-        my_range_raw = dict(node.player_ranges[my])
-        opp_range_raw = dict(node.player_ranges[opp])
-        s1 = sum(my_range_raw.values())
-        s2 = sum(opp_range_raw.values())
-        if s1 > 0:
-            for k in list(my_range_raw.keys()):
-                my_range_raw[k] = my_range_raw[k] / s1
-        else:
-            for k in list(my_range_raw.keys()):
-                my_range_raw[k] = 0.0
-        if s2 > 0:
-            for k in list(opp_range_raw.keys()):
-                opp_range_raw[k] = opp_range_raw[k] / s2
-        else:
-            for k in list(opp_range_raw.keys()):
-                opp_range_raw[k] = 0.0
-        my_range = my_range_raw
-        opp_range = opp_range_raw
-        ev_p_by_cluster = {}
-        ev_o_by_cluster = {}
-        if self.num_buckets is None or self.num_buckets <= 0:
-            for cid in my_range.keys():
-                my_hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
-                my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
-                if not my_hands:
-                    ev_p_by_cluster[int(cid)] = 0.0
-                    continue
-                ev_total_p = 0.0
-                my_w = 1.0 / float(len(my_hands))
-                for my_h in my_hands:
-                    c1, c2 = my_h.split()
-                    my_cards = [c1, c2]
+            board = list(node.public_state.board_cards)
+            board_set = set(board)
+            pot_size = float(node.public_state.pot_size)
+            p0_bet = float(node.public_state.current_bets[0])
+            p1_bet = float(node.public_state.current_bets[1])
+
+            total_initial = sum(node.public_state.initial_stacks) if getattr(node.public_state, "initial_stacks", None) else 1.0
+            if total_initial <= 0:
+                    total_initial = 1.0
+
+            my = player
+            opp = (player + 1) % 2
+
+            my_range_raw = dict(node.player_ranges[my])
+            opp_range_raw = dict(node.player_ranges[opp])
+
+            s1 = sum(my_range_raw.values())
+            s2 = sum(opp_range_raw.values())
+            if s1 > 0:
+                    for k in list(my_range_raw.keys()):
+                            my_range_raw[k] = my_range_raw[k] / s1
+            else:
+                    for k in list(my_range_raw.keys()):
+                            my_range_raw[k] = 0.0
+            if s2 > 0:
+                    for k in list(opp_range_raw.keys()):
+                            opp_range_raw[k] = opp_range_raw[k] / s2
+            else:
+                    for k in list(opp_range_raw.keys()):
+                            opp_range_raw[k] = 0.0
+
+            my_range = my_range_raw
+            opp_range = opp_range_raw
+
+            ev_p_by_cluster = {}
+            ev_o_by_cluster = {}
+
+            # No-bucket path
+            if self.num_buckets is None or self.num_buckets <= 0:
+                    for cid in my_range.keys():
+                            my_hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
+                            my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
+                            if not my_hands:
+                                    ev_p_by_cluster[int(cid)] = 0.0
+                                    continue
+
+                            ev_total_p = 0.0
+                            my_w = 1.0 / float(len(my_hands))
+
+                            for my_h in my_hands:
+                                    c1, c2 = my_h.split()
+                                    my_cards = [c1, c2]
+                                    for oid, oprob in opp_range.items():
+                                            if float(oprob) <= 0.0:
+                                                    continue
+                                            opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
+                                            opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
+                                            if not opp_hands:
+                                                    continue
+                                            opp_w = (oprob / float(len(opp_hands))) if len(opp_hands) > 0 else 0.0
+                                            for o_h in opp_hands:
+                                                    d1, d2 = o_h.split()
+                                                    opp_cards = [d1, d2]
+                                                    up, uo = self._expected_utility_pairwise(
+                                                            my_cards, opp_cards, board, wins_fn,
+                                                            pot_size, p0_bet if my == 0 else p1_bet, p1_bet if my == 0 else p0_bet
+                                                    )
+                                                    ev_total_p += my_w * opp_w * up
+                                                    if oid not in ev_o_by_cluster:
+                                                            ev_o_by_cluster[int(oid)] = 0.0
+                                                    ev_o_by_cluster[int(oid)] += my_w * opp_w * uo
+                            ev_p_by_cluster[int(cid)] = ev_total_p
+
+                    for k in list(opp_range.keys()):
+                            if int(k) not in ev_o_by_cluster:
+                                    ev_o_by_cluster[int(k)] = 0.0
+
+            # Bucketed path
+            else:
+                    all_strengths = []
+                    for cid in my_range.keys():
+                            my_hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
+                            my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
+                            if my_hands:
+                                    all_strengths.extend(self._cluster_distribution(my_hands, board, best_hand_fn, hand_rank_fn))
+                    for oid in opp_range.keys():
+                            opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
+                            opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
+                            if opp_hands:
+                                    all_strengths.extend(self._cluster_distribution(opp_hands, board, best_hand_fn, hand_rank_fn))
+
+                    bmap, B = self._bucketize(all_strengths)
+                    if bmap is None:
+                            return self.compute_cluster_cfvs(clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn)
+
+                    # Opponent bucket mix
+                    opp_bucket_mix = [0.0] * B
                     for oid, oprob in opp_range.items():
-                        if float(oprob) <= 0.0:
-                            continue
-                        opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
-                        opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
-                        if not opp_hands:
-                            continue
-                        opp_w = (oprob / float(len(opp_hands))) if len(opp_hands) > 0 else 0.0
-                        for o_h in opp_hands:
-                            d1, d2 = o_h.split()
-                            opp_cards = [d1, d2]
-                            up, uo = self._expected_utility_pairwise(my_cards, opp_cards, board, wins_fn, pot_size, p0_bet if my == 0 else p1_bet, p1_bet if my == 0 else p0_bet)
-                            ev_total_p += my_w * opp_w * up
-                            if oid not in ev_o_by_cluster:
-                                ev_o_by_cluster[int(oid)] = 0.0
-                            ev_o_by_cluster[int(oid)] += my_w * opp_w * uo
-                ev_p_by_cluster[int(cid)] = ev_total_p
-            for k in list(opp_range.keys()):
-                if int(k) not in ev_o_by_cluster:
-                    ev_o_by_cluster[int(k)] = 0.0
-        else:
-            all_strengths = []
-            for cid in my_range.keys():
-                my_hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
-                my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
-                if my_hands:
-                    all_strengths.extend(self._cluster_distribution(my_hands, board, best_hand_fn, hand_rank_fn))
-            for oid in opp_range.keys():
-                opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
-                opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
-                if opp_hands:
-                    all_strengths.extend(self._cluster_distribution(opp_hands, board, best_hand_fn, hand_rank_fn))
-            bmap, B = self._bucketize(all_strengths)
-            if bmap is None:
-                return self.compute_cluster_cfvs(clusters, node, player, wins_fn, best_hand_fn, hand_rank_fn)
-            opp_bucket_mix = [0.0] * B
-            for oid, oprob in opp_range.items():
-                if float(oprob) <= 0.0:
-                    continue
-                opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
-                opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
-                if not opp_hands:
-                    continue
-                for s in self._cluster_distribution(opp_hands, board, best_hand_fn, hand_rank_fn):
-                    opp_bucket_mix[bmap[s]] += float(oprob)
-            t = sum(opp_bucket_mix)
-            if t > 0:
-                i = 0
-                while i < B:
-                    opp_bucket_mix[i] = opp_bucket_mix[i] / t
-                    i += 1
-            for cid in my_range.keys():
-                my_hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
-                my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
-                if not my_hands:
-                    ev_p_by_cluster[int(cid)] = 0.0
-                    continue
-                my_bucket_mix = [0.0] * B
-                for s in self._cluster_distribution(my_hands, board, best_hand_fn, hand_rank_fn):
-                    my_bucket_mix[bmap[s]] += 1.0
-                tm = sum(my_bucket_mix)
-                if tm > 0:
-                    i = 0
-                    while i < B:
-                        my_bucket_mix[i] = my_bucket_mix[i] / tm
-                        i += 1
-                ev_p, _ev_o = self._expected_utility_buckets_both(my_bucket_mix, opp_bucket_mix, B, p0_bet if my == 0 else p1_bet, p1_bet if my == 0 else p0_bet)
-                ev_p_by_cluster[int(cid)] = ev_p
-            for oid in opp_range.keys():
-                opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
-                opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
-                if not opp_hands:
-                    ev_o_by_cluster[int(oid)] = 0.0
-                    continue
-                opp_bucket_mix_local = [0.0] * B
-                for s in self._cluster_distribution(opp_hands, board, best_hand_fn, hand_rank_fn):
-                    opp_bucket_mix_local[bmap[s]] += 1.0
-                tm = sum(opp_bucket_mix_local)
-                if tm > 0:
-                    i = 0
-                    while i < B:
-                        opp_bucket_mix_local[i] = opp_bucket_mix_local[i] / tm
-                        i += 1
-                _ev_p, ev_o = self._expected_utility_buckets_both(opp_bucket_mix_local, opp_bucket_mix, B, p1_bet if my == 0 else p0_bet, p0_bet if my == 0 else p1_bet)
-                ev_o_by_cluster[int(oid)] = ev_o
-        scale = 1.0 / float(total_initial)
-        if player == 0:
+                            if float(oprob) <= 0.0:
+                                    continue
+                            opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
+                            opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
+                            if not opp_hands:
+                                    continue
+                            for s in self._cluster_distribution(opp_hands, board, best_hand_fn, hand_rank_fn):
+                                    opp_bucket_mix[bmap[s]] += float(oprob)
+                    t = sum(opp_bucket_mix)
+                    if t > 0:
+                            for i in range(B):
+                                    opp_bucket_mix[i] = opp_bucket_mix[i] / t
+
+                    # My buckets & EV
+                    for cid in my_range.keys():
+                            my_hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
+                            my_hands = self._sample(my_hands_full, self.max_sample_per_cluster, 1000 + int(cid))
+                            if not my_hands:
+                                    ev_p_by_cluster[int(cid)] = 0.0
+                                    continue
+                            my_bucket_mix = [0.0] * B
+                            for s in self._cluster_distribution(my_hands, board, best_hand_fn, hand_rank_fn):
+                                    my_bucket_mix[bmap[s]] += 1.0
+                            tm = sum(my_bucket_mix)
+                            if tm > 0:
+                                    for i in range(B):
+                                            my_bucket_mix[i] = my_bucket_mix[i] / tm
+                            ev_p, _ = self._expected_utility_buckets_both(
+                                    my_bucket_mix, opp_bucket_mix, B,
+                                    p0_bet if my == 0 else p1_bet, p1_bet if my == 0 else p0_bet
+                            )
+                            ev_p_by_cluster[int(cid)] = ev_p
+
+                    # Opponent EVs by cluster (optional bookkeeping parity)
+                    for oid in opp_range.keys():
+                            opp_hands_full = self._filter_hands(clusters.get(int(oid), []), board_set)
+                            opp_hands = self._sample(opp_hands_full, self.max_sample_per_cluster, 2000 + int(oid))
+                            if not opp_hands:
+                                    ev_o_by_cluster[int(oid)] = 0.0
+                                    continue
+                            opp_bucket_mix_local = [0.0] * B
+                            for s in self._cluster_distribution(opp_hands, board, best_hand_fn, hand_rank_fn):
+                                    opp_bucket_mix_local[bmap[s]] += 1.0
+                            tm = sum(opp_bucket_mix_local)
+                            if tm > 0:
+                                    for i in range(B):
+                                            opp_bucket_mix_local[i] = opp_bucket_mix_local[i] / tm
+                            _, ev_o = self._expected_utility_buckets_both(
+                                    opp_bucket_mix_local, opp_bucket_mix, B,
+                                    p1_bet if my == 0 else p0_bet, p0_bet if my == 0 else p1_bet
+                            )
+                            ev_o_by_cluster[int(oid)] = ev_o
+
+            scale = 1.0 / float(total_initial)
             out = {int(cid): [ev_p_by_cluster.get(int(cid), 0.0) * scale] * 4 for cid in my_range.keys()}
-        else:
-            out = {int(cid): [ev_p_by_cluster.get(int(cid), 0.0) * scale] * 4 for cid in my_range.keys()}
-        return out
-
-	def build_bucketizer(self, clusters, node):
-		board = list(node.public_state.board_cards)
-		board_set = set(board)
-		all_strengths = []
-		my_range = node.player_ranges[0]
-		opp_range = node.player_ranges[1]
-		for cid in set(list(my_range.keys()) + list(opp_range.keys())):
-			hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
-			hands = self._sample(hands_full, self.max_sample_per_cluster, 3000 + int(cid))
-			if hands:
-				all_strengths.extend(self._cluster_distribution(hands, board, node.cfr_solver._player_wins.__self__.best_hand, node.cfr_solver._player_wins.__self__.hand_rank))
-		bmap, B = self._bucketize(all_strengths)
-		return bmap, B
-	def bucket_mix_for_cluster(self, clusters, cid, bmap, B, node):
-		board = list(node.public_state.board_cards)
-		board_set = set(board)
-		mix = [0.0] * int(B)
-		hands_full = self._filter_hands(clusters.get(int(cid), []), board_set)
-		hands = self._sample(hands_full, self.max_sample_per_cluster, 4000 + int(cid))
-		if not hands or bmap is None:
-			return mix
-		strengths = self._cluster_distribution(hands, board, node.cfr_solver._player_wins.__self__.best_hand, node.cfr_solver._player_wins.__self__.hand_rank)
-		for s in strengths:
-			mix[bmap[s]] += 1.0
-		t = sum(mix)
-		if t > 0:
-			i = 0
-			while i < len(mix):
-				mix[i] = mix[i] / t
-				i += 1
-		return mix
-	def generate_river_bucket_data(self, progress=None):
-		data = []
-		re = getattr(self.cfr_solver, "river_endgame", None)
-		if re is None or not isinstance(getattr(re, "num_buckets", None), int) or int(re.num_buckets) <= 0:
-			return data
-		boards = self.generate_unique_boards('river', self.num_boards)
-		for board_index, public_cards in enumerate(boards):
-			deck_without_board = [c for c in DECK if c not in public_cards]
-			possible_hands = [' '.join(h) for h in itertools.combinations(deck_without_board, 2)]
-			hands_set = set(possible_hands)
-			opponent_range_over_hands = {h: 1.0 / len(hands_set) for h in hands_set}
-			nominal_pot = 1.0
-			clusters = self.hand_clusterer.cluster_hands(hands_set, board=public_cards, opponent_range=opponent_range_over_hands, pot_size=nominal_pot)
-			self.cfr_solver.clusters = clusters
-			cluster_ids = list(range(self.num_clusters))
-			if callable(progress):
-				progress(1)
-			for sample_index in range(self.num_samples_per_board):
-				pot_size = self.sample_pot_size()
-				pr0 = self._sample_random_range(cluster_ids)
-				pr1 = self._sample_random_range(cluster_ids)
-				self.normalize_cluster_probabilities([pr0, pr1])
-				ps = PublicState(initial_stacks=[self.player_stack, self.player_stack], board_cards=public_cards)
-				ps.current_round = 3
-				ps.current_bets = [0, 0]
-				ps.pot_size = pot_size
-				ps.stacks = [self.player_stack, self.player_stack]
-				ps.current_player = (ps.dealer + 1) % 2
-				node = GameNode(ps)
-				node.player_ranges[0] = pr0
-				node.player_ranges[1] = pr1
-				bmap, B = self.cfr_solver.river_endgame.build_bucketizer(self.cfr_solver.clusters, node)
-				if bmap is None or B is None:
-					continue
-				bucket_mats = {}
-				for cid in cluster_ids:
-					bucket_mats[int(cid)] = self.cfr_solver.river_endgame.bucket_mix_for_cluster(self.cfr_solver.clusters, int(cid), bmap, B, node)
-				cf = self.cfr_solver.river_endgame.compute_cluster_cfvs(self.cfr_solver.clusters, node, player=0, wins_fn=lambda ph,oh,board: self.cfr_solver._player_wins(ph,oh,board), best_hand_fn=best_hand, hand_rank_fn=hand_rank)
-				target_v1 = [0.0] * self.num_clusters
-				for cid in cluster_ids:
-					target_v1[int(cid)] = float(cf.get(int(cid), [0.0])[0])
-				cf2 = self.cfr_solver.river_endgame.compute_cluster_cfvs(self.cfr_solver.clusters, node, player=1, wins_fn=lambda ph,oh,board: self.cfr_solver._player_wins(ph,oh,board), best_hand_fn=best_hand, hand_rank_fn=hand_rank)
-				target_v2 = [0.0] * self.num_clusters
-				for cid in cluster_ids:
-					target_v2[int(cid)] = float(cf2.get(int(cid), [0.0])[0])
-				record = {
-					"board": list(public_cards),
-					"pot_norm": pot_size / float(2 * self.player_stack) if self.player_stack > 0 else 0.0,
-					"bucketizer_B": int(B),
-					"bucket_mix_by_cluster": bucket_mats,
-					"target_v1": target_v1,
-					"target_v2": target_v2,
-				}
-				data.append(record)
-				if callable(progress):
-					progress(1)
-		return data
-
+            return out
+
